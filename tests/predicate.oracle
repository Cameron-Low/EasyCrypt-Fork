add type 'a list.
add type 'a option.
add type ('a,'b)map.
add op [=] : ('a, 'a) -> bool.
add op [&&] : (bool, bool) -> bool.
add op [||] : (bool, bool) -> bool.
add op [^^] : (bool, bool) -> bool.
add op [!] : bool -> bool.
add op [<] : (int, int) -> bool.
add op [<=] : (int, int) -> bool.
add op [-] : int -> int.
add op [+] : (int, int) -> int.
add op [-] : (int, int) -> int.
add op [*] : (int, int) -> int.
add op [/] : (int, int) -> int.
add op [%] : (int, int) -> int.
add op [^] : (int, int) -> int.
add op abs : int -> int.
add op [<] : (real, real) -> bool.
add op [<=] : (real, real) -> bool.
add op [-] : real -> real.
add op [+] : (real, real) -> real.
add op [-] : (real, real) -> real.
add op [*] : (real, real) -> real.
add op [/] : (real, real) -> real.
add op [^] : (real, real) -> real.
add op real_of_int : int -> real.
add op real_of_bool : bool -> real.
add op abs : real -> real.
add op exp : real -> real.
add op Some : 'a -> 'a option.
add cnst None : 'a option
add op [::] : ('a, 'a list) -> 'a list.
add cnst [] : 'a list
add op mem : ('a, 'a list) -> bool.
add op length : 'a list -> int.
add op [++] : ('a list, 'a list) -> 'a list.
add op upd : (('a,'b)map, 'a, 'b) -> ('a,'b)map.
add op get : (('a,'b)map, 'a) -> 'b.
add op in_dom : ('a, ('a,'b)map) -> bool.
add op in_rng : ('b, ('a,'b)map) -> bool.
 Read src/easycrypt_base.ec
add op [>] (x, y : int) = y < x.
add op [>=] (x, y : int) = y <= x.
add op [>] (x, y : real) = y < x.
add op [>=] (x, y : real) = y <= x.
add op fst (p : 'a * 'b) = (let a,b = p in a).
add op snd (p : 'a * 'b) = (let a,b = p in b).
add axiom Some_inj : forall (x, y : 'a),Some (x) = Some (y) => x = y
add op proj : 'a option -> 'a.
add axiom Proj_Some : forall (x : 'a),proj (Some (x)) = x
add axiom Proj_eq :
  forall (o1, o2 : 'a option),
    o1 <> None => o2 <> None => proj (o1) = proj (o2) => o1 = o2
add axiom Some_or_None :
  forall (o : 'a option),o = None || (exists (x : 'a),o = Some (x))
add op hd : 'a list -> 'a.
add op tl : 'a list -> 'a list.
add axiom head_def : forall (a : 'a, l : 'a list),hd (a :: l) = a
add axiom tail_def : forall (a : 'a, l : 'a list),tl (a :: l) = l
add cnst empty_map : ('a,'b)map
add axiom get_upd_map_same :
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),a1 = a2 => m[a1 <- b][a2] = b
add axiom get_upd_map_diff :
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),
    a1 <> a2 => m[a1 <- b][a2] = m[a2]
add axiom upd_map_comm :
  forall (m : ('a,'b)map, a, a' : 'a, b, b' : 'b),
    a <> a' => m[a <- b][a' <- b'] = m[a' <- b'][a <- b]
add axiom upd_in_dom_same :
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),a = a' => in_dom (a',m[a <- b])
add axiom upd_in_dom_diff :
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),
    a <> a' => in_dom (a',m[a <- b]) <=> in_dom (a',m)
add axiom upd_in_rng_same :
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),b = b' => in_rng (b',m[a <- b])
add axiom upd_in_rng_diff :
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),
    b <> b' => in_rng (b',m[a <- b]) <=> in_rng (b',m)
add axiom in_dom_in_rng :
  forall (m : ('a,'b)map, a : 'a),in_dom (a,m) => in_rng (m[a],m)
add axiom in_rng_in_dom :
  forall (m : ('a,'b)map, b : 'b),
    in_rng (b,m) => exists (a : 'a),in_dom (a,m) && m[a] = b
add axiom empty_in_dom : forall (a : 'a),!in_dom (a,empty_map)
add axiom empty_in_rng : forall (b : 'b),!in_rng (b,empty_map)
add axiom real_of_bool_true : real_of_bool (true) = 1%r
add axiom real_of_bool_false : real_of_bool (false) = 0%r
add axiom real_of_int_le_compat : forall (x, y : int),x <= y => x%r <= y%r
add axiom real_of_int_lt_compat : forall (x, y : int),x < y => x%r < y%r
add axiom rmult_le_compat_l :
  forall (x, y, z : real),0%r <= x => y <= z => x * y <= x * z
add axiom rmult_le_compat_r :
  forall (x, y, z : real),0%r <= z => x <= y => x * z <= y * z
add axiom rmul_plus_distr_r :
  forall (x, y, z : real),(x + y) * z = x * z + y * z
add axiom rdiv_le_compat :
  forall (x1, x2, y1, y2 : real),
    0%r < y2 => y2 <= y1 => 0%r <= x1 => x1 <= x2 => x1 / y1 <= x2 / y2
add axiom rdiv_0_le :
  forall (x, y : real),0%r < y => 0%r <= x => 0%r <= x / y
add axiom pow2_pos : forall (n : int),0 <= n => 0 < 2 ^ n
 Read tests/predicate.ec
add type 'a list'.
add cnst nil : 'a list'
add op [::] : ('a, 'a list') -> 'a list'.
add op in_list' : ('b, 'b list') -> bool.
add type ilist' = int list'.
add op icons (x : int, l : ilist') = x :: l.
add op length : 'a list' -> int.
add cnst n : int = length (1 :: (2 :: nil))
add pred my_eq (x, y : 'a) = x = y.

add pred all_eq (x : 'c, l : 'c list') =
           forall (a : 'c),in_list' (a,l) => x = a.

add pred all1 (l : int list') = all_eq(1,l).

add pred alltrue (l : bool list') = all_eq(true,l).

add pred is_true (b : bool) = b.

 
add lemma toto : forall (b : bool),is_true(b) => b
add axiom in_list'_cons1 : forall (a : 'a, l : 'a list'),in_list' (a,a :: l)
 
add lemma alltrue_fst :
  forall (x, y : 'a, l : 'a list'),all_eq(x,y :: l) => x = y
 
add lemma test : forall (x, y : int),x + y = y + x
axiom Some_inj: forall (x, y : 'a),Some (x) = Some (y) => x = y
axiom Proj_Some: forall (x : 'a),proj (Some (x)) = x
axiom Proj_eq:
  forall (o1, o2 : 'a option),
    o1 <> None => o2 <> None => proj (o1) = proj (o2) => o1 = o2
axiom Some_or_None:
  forall (o : 'a option),o = None || (exists (x : 'a),o = Some (x))
axiom head_def: forall (a : 'a, l : 'a list),hd (a :: l) = a
axiom tail_def: forall (a : 'a, l : 'a list),tl (a :: l) = l
axiom get_upd_map_same:
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),a1 = a2 => m[a1 <- b][a2] = b
axiom get_upd_map_diff:
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),
    a1 <> a2 => m[a1 <- b][a2] = m[a2]
axiom upd_map_comm:
  forall (m : ('a,'b)map, a, a' : 'a, b, b' : 'b),
    a <> a' => m[a <- b][a' <- b'] = m[a' <- b'][a <- b]
axiom upd_in_dom_same:
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),a = a' => in_dom (a',m[a <- b])
axiom upd_in_dom_diff:
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),
    a <> a' => in_dom (a',m[a <- b]) <=> in_dom (a',m)
axiom upd_in_rng_same:
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),b = b' => in_rng (b',m[a <- b])
axiom upd_in_rng_diff:
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),
    b <> b' => in_rng (b',m[a <- b]) <=> in_rng (b',m)
axiom in_dom_in_rng:
  forall (m : ('a,'b)map, a : 'a),in_dom (a,m) => in_rng (m[a],m)
axiom in_rng_in_dom:
  forall (m : ('a,'b)map, b : 'b),
    in_rng (b,m) => exists (a : 'a),in_dom (a,m) && m[a] = b
axiom empty_in_dom: forall (a : 'a),!in_dom (a,empty_map)
axiom empty_in_rng: forall (b : 'b),!in_rng (b,empty_map)
axiom real_of_bool_true: real_of_bool (true) = 1%r
axiom real_of_bool_false: real_of_bool (false) = 0%r
axiom real_of_int_le_compat: forall (x, y : int),x <= y => x%r <= y%r
axiom real_of_int_lt_compat: forall (x, y : int),x < y => x%r < y%r
axiom rmult_le_compat_l:
  forall (x, y, z : real),0%r <= x => y <= z => x * y <= x * z
axiom rmult_le_compat_r:
  forall (x, y, z : real),0%r <= z => x <= y => x * z <= y * z
axiom rmul_plus_distr_r: forall (x, y, z : real),(x + y) * z = x * z + y * z
axiom rdiv_le_compat:
  forall (x1, x2, y1, y2 : real),
    0%r < y2 => y2 <= y1 => 0%r <= x1 => x1 <= x2 => x1 / y1 <= x2 / y2
axiom rdiv_0_le: forall (x, y : real),0%r < y => 0%r <= x => 0%r <= x / y
axiom pow2_pos: forall (n : int),0 <= n => 0 < 2 ^ n
axiom toto: forall (b : bool),is_true(b) => b
axiom in_list'_cons1: forall (a : 'a, l : 'a list'),in_list' (a,a :: l)
axiom alltrue_fst: forall (x, y : 'a, l : 'a list'),all_eq(x,y :: l) => x = y
axiom test: forall (x, y : int),x + y = y + x
axiom Some_inj: forall (x, y : 'a),Some (x) = Some (y) => x = y
axiom Proj_Some: forall (x : 'a),proj (Some (x)) = x
axiom Proj_eq:
  forall (o1, o2 : 'a option),
    o1 <> None => o2 <> None => proj (o1) = proj (o2) => o1 = o2
axiom Some_or_None:
  forall (o : 'a option),o = None || (exists (x : 'a),o = Some (x))
axiom head_def: forall (a : 'a, l : 'a list),hd (a :: l) = a
axiom tail_def: forall (a : 'a, l : 'a list),tl (a :: l) = l
axiom get_upd_map_same:
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),a1 = a2 => m[a1 <- b][a2] = b
axiom get_upd_map_diff:
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),
    a1 <> a2 => m[a1 <- b][a2] = m[a2]
axiom upd_map_comm:
  forall (m : ('a,'b)map, a, a' : 'a, b, b' : 'b),
    a <> a' => m[a <- b][a' <- b'] = m[a' <- b'][a <- b]
axiom upd_in_dom_same:
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),a = a' => in_dom (a',m[a <- b])
axiom upd_in_dom_diff:
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),
    a <> a' => in_dom (a',m[a <- b]) <=> in_dom (a',m)
axiom upd_in_rng_same:
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),b = b' => in_rng (b',m[a <- b])
axiom upd_in_rng_diff:
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),
    b <> b' => in_rng (b',m[a <- b]) <=> in_rng (b',m)
axiom in_dom_in_rng:
  forall (m : ('a,'b)map, a : 'a),in_dom (a,m) => in_rng (m[a],m)
axiom in_rng_in_dom:
  forall (m : ('a,'b)map, b : 'b),
    in_rng (b,m) => exists (a : 'a),in_dom (a,m) && m[a] = b
axiom empty_in_dom: forall (a : 'a),!in_dom (a,empty_map)
axiom empty_in_rng: forall (b : 'b),!in_rng (b,empty_map)
axiom real_of_bool_true: real_of_bool (true) = 1%r
axiom real_of_bool_false: real_of_bool (false) = 0%r
axiom real_of_int_le_compat: forall (x, y : int),x <= y => x%r <= y%r
axiom real_of_int_lt_compat: forall (x, y : int),x < y => x%r < y%r
axiom rmult_le_compat_l:
  forall (x, y, z : real),0%r <= x => y <= z => x * y <= x * z
axiom rmult_le_compat_r:
  forall (x, y, z : real),0%r <= z => x <= y => x * z <= y * z
axiom rmul_plus_distr_r: forall (x, y, z : real),(x + y) * z = x * z + y * z
axiom rdiv_le_compat:
  forall (x1, x2, y1, y2 : real),
    0%r < y2 => y2 <= y1 => 0%r <= x1 => x1 <= x2 => x1 / y1 <= x2 / y2
axiom rdiv_0_le: forall (x, y : real),0%r < y => 0%r <= x => 0%r <= x / y
axiom pow2_pos: forall (n : int),0 <= n => 0 < 2 ^ n
axiom toto: forall (b : bool),is_true(b) => b
axiom in_list'_cons1: forall (a : 'a, l : 'a list'),in_list' (a,a :: l)
axiom alltrue_fst: forall (x, y : 'a, l : 'a list'),all_eq(x,y :: l) => x = y
axiom test: forall (x, y : int),x + y = y + x
is unset
test
Some_inj, Proj_Some, Proj_eq, Some_or_None, head_def, tail_def, get_upd_map_same, get_upd_map_diff, upd_map_comm, upd_in_dom_same, upd_in_dom_diff, upd_in_rng_same, upd_in_rng_diff, in_dom_in_rng, in_rng_in_dom, empty_in_dom, empty_in_rng, real_of_bool_true, real_of_bool_false, real_of_int_le_compat, real_of_int_lt_compat, rmult_le_compat_l, rmult_le_compat_r, rmul_plus_distr_r, rdiv_le_compat, rdiv_0_le, pow2_pos, toto, in_list'_cons1, alltrue_fst
pred my_eq (x, y : 'a) = x = y.

pred all_eq (x : 'c, l : 'c list') = forall (a : 'c),in_list' (a,l) => x = a.

pred all1 (l : int list') = all_eq(1,l).

pred alltrue (l : bool list') = all_eq(true,l).

pred is_true (b : bool) = b.

