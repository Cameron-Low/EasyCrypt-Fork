add type 'a list.
add type 'a option.
add type ('a,'b)map.
add op [=] : ('a, 'a) -> bool.
add op [&&] : (bool, bool) -> bool.
add op [||] : (bool, bool) -> bool.
add op [^^] : (bool, bool) -> bool.
add op [!] : bool -> bool.
add op [<] : (int, int) -> bool.
add op [<=] : (int, int) -> bool.
add op [-] : int -> int.
add op [+] : (int, int) -> int.
add op [-] : (int, int) -> int.
add op [*] : (int, int) -> int.
add op [/] : (int, int) -> int.
add op [%] : (int, int) -> int.
add op [^] : (int, int) -> int.
add op abs : int -> int.
add op [<] : (real, real) -> bool.
add op [<=] : (real, real) -> bool.
add op [-] : real -> real.
add op [+] : (real, real) -> real.
add op [-] : (real, real) -> real.
add op [*] : (real, real) -> real.
add op [/] : (real, real) -> real.
add op [^] : (real, real) -> real.
add op real_of_int : int -> real.
add op real_of_bool : bool -> real.
add op abs : real -> real.
add op exp : real -> real.
add op Some : 'a -> 'a option.
add cnst None : 'a option
add op [::] : ('a, 'a list) -> 'a list.
add cnst [] : 'a list
add op mem : ('a, 'a list) -> bool.
add op length : 'a list -> int.
add op [++] : ('a list, 'a list) -> 'a list.
add op upd : (('a,'b)map, 'a, 'b) -> ('a,'b)map.
add op get : (('a,'b)map, 'a) -> 'b.
add op in_dom : ('a, ('a,'b)map) -> bool.
add op in_rng : ('b, ('a,'b)map) -> bool.
 Read src/easycrypt_base.ec
add op [>] (x, y : int) = y < x.
add op [>=] (x, y : int) = y <= x.
add op [>] (x, y : real) = y < x.
add op [>=] (x, y : real) = y <= x.
add op fst (p : 'a * 'b) = (let a,b = p in a).
add op snd (p : 'a * 'b) = (let a,b = p in b).
add axiom Some_inj : forall (x, y : 'a),Some (x) = Some (y) => x = y
add op proj : 'a option -> 'a.
add axiom Proj_Some : forall (x : 'a),proj (Some (x)) = x
add axiom Proj_eq :
  forall (o1, o2 : 'a option),
    o1 <> None => o2 <> None => proj (o1) = proj (o2) => o1 = o2
add axiom Some_or_None :
  forall (o : 'a option),o = None || (exists (x : 'a),o = Some (x))
add op hd : 'a list -> 'a.
add op tl : 'a list -> 'a list.
add axiom head_def : forall (a : 'a, l : 'a list),hd (a :: l) = a
add axiom tail_def : forall (a : 'a, l : 'a list),tl (a :: l) = l
add cnst empty_map : ('a,'b)map
add axiom get_upd_map_same :
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),a1 = a2 => m[a1 <- b][a2] = b
add axiom get_upd_map_diff :
  forall (m : ('a,'b)map, a1, a2 : 'a, b : 'b),
    a1 <> a2 => m[a1 <- b][a2] = m[a2]
add axiom upd_map_comm :
  forall (m : ('a,'b)map, a, a' : 'a, b, b' : 'b),
    a <> a' => m[a <- b][a' <- b'] = m[a' <- b'][a <- b]
add axiom upd_in_dom_same :
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),a = a' => in_dom (a',m[a <- b])
add axiom upd_in_dom_diff :
  forall (m : ('a,'b)map, a, a' : 'a, b : 'b),
    a <> a' => in_dom (a',m[a <- b]) <=> in_dom (a',m)
add axiom upd_in_rng_same :
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),b = b' => in_rng (b',m[a <- b])
add axiom upd_in_rng_diff :
  forall (m : ('a,'b)map, a : 'a, b, b' : 'b),
    b <> b' => in_rng (b',m[a <- b]) <=> in_rng (b',m)
add axiom in_dom_in_rng :
  forall (m : ('a,'b)map, a : 'a),in_dom (a,m) => in_rng (m[a],m)
add axiom in_rng_in_dom :
  forall (m : ('a,'b)map, b : 'b),
    in_rng (b,m) => exists (a : 'a),in_dom (a,m) && m[a] = b
add axiom empty_in_dom : forall (a : 'a),!in_dom (a,empty_map)
add axiom empty_in_rng : forall (b : 'b),!in_rng (b,empty_map)
add axiom real_of_bool_true : real_of_bool (true) = 1%r
add axiom real_of_bool_false : real_of_bool (false) = 0%r
add axiom real_of_int_le_compat : forall (x, y : int),x <= y => x%r <= y%r
add axiom real_of_int_lt_compat : forall (x, y : int),x < y => x%r < y%r
add axiom rmult_le_compat_l :
  forall (x, y, z : real),0%r <= x => y <= z => x * y <= x * z
add axiom rmult_le_compat_r :
  forall (x, y, z : real),0%r <= z => x <= y => x * z <= y * z
add axiom rmul_plus_distr_r :
  forall (x, y, z : real),(x + y) * z = x * z + y * z
add axiom rdiv_le_compat :
  forall (x1, x2, y1, y2 : real),
    0%r < y2 => y2 <= y1 => 0%r <= x1 => x1 <= x2 => x1 / y1 <= x2 / y2
add axiom rdiv_0_le :
  forall (x, y : real),0%r < y => 0%r <= x => 0%r <= x / y
add axiom pow2_pos : forall (n : int),0 <= n => 0 < 2 ^ n
 Read tests/rnd.ec
current prover is alt-ergo
[global] end game G0 :
Proving equiv minimal : G0.F ~ G0.F : true ==> res{1} < res{2}
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..0];
stmt2 =   1 : z = [0..0];
post  = z{1} < z{2}

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..0];
stmt2 =   1 : z = [0..0];
post  = z{1} < z{2}

 
 None of the provers is able to prove goal 'implies_goal1'
 
 
 
 None of the provers is able to prove goal 'implies_goal4'
 
 
Current goal
Pending subgoals: 1
pre   = true
stmt1 = 
stmt2 = 
post  = (forall (x : int),0 <= x => x <= 0 => x + 1 <= 0) &&
         (forall (y : int),0 <= y => y <= 0 => 0 <= y - 1)

Abort minimal

[global] end game G1 :
[global] end game G2 :
Proving equiv forward : G1.F ~ G2.F : true ==> ={res}
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..0];
stmt2 =   1 : z = [0..0];
          2 : b = false;
          3 : if (z = 1) b = true;
post  = b{2}

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..0];
stmt2 =   1 : z = [0..0];
          2 : b = false;
          3 : if (z = 1) b = true;
post  = b{2}

 
 None of the provers is able to prove goal 'implies_goal0'
Current goal
Pending subgoals: 1
pre   = (((forall (x : int),
             0 <= x => x <= 0 =>
                (0 <= 1 - x && 1 - x <= 0) && 1 - (1 - x) = x) =>
          (forall (y : int),
             0 <= y => y <= 0 =>
                (0 <= 1 - y && 1 - y <= 0) && 1 - (1 - y) = y) =>
          z{2} = 1 - z{1}) && 0 <= z{1} && z{1} <= 0) &&
         0 <= z{2} && z{2} <= 0
stmt1 = 
stmt2 = 
post  = z{2} <> 1 => false

Abort forward

Proving equiv backward : G1.F ~ G2.F : true ==> ={res}
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..0];
stmt2 =   1 : z = [0..0];
          2 : b = false;
          3 : if (z = 1) b = true;
post  = b{2}

 
 None of the provers is able to prove goal 'implies_goal1'
 
 
 
 None of the provers is able to prove goal 'implies_goal5'
 
Current goal
Pending subgoals: 1
pre   = true
stmt1 = 
stmt2 = 
post  = (forall (x : int),0 <= x => x <= 0 => 1 - x <= 0) &&
         (forall (y : int),0 <= y => y <= 0 => 1 - y <= 0)

Abort backward

[global] end game G3 :
[global] end game G4 :
Proving equiv different : G3.F ~ G4.F : true ==> z{2} = z{1} + 1
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = z{2} = z{1} + 1

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = z{2} = z{1} + 1

Current goal
Pending subgoals: 1
pre   = true
stmt1 = 
stmt2 = 
post  = (forall (x : int),
           0 <= x => x <= 1 => (1 <= x + 1 && x + 1 <= 2) && x + 1 - 1 = x) &&
         (forall (y : int),
            1 <= y => y <= 2 => (0 <= y - 1 && y - 1 <= 1) && y - 1 + 1 = y)

 
QED
Abort different

Proving equiv range_fwd : G3.F ~ G4.F : true ==> 1 <= z{1} && z{1} <= 2
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = 1 <= z{1} && z{1} <= 2

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = 1 <= z{1} && z{1} <= 2

 
 None of the provers is able to prove goal 'implies_goal0'
 
Current goal
Pending subgoals: 1
pre   = ((0 = 1 => 1 = 2 => z{2} = z{1}) && 0 <= z{1} && z{1} <= 1) &&
         1 <= z{2} && z{2} <= 2
stmt1 = 
stmt2 = 
post  = 1 <= z{1}

Abort range_fwd

Proving equiv range_bwd : G3.F ~ G4.F : true ==> 1 <= z{1} && z{1} <= 2
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = 1 <= z{1} && z{1} <= 2

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = 1 <= z{1} && z{1} <= 2

 
 None of the provers is able to prove goal 'implies_goal0'
 
 None of the provers is able to prove goal 'implies_goal1'
 
 None of the provers is able to prove goal 'implies_goal2'
 
Current goal
Pending subgoals: 1
pre   = true
stmt1 = 
stmt2 = 
post  = (0 = 1 && 1 = 2) && (forall (x : int),0 <= x => x <= 1 => 1 <= x)

Abort range_bwd

Proving equiv equality : G3.F ~ G4.F : true ==> ={res}
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = ={z}

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [0..1];
stmt2 =   1 : z = [1..2];
post  = ={z}

 
 None of the provers is able to prove goal 'implies_goal0'
Current goal
Pending subgoals: 1
pre   = ((0 = 1 => 1 = 2 => z{2} = z{1}) && 0 <= z{1} && z{1} <= 1) &&
         1 <= z{2} && z{2} <= 2
stmt1 = 
stmt2 = 
post  = ={z}

Abort equality

add cnst a : int
add cnst b : int
add cnst c : int
add cnst d : int
add op Q_ : (int, int) -> bool.
add pred Q (a, b : int) = Q_ (a,b).

add op f : int -> int.
add op finv : int -> int.
add axiom f_finv :
  forall (x : int),
    a <= x => x <= b => c <= f (x) && f (x) <= d && finv (f (x)) = x
add axiom finv_f :
  forall (y : int),
    c <= y => y <= d => a <= finv (y) && finv (y) <= b && f (finv (y)) = y
[global] end game G5 :
[global] end game G6 :
add axiom Q_valid : forall (x : int),a <= x => x <= b => Q(x,f (x))
Proving equiv test_wp : G5.F ~ G6.F : true ==> Q(z{1},z{2})
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = Q(z{1},z{2})

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = Q(z{1},z{2})

Current goal
Pending subgoals: 1
pre   = true
stmt1 = 
stmt2 = 
post  = (forall (x : int),
           a <= x => x <= b =>
              ((c <= f (x) && f (x) <= d) && finv (f (x)) = x) &&
               (c <= f (x) => f (x) <= d => finv (f (x)) = x => Q(x,f (x)))) &&
         (forall (y : int),
            c <= y => y <= d =>
               (a <= finv (y) && finv (y) <= b) && f (finv (y)) = y)

 
QED
Abort test_wp

Proving equiv test_sp : G5.F ~ G6.F : true ==> Q(z{1},z{2})
Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = Q(z{1},z{2})

Current goal
Pending subgoals: 1
pre   = true
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = Q(z{1},z{2})

Current goal
Pending subgoals: 1
pre   = (((forall (x : int),
             a <= x => x <= b =>
                (c <= f (x) && f (x) <= d) && finv (f (x)) = x) =>
          (forall (y : int),
             c <= y => y <= d =>
                (a <= finv (y) && finv (y) <= b) && f (finv (y)) = y) =>
          z{2} = f (z{1})) && a <= z{1} && z{1} <= b) &&
         c <= z{2} && z{2} <= d
stmt1 = 
stmt2 = 
post  = Q(z{1},z{2})

 
QED
Abort test_sp

Proving equiv test_sp : G5.F ~ G6.F :
          Q(z{1},z{2}) ==>
          z{2} = f (z{1}) &&
           a <= z{1} &&
            z{1} <= b &&
             c <= z{2} && z{2} <= d && (exists (u, v : int),Q(u,v))
Current goal
Pending subgoals: 1
pre   = Q(z{1},z{2})
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = z{2} = f (z{1}) &&
         a <= z{1} &&
          z{1} <= b && c <= z{2} && z{2} <= d && (exists (u, v : int),Q(u,v))

Current goal
Pending subgoals: 1
pre   = Q(z{1},z{2})
stmt1 =   1 : z = [a..b];
stmt2 =   1 : z = [c..d];
post  = z{2} = f (z{1}) &&
         a <= z{1} &&
          z{1} <= b && c <= z{2} && z{2} <= d && (exists (u, v : int),Q(u,v))

Current goal
Pending subgoals: 1
pre   = exists (z, z_0 : int),
          ((((forall (x : int),
                a <= x => x <= b =>
                   (c <= f (x) && f (x) <= d) && finv (f (x)) = x) =>
             (forall (y : int),
                c <= y => y <= d =>
                   (a <= finv (y) && finv (y) <= b) && f (finv (y)) = y) =>
             z{2} = f (z{1})) && a <= z{1} && z{1} <= b) &&
            c <= z{2} && z{2} <= d) &&
           Q(z,z_0)
stmt1 = 
stmt2 = 
post  = z{2} = f (z{1}) &&
         a <= z{1} &&
          z{1} <= b && c <= z{2} && z{2} <= d && (exists (u, v : int),Q(u,v))

 
QED
Abort test_sp

