(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Reals Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Dp_hint bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Dp_hint bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Dp_hint bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Dp_hint bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Dp_hint ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Dp_hint ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Dp_hint lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Dp_hint le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Dp_hint gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Dp_hint ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Dp_hint eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Dp_hint neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Dp_hint abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Dp_hint abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Dp_hint int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Dp_hint int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Dp_hint int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Dp_hint int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Dp_hint math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Dp_hint math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Dp_hint computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Dp_hint computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Dp_hint computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Dp_hint computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Dp_hint computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Dp_hint computer_rounds_toward_zero.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Dp_hint truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Dp_hint truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Dp_hint lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Dp_hint le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Dp_hint gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Dp_hint ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Dp_hint eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Dp_hint neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Dp_hint real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Dp_hint real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Dp_hint real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Dp_hint real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Dp_hint sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Dp_hint sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Dp_hint sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Dp_hint abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Dp_hint abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Dp_hint log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Dp_hint exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Dp_hint prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Dp_hint abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Dp_hint poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Dp_hint poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Dp_hint not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Dp_hint bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Dp_hint not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Dp_hint surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Dp_hint fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Dp_hint snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Dp_hint pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Dp_hint None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Dp_hint Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Dp_hint Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Dp_hint Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Dp_hint Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Dp_hint Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Dp_hint Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Dp_hint in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Dp_hint in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Dp_hint in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Dp_hint length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Dp_hint length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Dp_hint length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Dp_hint head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Dp_hint tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Dp_hint Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Dp_hint Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Dp_hint get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Dp_hint get_upd_map_diff.

(*Why axiom*) Lemma get_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (a = a' /\ b = b' \/ ~(a = a') /\ (get_map m a') = b' ->
        (get_map (upd_map m a b) a') = b')))))).
Admitted.
Dp_hint get_upd_map.

(*Why axiom*) Lemma get_upd_map_2 :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (((a = a' -> b = b')) ->
        (((~(a = a') -> (get_map m a') = b')) ->
         (get_map (upd_map m a b) a') = b'))))))).
Admitted.
Dp_hint get_upd_map_2.

(*Why axiom*) Lemma get_upd_map_elim :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       ((get_map (upd_map m a b) a') = b' -> a = a' /\ b = b' \/ ~(a = a') /\
        (get_map m a') = b')))))).
Admitted.
Dp_hint get_upd_map_elim.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Dp_hint upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Dp_hint upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Dp_hint upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map1 :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (a = a' \/ (in_dom_map a' m) = true ->
       (in_dom_map a' (upd_map m a b)) = true))))).
Admitted.
Dp_hint in_dom_upd_map1.

(*Why axiom*) Lemma in_dom_upd_map2 :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true -> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Dp_hint in_dom_upd_map2.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Dp_hint in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Dp_hint upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Dp_hint in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Dp_hint in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Dp_hint in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Dp_hint inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A2 A1)) = false).
Admitted.
Dp_hint empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A1 A2)) = false).
Admitted.
Dp_hint empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Dp_hint triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Dp_hint div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Dp_hint real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Dp_hint real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Dp_hint rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Dp_hint rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Dp_hint rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Dp_hint rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Dp_hint rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Dp_hint rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Dp_hint rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Dp_hint real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Dp_hint real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Dp_hint real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Dp_hint real_of_int_12.


(***********************)
(*     DEFINITIONS     *)
(***********************)

(* The following correspond to our own axioms and definitions of some operators and predicates in the EasyCrypt file. *)

(*Why logic*) Definition pad : (list bool) -> (list bitstring).
Admitted.

(*Why logic*) Definition unpad : (list bitstring) -> (option (list bool)).
Admitted.

(*Why logic*) Definition prefix :
  (list bitstring) -> (list bitstring) -> bool.
Admitted.

(*Why logic*) Definition mapfst :
  (list (prod bitstring bitstring)) -> (list bitstring).
Admitted.

(*Why logic*) Definition ischained :
  (map (prod bitstring bitstring) bitstring) -> bitstring
  -> (list (prod bitstring bitstring)) -> bitstring -> bool.
Admitted.

(*Why logic*) Definition find_seq :
  bitstring -> bitstring
  -> (map (prod bitstring bitstring) bitstring) -> (option (list (prod bitstring bitstring))).
Admitted.

(*Why logic*) Definition set_bad4 :
  bitstring -> (map (prod bitstring bitstring) bitstring)
  -> (map (prod bitstring bitstring) bitstring)
  -> (map bitstring (prod bitstring bitstring)) -> bool.
Admitted.

(*Why logic*) Definition k : Z.
Admitted.

(*Why logic*) Definition n : Z.
Admitted.

(*Why logic*) Definition IV : bitstring.
Admitted.

(*Why predicate*) Definition Injective  (T_2:(map (prod bitstring bitstring) bitstring))
  := (forall (xy_6:(prod bitstring bitstring)),
      (forall (xy'_5:(prod bitstring bitstring)),
       ((in_dom_map xy_6 T_2) = true ->
        ((in_dom_map xy'_5 T_2) = true ->
         ((get_map T_2 xy_6) = (get_map T_2 xy'_5) -> xy_6 = xy'_5))))).

(*Why predicate*) Definition Inclusion  (T'_13:(map (prod bitstring bitstring) bitstring)) (T_14:(map (prod bitstring bitstring) bitstring))
  := (forall (xy_18:(prod bitstring bitstring)),
      ((in_dom_map xy_18 T'_13) = true -> (in_dom_map xy_18 T_14) = true)) /\
     (forall (xy_16:(prod bitstring bitstring)),
      ((in_dom_map xy_16 T'_13) = true ->
       (get_map T'_13 xy_16) = (get_map T_14 xy_16))).

(*Why predicate*) Definition Inverse  (T_614:(map (prod bitstring bitstring) bitstring)) (invT_615:(map bitstring (prod bitstring bitstring)))
  := (forall (xy_619:(prod bitstring bitstring)),
      ((in_dom_map xy_619 T_614) = true ->
       (in_dom_map (get_map T_614 xy_619) invT_615) = true /\
       (get_map invT_615 (get_map T_614 xy_619)) = xy_619)) /\
     (forall (z_617:bitstring),
      ((in_dom_map z_617 invT_615) = true ->
       (in_dom_map (get_map invT_615 z_617) T_614) = true /\
       (get_map T_614 (get_map invT_615 z_617)) = z_617)).

(*Why predicate*) Definition valid_chain  (c_220:(list (prod bitstring bitstring))) (T_221:(map (prod bitstring bitstring) bitstring))
  := (exists z_223:bitstring, (ischained T_221 IV c_220 z_223) = true /\
      ~(unpad (mapfst c_220)) = (@None (list bool))).

(*Why predicate*) Definition Claim5  (T'_708:(map (prod bitstring bitstring) bitstring)) (T_709:(map (prod bitstring bitstring) bitstring))
  := (forall (x'_717:bitstring),
      (forall (y'_716:bitstring),
       (forall (x_715:bitstring),
        (forall (y_714:bitstring),
         ((in_dom_map (pair x'_717 y'_716) T_709) = true ->
          ((get_map T_709 (pair x'_717 y'_716)) = y_714 ->
           ((in_dom_map (pair x_715 y_714) T'_708) = true ->
            ((find_seq x'_717 y'_716 T_709) =
             (@None (list (prod bitstring bitstring))) ->
             (in_dom_map (pair x'_717 y'_716) T'_708) = true)))))))).


(* The following are axioms which express properties that we expect our operators to have. They can be considered as definitions. *)

(*Why axiom*) Lemma unpad_ex_pad :
  (forall (p_29:(list bitstring)),
   (~(unpad p_29) = (@None (list bool)) ->
    (exists m_28:(list bool), p_29 = (pad m_28)))).
Admitted.
Dp_hint unpad_ex_pad.

(*Why axiom*) Lemma prefixfree :
  (forall (m1_43:(list bool)),
   (forall (m2_42:(list bool)),
    (forall (bl_41:(list bitstring)),
     (~m1_43 = m2_42 -> ~(pad m1_43) = (Append (pad m2_42) bl_41))))).
Admitted.
Dp_hint prefixfree.

(*Why axiom*) Lemma unpad_inj :
  (forall (x_33:(list bitstring)),
   (forall (y_32:(list bitstring)),
    ((unpad x_33) = (unpad y_32) ->
     (~(unpad x_33) = (@None (list bool)) -> x_33 = y_32)))).
Admitted.
Dp_hint unpad_inj.

(*Why axiom*) Lemma mapfst_nil :
  (mapfst (@Nil (prod bitstring bitstring))) = (@Nil bitstring).
Admitted.
Dp_hint mapfst_nil.

(*Why axiom*) Lemma mapfst_cons :
  (forall (x_60:bitstring),
   (forall (y_59:bitstring),
    (forall (c_58:(list (prod bitstring bitstring))),
     (mapfst (Cons (pair x_60 y_59) c_58)) = (Cons x_60 (mapfst c_58))))).
Admitted.
Dp_hint mapfst_cons.

(*Why axiom*) Lemma ischained_nil :
  (forall (T_66:(map (prod bitstring bitstring) bitstring)),
   (forall (y_65:bitstring),
    (forall (z_64:bitstring),
     ((ischained T_66 y_65 (@Nil (prod bitstring bitstring)) z_64) = true <->
      y_65 = z_64)))).
Admitted.
Dp_hint ischained_nil.

(*Why axiom*) Lemma ischained_cons :
  (forall (T_74:(map (prod bitstring bitstring) bitstring)),
   (forall (y_73:bitstring),
    (forall (xy_72:(prod bitstring bitstring)),
     (forall (z_71:bitstring),
      ((ischained
        T_74 y_73 (Cons xy_72 (@Nil (prod bitstring bitstring))) z_71) =
       true <-> ((in_dom_map xy_72 T_74) = true /\
       y_73 = (snd_prod xy_72)) /\ (get_map T_74 xy_72) = z_71))))).
Admitted.
Dp_hint ischained_cons.

(*Why axiom*) Lemma ischained_conscons :
  (forall (T_86:(map (prod bitstring bitstring) bitstring)),
   (forall (xy_85:(prod bitstring bitstring)),
    (forall (y_84:bitstring),
     (forall (xy'_83:(prod bitstring bitstring)),
      (forall (c_82:(list (prod bitstring bitstring))),
       (forall (z_81:bitstring),
        ((ischained T_86 y_84 (Cons xy_85 (Cons xy'_83 c_82)) z_81) = true <->
         (((in_dom_map xy_85 T_86) = true /\ y_84 = (snd_prod xy_85)) /\
         (get_map T_86 xy_85) = (snd_prod xy'_83)) /\
         (ischained T_86 (snd_prod xy'_83) (Cons xy'_83 c_82) z_81) = true))))))).
Admitted.
Dp_hint ischained_conscons.

(*Why axiom*) Lemma find_seq_ischained :
  (forall (T_190:(map (prod bitstring bitstring) bitstring)),
   (forall (x_189:bitstring),
    (forall (y_188:bitstring),
     (~(find_seq x_189 y_188 T_190) =
       (@None (list (prod bitstring bitstring))) ->
      (ischained T_190 IV (proj (find_seq x_189 y_188 T_190)) y_188) = true)))).
Admitted.
Dp_hint find_seq_ischained.

(*Why axiom*) Lemma find_seq_unpad :
  (forall (T_200:(map (prod bitstring bitstring) bitstring)),
   (forall (x_199:bitstring),
    (forall (y_198:bitstring),
     (~(find_seq x_199 y_198 T_200) =
       (@None (list (prod bitstring bitstring))) ->
      ~(unpad
        (mapfst
         (Append
          (proj (find_seq x_199 y_198 T_200)) (Cons
                                               (pair x_199 y_198) (@Nil (prod bitstring bitstring)))))) =
       (@None (list bool)))))).
Admitted.
Dp_hint find_seq_unpad.

(*Why axiom*) Lemma find_seq_complete :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (x:bitstring),
    (forall (y:bitstring),
     (forall (c:(list (prod bitstring bitstring))),
      ((Injective T) ->
       (~(in_rng_map IV T) = true ->
        ((ischained T IV c y) = true ->
         (~(unpad
            (mapfst
             (Append
              c (Cons
                     (pair x y) (@Nil (prod bitstring bitstring)))))) =
           (@None (list bool)) ->
          ~(find_seq x y T) =
           (@None (list (prod bitstring bitstring))))))))))).
Admitted.
Dp_hint find_seq_complete.

(*Why axiom*) Lemma set_bad4_def :
  (forall (z_613:bitstring),
   (forall (T'_612:(map (prod bitstring bitstring) bitstring)),
    (forall (T_611:(map (prod bitstring bitstring) bitstring)),
     (forall (invT_610:(map bitstring (prod bitstring bitstring))),
      ((set_bad4 z_613 T'_612 T_611 invT_610) = true <->
       ((in_dom_map z_613 invT_610) = true /\
       ~(in_dom_map (get_map invT_610 z_613) T'_612) = true) /\
       ~(exists c_609:(list (prod bitstring bitstring)),
         (valid_chain
          (Append
           c_609 (Cons
                  (get_map invT_610 z_613) (@Nil (prod bitstring bitstring)))) T_611))))))).
Admitted.
Dp_hint set_bad4_def.


(********************)
(*     PREAMBLE     *)
(********************)

(*
In the following, we will show the properties formalized as axioms in EasyCrypt.
Before we proceed, we need some more assumptions. We will require classical logic
and assume that we can perform case distinctions on certain types.
*)

Require Import Classical.

Lemma not_imply_to_or : forall P Q:Prop, (~P -> Q) -> P \/ Q.
Proof.
intros. case (classic P); auto.
Qed.

Parameter eq_bstr_dec : forall (x x' : bitstring), {x = x'} + {x <> x'}.
Parameter eq_prod_dec : forall (xy xy' : prod bitstring bitstring), {xy = xy'} + {xy <> xy'}.
Parameter none_or_notnone: forall (A:Set) (o:option A), {o <> None} + {o = None}.

Lemma eq_bool: forall (b:bool), {b = true} + {b = false}.
Proof.
intros.
apply (bool_rec (fun b => {b = true} + {b = false})).
left. reflexivity.
right. reflexivity.
Qed.

(* Also, induction principles for Why's lists are good to have. *)
Axiom list_rec : forall (A : Set) (P : list A -> Set),
                   P Nil ->
                   (forall (x : A) (tl : list A), P tl -> P (Cons x tl)) ->
                   forall l : list A, P l.


Lemma list_ind : forall (A : Set) (P : list A -> Prop),
                   P Nil ->
                   (forall (x : A) (tl : list A), P tl -> P (Cons x tl)) ->
                   forall l : list A, P l.
Proof with assumption.
intros; apply list_rec...
Defined.

(* We need to know that any list has either the form x::tl or Nil. *)
Lemma destruct_list : forall (A:Set) (l:list A), {x:A & {tl:list A | l = (Cons x tl)}}+{l = Nil}.
Proof with reflexivity.
intros.
apply list_rec with (l := l).
 (* base case, l = [] *)
 right...
 (* induction step, l = a::al *)
 intros a al IH; clear IH. (* don't need IH *)
 left. exists a, al...
Qed.


(* Now, a few useful tactics. *)

(* A primitive tactic which uses destruct_list to destruct a list, obtains the variables x and tl in the Cons case,
   and peforms all the necessary substitutions *)
Ltac destruct_list l_ x_ tl_ := case destruct_list with (l := l_);
 match goal with
 | [ |- {x : ?A & {tl : list ?A | l_ = Cons x tl}} -> ?P ] => intro s; destruct s as (x_,(tl_,e)); repeat rewrite e in *; clear e
 | [ |- l_ = Nil -> ?P ] => intro e; repeat rewrite e in *; clear e
 end.

Tactic Notation "destruct_list" ident(l) "as" ident(x) ident(tl) := destruct_list l x tl.

(* clear duplicate hypotheses *)
Ltac clear_dup :=
  match goal with
    | [ H : ?X |- _ ] =>
      match goal with
        | [ H' : ?Y |- _ ] =>
          match H with
            | H' => fail 2
            | _ => unify X Y ; (clear H' || clear H)
          end
      end
  end.

Ltac clear_dups := repeat clear_dup.

(* duplicate a hypothesis *)
Ltac duplicate H Hdup := generalize H as Hdup; intro.
Tactic Notation "duplicate" ident(H) "as" ident(Hdup) := duplicate H Hdup.


(******************)
(*     PROOFS     *)
(******************)

(*
Finally, we are ready to perform all proofs.
From here on, all lemmas are either proved in Coq, or automatically derived by the SMT solvers from previous lemmas (or both).
In case they are derived by the SMT solvers, they are annotated as such.
From those lemmas that are solved by the SMT solvers, only those appear here which we need in some later Coq proof.
*)

(* list lemmas *)
(***************)

Lemma tail_length : 
  (forall (l_133:(list bitstring)),
   (~l_133 = (@Nil bitstring) -> (length_list (tail l_133)) =
    ((length_list l_133) - 1))).
Proof.
intros l.
destruct_list l as a al.
 (* l = a::al *)
 intros _. rewrite tail_def. rewrite length_cons. omega.
 (* l = [] *)
 intros Hnnil. apply False_ind. auto.
Qed.

Lemma length0 : 
  (forall (l_135:(list bitstring)),
   ((length_list l_135) = 0 -> l_135 = (@Nil bitstring))).
Proof.
intros l Hlen.
destruct_list l as a al.
 (* l = a::al *)
 apply False_ind. remember (length_pos _ al) as Hpos; clear HeqHpos. rewrite length_cons in Hlen.
 omega.
 (* l = [] *)
 clear. reflexivity.
Qed.

Lemma head_tail : 
  (forall (ms_137:(list bitstring)),
   (~ms_137 = (@Nil bitstring) -> ms_137 = (Cons (head ms_137) (tail ms_137)))).
Proof.
intros ms Hnnil.
destruct_list ms as a al.
 (* l = a::al *)
 clear. rewrite head_def, tail_def. reflexivity.
 (* l = [] *)
 apply False_ind. auto.
Qed.

Lemma head_length_one : 
  (forall (ms_141:(list bitstring)),
   (~ms_141 = (@Nil bitstring) ->
    (~1 < (length_list ms_141) ->
     ms_141 = (Cons (head ms_141) (@Nil bitstring))))).
Proof.
intros ms Hnnil Hlen.
destruct_list ms as a al.
 (* l = a::al *)
 rewrite head_def. rewrite length_cons in Hlen.
 destruct_list al as a' al'.
  (* al = a'::al' *)
  clear - Hlen. apply False_ind. rewrite length_cons in Hlen.
  remember (length_pos _ al') as Hpos; clear HeqHpos. omega.
  (* al = [] *)
  clear. reflexivity.
 (* l = [] *)
 clear - Hnnil. apply False_ind. auto.
Qed.

Lemma append_same_nil : 
  (forall (m1_17:(list bitstring)),
   (forall (m2_16:(list bitstring)),
    ((Append m1_17 m2_16) = m1_17 -> m2_16 = (@Nil bitstring)))).
Proof.
intros m1 m2.
apply list_ind with (l := m1).
 (* base case *)
 intros H. rewrite Append_nil in H. assumption.
 (* induction step *)
 intros a al. intro IH. intros H.
 rewrite Append_Cons in H.
 apply Cons_inj in H. exact (IH (proj2 H)).
Qed.

Lemma app_nil_end : 
  (forall (ms_151:(list bitstring)),
   (Append ms_151 (@Nil bitstring)) = ms_151).
Proof.
intros l.
apply list_ind with (l := l).
 (* base case *)
 rewrite Append_nil. reflexivity.
 (* induction step *)
 intros a al. intro IH.
 rewrite Append_Cons. rewrite IH. reflexivity.
Qed.

Lemma app_inj_tail :
  (forall (l1_26:(list bitstring)),
   (forall (l2_25:(list bitstring)),
    (forall (x1_24:bitstring),
     (forall (x2_23:bitstring),
      ((Append l1_26 (Cons x1_24 (@Nil bitstring))) =
       (Append l2_25 (Cons x2_23 (@Nil bitstring))) -> l1_26 = l2_25 /\
       x1_24 = x2_23))))).
Proof.
intros l1 l2 x1 x2.
generalize l2; clear l2.
apply list_ind with (l := l1).
 (* l1 = [] *)
 rewrite Append_nil. intros.
 destruct_list l2 as b bl.
  (* l2 = b::bl *)
  apply False_ind. rewrite Append_Cons in H.
  apply Cons_inj in H. destruct H as (_,H).
  destruct_list bl as b' bl'.
   (* bl = b'::bl' *)
   rewrite Append_Cons in H. apply Nil_neq_Cons in H.
   trivial.
   (* bl = [] *)
   rewrite Append_nil in H. apply Nil_neq_Cons in H.
   trivial.
  (* l2 = [] *)
  rewrite Append_nil in H. apply Cons_inj in H.
  tauto.
 (* l1 = a::al *)
 intros a al IH l2 H.
 destruct_list l2 as b bl.
  (* l2 = b::bl *)
  repeat rewrite Append_Cons in H. apply Cons_inj in H.
  destruct H as (e,e').
  specialize (IH bl e'); clear e'. destruct IH as (e',e'').
  subst. repeat split; trivial.
  (* l2 = [] *)
  clear - H. apply False_ind. rewrite Append_Cons in H. rewrite Append_nil in H.
  apply Cons_inj in H. destruct H as (_,H).
  destruct_list al as a' al'.
   (* al = a'::al' *)
   rewrite Append_Cons in H. symmetry in H. apply Nil_neq_Cons in H.
   trivial.
   (* bl = [] *)
   rewrite Append_nil in H. symmetry in H. apply Nil_neq_Cons in H.
   trivial.
Qed.

Lemma append_assoc :
  (forall (s1_41:(list (prod bitstring bitstring))),
   (forall (s2_40:(list (prod bitstring bitstring))),
    (forall (s3_39:(list (prod bitstring bitstring))),
     (Append (Append s1_41 s2_40) s3_39) =
     (Append s1_41 (Append s2_40 s3_39))))).
Proof.
intros s1 s2 s3.
apply list_ind with (l := s1).
 (* base case *)
 repeat rewrite Append_nil. reflexivity.
 (* induction step *)
 intros a al. intro IH.
 repeat rewrite Append_Cons. rewrite IH.
 reflexivity.
Qed.

Lemma append_assoc_padding :
  (forall (s1_169:(list bitstring)),
   (forall (s2_168:(list bitstring)),
    (forall (s3_167:(list bitstring)),
     (Append (Append s1_169 s2_168) s3_167) =
     (Append s1_169 (Append s2_168 s3_167))))).
Proof.
intros s1 s2 s3.
apply list_ind with (l := s1).
 (* base case *)
 repeat rewrite Append_nil. reflexivity.
 (* induction step *)
 intros a al. intro IH.
 repeat rewrite Append_Cons. rewrite IH.
 reflexivity.
Qed.

Lemma exists_last : 
  (forall (c:(list (prod bitstring bitstring))),
   c = (@Nil (prod bitstring bitstring)) \/
   (exists c':(list (prod bitstring bitstring)),
    (exists xy':(prod bitstring bitstring),
     c = (Append c' (Cons xy' (@Nil (prod bitstring bitstring))))))).
Proof with reflexivity.
intros c.
apply list_ind with (l := c).
 (* base case, l = [] *)
 left...
 (* induction step, l = a::al *)
 intros a al IH.
 destruct IH as [e|(al',(b,e))]; subst.
  (* case al = [] *)
  right. exists Nil, a.
  rewrite Append_nil...
  (* case  al = al'@b::[] *)
  right. exists (Cons a al'), b.
  rewrite Append_Cons...
Qed.

Lemma cons_append_swap :
  (forall (a_67:(prod bitstring bitstring)),
   (forall (al_66:(list (prod bitstring bitstring))),
    (exists x_65:(prod bitstring bitstring),
     (exists xl_64:(list (prod bitstring bitstring)),
      (Cons a_67 al_66) =
      (Append xl_64 (Cons x_65 (@Nil (prod bitstring bitstring)))))))).
Proof.
intros a al. generalize a; clear a.
apply list_ind with (l := al).
 (* case al = [] *)
 intros. exists (a). exists Nil. rewrite Append_nil. reflexivity.
 (* case al = a'::al' *)
 intros a' al' IH a.
 specialize (IH a'). destruct IH as (x). destruct H as (xl).
 exists x. exists (Cons a xl).
 rewrite H. rewrite Append_Cons. reflexivity.
Qed.

Lemma last_in :
  (forall (l_73:(list (prod bitstring bitstring))),
   (forall (xy_72:(prod bitstring bitstring)),
    (in_list
     xy_72 (Append l_73 (Cons xy_72 (@Nil (prod bitstring bitstring))))) =
    true)).
Proof.
intros l xy.
apply list_ind with (l := l).
 (* case l = [] *)
 rewrite Append_nil. rewrite in_list_Cons.
 rewrite bool_or_def. rewrite poly_eq_eq.
 left. reflexivity.
 (* case l = a::al *)
 intros a al IH.
 rewrite Append_Cons. rewrite in_list_Cons.
 rewrite bool_or_def.
 right. assumption.
Qed.

Lemma in_split : 
  (forall (l_103:(list (prod bitstring bitstring))),
   (forall (xy_102:(prod bitstring bitstring)),
    ((in_list xy_102 l_103) = true ->
     (exists l1_101:(list (prod bitstring bitstring)),
      (exists l2_100:(list (prod bitstring bitstring)),
       l_103 = (Append l1_101 (Cons xy_102 l2_100))))))).
Proof.
intros l xy.
apply list_ind with (l := l).
 (* base case *)
 intros Hin. rewrite in_list_Nil in Hin. discriminate Hin.
 (* induction step *)
 intros a al. intro IH. intros Hin.
 rewrite in_list_Cons in Hin. rewrite bool_or_def in Hin. rewrite poly_eq_eq in Hin.
 destruct Hin.
  (* case xy = a *)
  subst. exists Nil, al. rewrite Append_nil. reflexivity.
  (* case xy in al *)
  apply IH in H; clear IH. destruct H as (l1,(l2)).
  subst. exists (Cons a l1), l2. rewrite Append_Cons.
  reflexivity.
Qed.


(* map lemmas *)
(**************)

Lemma in_dom_upd_map_I :
  (forall (i_133:Z),
   (forall (i'_132:Z),
    (forall (sb_131:(prod bitstring bool)),
     (forall (I_130:(map Z (prod bitstring bool))),
      ((in_dom_map i'_132 (upd_map I_130 i_133 sb_131)) = true <-> i_133 =
       i'_132 \/ ~i_133 = i'_132 /\ (in_dom_map i'_132 I_130) = true))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma inclusion_injective :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (T':(map (prod bitstring bitstring) bitstring)),
    ((Inclusion T' T) -> ((Injective T) -> (Injective T'))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma inclusion_upd :
  (forall (T_481:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_480:(map (prod bitstring bitstring) bitstring)),
    (forall (xy_479:(prod bitstring bitstring)),
     ((Inclusion T'_480 T_481) ->
      ((in_dom_map xy_479 T_481) = true ->
       (Inclusion T'_480 (upd_map T'_480 xy_479 (get_map T_481 xy_479)))))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma inclusion_upd' :
  (forall (T_431:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_430:(map (prod bitstring bitstring) bitstring)),
    (forall (xy_429:(prod bitstring bitstring)),
     ((Inclusion T'_430 T_431) ->
      ((in_dom_map xy_429 T_431) = true ->
       (Inclusion (upd_map T'_430 xy_429 (get_map T_431 xy_429)) T_431)))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma inclusion_upd'' :
  (forall (T_165:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_164:(map (prod bitstring bitstring) bitstring)),
    (forall (xy_163:(prod bitstring bitstring)),
     (forall (z_162:bitstring),
      ((Inclusion T'_164 T_165) ->
       (Inclusion (upd_map T'_164 xy_163 z_162) (upd_map T_165 xy_163 z_162))))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma inclusion_not_rng :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (T':(map (prod bitstring bitstring) bitstring)),
    (forall (z:bitstring),
     ((Inclusion T' T) ->
      (~(in_rng_map z T) = true -> ~(in_rng_map z T') = true))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma IV_not_rng_upd :
  (forall (T_169:(map (prod bitstring bitstring) bitstring)),
   (forall (xy_168:(prod bitstring bitstring)),
    (forall (z_167:bitstring),
     (~(in_rng_map IV T_169) = true ->
      (~z_167 = IV -> ~(in_rng_map IV (upd_map T_169 xy_168 z_167)) = true))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma Injective_upd :
  (forall (T_12:(map (prod bitstring bitstring) bitstring)),
   (forall (xy_11:(prod bitstring bitstring)),
    (forall (z_10:bitstring),
     (~(in_rng_map z_10 T_12) = true ->
      ((Injective T_12) -> (Injective (upd_map T_12 xy_11 z_10))))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma Inverse_dom_rng :
  (forall (T_641:(map (prod bitstring bitstring) bitstring)),
   (forall (invT_640:(map bitstring (prod bitstring bitstring))),
    (forall (z:bitstring),
     ((Inverse T_641 invT_640) ->
      ((in_dom_map z invT_640) = true -> (in_rng_map z T_641) = true))))).
Proof.
(* derived by the SMT solvers *)
Admitted.

Lemma Inverse_rng_dom :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (invT_186:(map bitstring (prod bitstring bitstring))),
    (forall (z_185:bitstring),
     ((Inverse T invT_186) ->
      ((in_rng_map z_185 T) = true -> (in_dom_map z_185 invT_186) = true))))).
Proof.
(* derived by the SMT solvers *)
Admitted.


(* padding lemmas *)
(******************)

Lemma prefixfree' :
  (forall (p1:(list bitstring)),
   (forall (p2:(list bitstring)),
    (~(unpad (Append p1 p2)) = (@None (list bool)) ->
     (~p2 = (@Nil bitstring) -> (unpad p1) = (@None (list bool)))))).
Proof.
(* derived by the SMT solvers using: prefixfree, append_same_nil, unpad_ex_pad *)
Admitted.

Lemma unpad_head : 
  (forall (ms_295:(list bitstring)),
   (~ms_295 = (@Nil bitstring) ->
    (~(tail ms_295) = (@Nil bitstring) ->
     (~(unpad ms_295) = (@None (list bool)) ->
      (unpad
       (Append
        (mapfst (@Nil (prod bitstring bitstring))) (Cons
                                                    (head ms_295) (@Nil bitstring)))) =
      (@None (list bool)))))).
Proof.
intros ms Hnnil Hnnil' Hpad. 
rewrite mapfst_nil. rewrite Append_nil.
destruct_list ms as a al.
 (* case ms = a::al *)
 destruct_list al as a' al'.
  (* case al = a'::al' *)
  clear - Hpad. rewrite head_def.
  eapply prefixfree'. instantiate (1 := Cons a' al').
   (* unpad ... <> None *)
   rewrite Append_Cons. rewrite Append_nil.
   assumption.
   (* a'::al' <> Nil *)
   clear. intro C. symmetry in C. apply Nil_neq_Cons in C. assumption.
  (* case al = [] *)
  clear - Hnnil'. apply False_ind. rewrite tail_def in Hnnil'. auto.
 (* case ms = [] *)
 clear - Hnnil. apply False_ind. auto.
Qed.

Lemma unpad_tail_prefix : 
  (forall (ms_299:(list bitstring)),
   (forall (c_298:(list bitstring)),
    (2 < (length_list ms_299) ->
     (~(unpad (Append c_298 ms_299)) = (@None (list bool)) ->
      (unpad
       (Append
        c_298 (Append
               (Cons (head ms_299) (@Nil bitstring)) (Cons
                                                      (head (tail ms_299)) (
                                                      @Nil bitstring))))) =
      (@None (list bool)))))).
Proof.
intros ms c.
intros Hlen Hpad.
rewrite Append_Cons. rewrite Append_nil.
destruct_list ms as a al.
 (* case ms = a::al *)
 destruct_list al as a' al'.
  (* case al = a'::al' *)
  destruct_list al' as a'' al''.
   (* case al' = a''::al'' *)
   clear - Hpad. rewrite tail_def. repeat rewrite head_def.
   eapply prefixfree'. instantiate (1 := Cons a'' al'').
   (* unpad .. <> None *)
   rewrite append_assoc_padding. repeat rewrite Append_Cons. rewrite Append_nil. assumption.
   (* a''::al'' <> Nil *)
   clear. intro C. symmetry in C. apply Nil_neq_Cons in C. assumption.
   (* case al' = [] *)
   clear - Hlen. apply False_ind. repeat rewrite length_cons in Hlen. rewrite length_nil in Hlen.
   omega.
  (* case al = [] *)
   clear - Hlen. apply False_ind. rewrite length_cons in Hlen. rewrite length_nil in Hlen.
   omega.
 (* case ms = [] *)
   clear - Hlen. apply False_ind. rewrite length_nil in Hlen. omega.
Qed.

(* lemmas on mapfst *)
(********************)

Lemma mapfst_app :
  (forall (c1_64:(list (prod bitstring bitstring))),
   (forall (c2_63:(list (prod bitstring bitstring))),
    (mapfst (Append c1_64 c2_63)) = (Append (mapfst c1_64) (mapfst c2_63)))).
intros c1 c2.
apply list_ind with (l := c1).
 (* base case, c1 = [] *)
 rewrite mapfst_nil. repeat rewrite Append_nil. reflexivity.
 (* induction step, c1 = a::al *)
 intros a al. intro IH.
 rewrite Append_Cons. rewrite <- (surjective_pairing _ _ a). repeat rewrite mapfst_cons.
 rewrite Append_Cons. rewrite IH.
 reflexivity.
Qed.


(* lemmas on ischained *)
(***********************)

Lemma ischained_lasteq : 
  (forall (T_112:(map (prod bitstring bitstring) bitstring)),
   (forall (xy_111:(prod bitstring bitstring)),
    (forall (y_110:bitstring),
     (forall (c_109:(list (prod bitstring bitstring))),
      (forall (z_108:bitstring),
       ((ischained T_112 y_110 (Cons xy_111 c_109) z_108) = true ->
        y_110 = (snd_prod xy_111))))))).
Proof.
intros T xy y c z.
intros.
destruct_list c as xy' c'.
 (* case c = xy'::c' *)
 rewrite ischained_conscons in H. tauto.
 (* case c = [] *)
 rewrite ischained_cons in H. tauto.
Qed.

Lemma ischained_app : 
  (forall (T_92:(map (prod bitstring bitstring) bitstring)),
   (forall (Y_91:bitstring),
    (forall (xy_90:(prod bitstring bitstring)),
     (forall (Z_89:bitstring),
      (forall (c1_88:(list (prod bitstring bitstring))),
       (forall (c2_87:(list (prod bitstring bitstring))),
        (((ischained T_92 Y_91 c1_88 (snd_prod xy_90)) = true /\
         (in_dom_map xy_90 T_92) = true) /\
         (ischained T_92 (get_map T_92 xy_90) c2_87 Z_89) = true <->
         (ischained T_92 Y_91 (Append c1_88 (Cons xy_90 c2_87)) Z_89) = true))))))).
Proof.
intros T Y xy Z c1 c2.
split.

 (* -> *)
 intuition.
 generalize Y H; clear Y H.
 apply list_ind with (l := c1).
  (* base case, c1 = [] *)
  intros. rewrite Append_nil.
  rewrite ischained_nil in H. subst.
  destruct_list c2 as xy' c2'.
   (* case c2 = xy'::c2' *)
   rewrite ischained_conscons.
   rewrite <- (ischained_lasteq _ _ _ _ _ H1). auto.
   (* case c2 = [] *)
   rewrite ischained_cons.
   rewrite ischained_nil in H1. auto.
  (* induction step, c1 = a::c1' *)
  intros a c1'. intro IH. intros.
  destruct_list c1' as b c1''.
   (* case c1' = b::c1'' *)
   specialize (IH (snd_prod b)).
   repeat rewrite Append_Cons in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_conscons in *.
   tauto.
   (* case c1' = [] *)
   specialize (IH (snd_prod xy)).
   rewrite Append_Cons. rewrite Append_nil in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_nil in IH. rewrite ischained_cons in H. rewrite ischained_conscons.
   tauto.

 (* <- *)
 generalize Y; clear Y. 
 apply list_ind with (l := c1).
  (* base case, c1 = [] *)
  intros. rewrite Append_nil in H.
  rewrite ischained_nil.
  destruct_list c2 as xy' c2'.
   (* case c2 = xy'::c2' *)
   rewrite ischained_conscons in H. intuition.
   rewrite H2. assumption.
   (* case c2 = [] *)
   apply ischained_cons in H. intuition.
   rewrite ischained_nil. assumption.
  (* induction step, c1 = a::c1' *)
  intros a c1'. intro IH. intros.
  destruct_list c1' as b c1''.
   (* case c1' = b::c1'' *)
   specialize (IH (snd_prod b)).
   repeat rewrite Append_Cons in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_conscons in *. tauto.
   (* case c1' = [] *)
   specialize (IH (snd_prod xy)).
   rewrite Append_Cons in H. rewrite Append_nil in *.
   rewrite (ischained_lasteq _ _ _ _ _ H). rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   rewrite ischained_nil in IH. rewrite ischained_conscons in H. rewrite ischained_cons.
   tauto.
Qed.

Lemma ischained_same_length : 
  (forall (T_148:(map (prod bitstring bitstring) bitstring)),
   (forall (Y1_147:bitstring),
    (forall (Y2_146:bitstring),
     (forall (c1_145:(list (prod bitstring bitstring))),
      (forall (c2_144:(list (prod bitstring bitstring))),
       (forall (z_143:bitstring),
        ((length_list c1_145) = (length_list c2_144) ->
         ((Injective T_148) ->
          ((ischained T_148 Y1_147 c1_145 z_143) = true ->
           ((ischained T_148 Y2_146 c2_144 z_143) = true -> c1_145 = c2_144)))))))))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Heq HB2 Hch1 Hch2.
generalize Hch1 Heq; clear Hch1 Heq.
generalize Hch2; clear Hch2.
generalize c2 Y1 Y2; clear c2 Y1 Y2.
apply list_ind with (l := c1).

 (* base case, c1 = [] *)
 intros.
 destruct_list c2 as b bl.
  (* case c2 = b::bl *)
  apply False_ind. clear - Heq.
  rewrite length_cons in Heq. rewrite length_nil in Heq.
  remember (length_pos _ bl) as Hpos; clear HeqHpos. omega.
  (* case seq2 = [] *)
  reflexivity.

 (* induction step, c1 = a::al *)
 intros a al. intros IH. intros.
 destruct_list c2 as b bl.
  (* case c2 = b::bl *)
  specialize (IH bl).
  assert (length_list al = length_list bl) as Heq'; [repeat rewrite length_cons in Heq; omega|].
  clear Heq; rename Heq' into Heq.
  assert (forall (x:prod bitstring bitstring) xl, (Cons x xl) = (Append Nil (Cons x xl))).
   clear. intros. rewrite Append_nil. reflexivity.
  rewrite H in Hch1, Hch2; clear H.
  rewrite <- ischained_app in Hch1, Hch2.
  destruct Hch1 as ((_,Hdoma),Hch1). destruct Hch2 as ((_,Hdomb),Hch2).
  specialize (IH (get_map T a) (get_map T b) Hch2 Hch1 Heq).
  subst. clear - HB2 Hdoma Hdomb Hch1 Hch2. move HB2 after b.
  cut (a = b); [intro; subst; reflexivity|].
  destruct_list bl as b' bl'.
   (* case bl = b'::bl' *)
   assert (Cons b' bl' = Append Nil (Cons b' bl')).
    clear. intros. rewrite Append_nil. reflexivity.
   rewrite H in Hch1, Hch2; clear H.
   rewrite <- ischained_app in Hch1, Hch2.
   destruct Hch1 as ((Heq,_),_). destruct Hch2 as ((Heq',_),_).
   rewrite ischained_nil in Heq, Heq'. rewrite <- Heq' in Heq; clear Heq'.
   unfold Injective in HB2.
   exact (HB2 a b Hdoma Hdomb Heq).
   (* case bl = [] *)
   rewrite ischained_nil in Hch1, Hch2. rewrite <- Hch2 in Hch1; clear Hch2.
   unfold Injective in HB2.
   exact (HB2 a b Hdoma Hdomb Hch1).
  (* case c2 = b::bl *)
  apply False_ind. clear - Heq.
  rewrite length_cons in Heq. rewrite length_nil in Heq.
  remember (length_pos _ al) as Hpos; clear HeqHpos. omega.
Qed.

Lemma ischained_diff_length : 
  (forall (T_164:(map (prod bitstring bitstring) bitstring)),
   (forall (Y1_163:bitstring),
    (forall (Y2_162:bitstring),
     (forall (c1_161:(list (prod bitstring bitstring))),
      (forall (c2_160:(list (prod bitstring bitstring))),
       (forall (z_159:bitstring),
        ((gt_int_bool (length_list c1_161) (length_list c2_160)) = true ->
         ((Injective T_164) ->
          ((ischained T_164 Y1_163 c1_161 z_159) = true ->
           ((ischained T_164 Y2_162 c2_160 z_159) = true ->
            (exists xy:(prod bitstring bitstring),
             (exists pre:(list (prod bitstring bitstring)),
              c1_161 = (Append pre (Cons xy c2_160)))))))))))))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Hgt HB2 Hch1 Hch2.
rewrite gt_int_bool_axiom in Hgt.
generalize Hch1 Hch2 Hgt; clear Hch1 Hch2 Hgt.
generalize c1 Y1 Y2; clear c1 Y1 Y2.
apply list_ind with (l := c2).

 (* base case, c2 = [] *)
 intros.
 destruct_list c1 as a al.
  (* case c1 = a::al *)
  (* in this case, we have to show: exists x xl, a::al = xl@x *)
  exact (cons_append_swap a al).
  (* case c1 = [] *)
  (* in this case, we get a contradiction since we have length([]) > length([]) *)
  apply False_ind. clear - Hgt.
  rewrite length_nil in Hgt. omega.

 (* induction step, c2 = b::bl *)
 intros b bl IH. intros.
 destruct_list c1 as a al.
  (* case c1 = a::al *)
  (* in this case we use the IH to obtain: exists x xl, al = xl++x::bl *)
  specialize (IH al).
  assert (length_list al > length_list bl) as Hgt'; [repeat rewrite length_cons in Hgt; omega|].
  clear Hgt; rename Hgt' into Hgt.
  assert (forall (x:prod bitstring bitstring) xl, (Cons x xl) = (Append Nil (Cons x xl))).
   clear. intros. rewrite Append_nil. reflexivity.
  rewrite H in Hch1, Hch2; clear H.
  rewrite <- ischained_app in Hch1, Hch2.
  destruct Hch1 as (_,Hch1). destruct Hch2 as ((_,Hdomb),Hch2).
  specialize (IH (get_map T a) (get_map T b) Hch1 Hch2 Hgt).
  destruct IH as (xy',(pre')). subst.
  clear - HB2 Hdomb Hch1 Hch2. move HB2 after a.
  (* we now want to show that xy' = b; then it is easy to find instances for xy and pre in the goal *)
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as ((_,Hdomxy'),Hch1).
  destruct_list bl as b' bl'.
   (* case bl = b'::bl' *)
   rewrite <- (Append_nil _ (Cons b' bl')) in Hch1, Hch2.
   rewrite <- ischained_app in Hch1, Hch2.
   destruct Hch1 as ((Hch1,_),_). destruct Hch2 as ((Hch2,_),_).
   rewrite ischained_nil in Hch1, Hch2.
   rewrite <- Hch2 in Hch1; clear Hch2.
   unfold Injective in HB2.
   specialize (HB2 xy' b Hdomxy' Hdomb Hch1). subst.
   rewrite <- Append_Cons.
   destruct (cons_append_swap a pre') as (xy,(pre)). rewrite H.
   exists xy, pre. rewrite append_assoc. rewrite Append_Cons. rewrite Append_nil.
   reflexivity.
   (* case bl = [] *)
   rewrite ischained_nil in Hch1, Hch2.
   rewrite <- Hch2 in Hch1; clear Hch2.
   unfold Injective in HB2.
   specialize (HB2 xy' b Hdomxy' Hdomb Hch1). subst.
   rewrite <- Append_Cons.
   destruct (cons_append_swap a pre') as (xy,(pre)). rewrite H.
   exists xy, pre. rewrite append_assoc. rewrite Append_Cons. rewrite Append_nil.
   reflexivity.
  (* case c1 = [] *)
  apply False_ind. clear - Hgt.
  rewrite length_nil in Hgt. rewrite length_cons in Hgt.
  remember (length_pos _ bl) as Hpos; clear HeqHpos.
  omega.
Qed.

Lemma ischained_diff_length_absurd : 
  (forall (T_176:(map (prod bitstring bitstring) bitstring)),
   (forall (Y1_175:bitstring),
    (forall (Y2_174:bitstring),
     (forall (c1_173:(list (prod bitstring bitstring))),
      (forall (c2_172:(list (prod bitstring bitstring))),
       (forall (z_171:bitstring),
        ((gt_int_bool (length_list c1_173) (length_list c2_172)) = true ->
         (~(in_rng_map Y2_174 T_176) = true ->
          ((Injective T_176) ->
           ((ischained T_176 Y1_175 c1_173 z_171) = true ->
            ((ischained T_176 Y2_174 c2_172 z_171) = true -> False))))))))))).
Proof.
intros T Y1 Y2 c1 c2 z.
intros Hgt HB1 HB2 Hch1 Hch2.
remember (ischained_diff_length T Y1 Y2 c1 c2 z Hgt HB2 Hch1 Hch2) as H; clear HeqH.
destruct H as (a,(al)); subst.
clear HB2 Hgt.
assert (in_rng_map Y2 T = true).
 clear HB1.
 destruct_list c2 as b bl.
  (* case c2 = b::bl *)
  apply ischained_lasteq in Hch2. subst.
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as ((_,Hdoma),Hch1).
  apply in_dom_in_rng_map in Hdoma.
  rewrite (ischained_lasteq _ _ _ _ _ Hch1) in Hdoma.
  assumption.
  (* case c2 = [] *)
  rewrite ischained_nil in Hch2. subst.
  rewrite <- ischained_app in Hch1.
  destruct Hch1 as ((_,Hdoma),Hch1).
  apply in_dom_in_rng_map in Hdoma.
  rewrite ischained_nil in Hch1. rewrite Hch1 in Hdoma.
  assumption.
exact (HB1 H).
Qed.

Lemma ischained_inj :
  (forall (T_181:(map (prod bitstring bitstring) bitstring)),
   (forall (Y_180:bitstring),
    (forall (c1_179:(list (prod bitstring bitstring))),
     (forall (c2_178:(list (prod bitstring bitstring))),
      (forall (z_177:bitstring),
       (~(in_rng_map Y_180 T_181) = true ->
        ((Injective T_181) ->
         ((ischained T_181 Y_180 c1_179 z_177) = true ->
          ((ischained T_181 Y_180 c2_178 z_177) = true -> c1_179 = c2_178))))))))).
Proof.
(* derived by the SMT solvers using:
ischained_same_length, ischained_diff_length_absurd *)
Admitted.

Lemma ischained_in_dom : 
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (c:(list (prod bitstring bitstring))),
    (forall (xy:(prod bitstring bitstring)),
     (forall (z:bitstring),
      ((in_list xy c) = true ->
       ((ischained T IV c z) = true ->
        (in_dom_map xy T) = true)))))).
Proof.
intros T c xy z.
intros Hin Hch; generalize Hin Hch; clear Hin Hch. (* internally give the premises names *)
generalize IV as Y.
apply list_ind with (l := c).
 (* case c = [] *)
 intros. clear Hch. apply False_ind.
 rewrite in_list_Nil in Hin. inversion Hin.
 (* case c = a::al *)
 intros a al IH. intros.
 rewrite in_list_Cons in Hin. rewrite bool_or_def in Hin. rewrite poly_eq_eq in Hin.
 rewrite <- (Append_nil _ (Cons a al)) in Hch. rewrite <- ischained_app in Hch.
 destruct Hch as ((_,Hdom),Hch).
 destruct Hin as [Heq|Hin].
  (* case xy = a *)
  clear IH Hch. subst. assumption.
  (* case in_list xy al = true *)
  clear Hdom. specialize (IH (get_map T a)). tauto.
Qed.

Lemma ischained_upd : 
  (forall (T_397:(map (prod bitstring bitstring) bitstring)),
   (forall (c_396:(list (prod bitstring bitstring))),
    (forall (xy_395:(prod bitstring bitstring)),
     (forall (z_394:bitstring),
      (forall (z'_393:bitstring),
       (~(in_list xy_395 c_396) = true ->
        ((ischained T_397 IV c_396 z_394) = true ->
         (ischained (upd_map T_397 xy_395 z'_393) IV c_396 z_394) = true))))))).
Proof.
intros T c xy z z'.
intros Hnin Hch.
generalize Hnin Hch; clear Hnin Hch.
generalize IV as Y.
apply list_ind with (l := c).
 (* c = [] *)
 intros. rewrite ischained_nil in *; trivial.
 (* c = a::al *)
 intros a al IH. intros.
 rewrite <- (Append_nil _ (Cons a al)).
 apply ischained_app.
 rewrite <- (Append_nil _ (Cons a al)) in Hch.
 apply ischained_app in Hch. rewrite ischained_nil in *.
 destruct Hch as ((HY,Hdom),Hch).
 repeat split; try assumption.
 (* a in dom(upd(T,xy,z')) *)
 clear - Hdom. apply in_dom_upd_map1.
 right; assumption.
 (* ischained upd(T,xy,z') upd(T,xy,z')[a] al z = true *)
 clear - IH Hch Hnin.
 assert ( a <> xy ) as n0.
  clear - Hnin.
  rewrite in_list_Cons in Hnin. rewrite bool_or_def in Hnin. rewrite poly_eq_eq in Hnin.
  intuition.
 rewrite get_upd_map_diff; try auto.
 specialize (IH (get_map T a)).
 rewrite in_list_Cons in Hnin. rewrite bool_or_def in Hnin. rewrite poly_eq_eq in Hnin.
 intuition.
Qed.

Lemma ischained_upd' : 
  (forall (T_407:(map (prod bitstring bitstring) bitstring)),
   (forall (c_406:(list (prod bitstring bitstring))),
    (forall (xy_405:(prod bitstring bitstring)),
     (forall (z_404:bitstring),
      (forall (z'_403:bitstring),
       (~(in_dom_map xy_405 T_407) = true ->
        ((ischained T_407 IV c_406 z_404) = true ->
         (ischained (upd_map T_407 xy_405 z'_403) IV c_406 z_404) = true))))))).
Proof.
intros T c xy z z'.
intros Hndom Hch.
generalize Hndom Hch; clear Hndom Hch.
generalize IV as Y.
apply list_ind with (l := c).
 (* c = [] *)
 intros. rewrite ischained_nil in *; trivial.
 (* c = a::al *)
 intros a al IH. intros.
 rewrite <- (Append_nil _ (Cons a al)).
 apply ischained_app.
 rewrite <- (Append_nil _ (Cons a al)) in Hch.
 apply ischained_app in Hch. rewrite ischained_nil in *.
 destruct Hch as ((HY,Hdom),Hch).
 repeat split; try assumption.
 (* a in dom(upd(T,xy,z')) *)
 clear - Hdom. apply in_dom_upd_map1.
 right; assumption.
 (* ischained upd(T,xy,z') upd(T,xy,z')[a] al z = true *)
 clear - IH Hch Hndom Hdom.
 assert ( a <> xy ) as n0.
  clear - Hndom Hdom.
  intro e; rewrite e in *; clear e.
  exact (Hndom Hdom).
 rewrite get_upd_map_diff; auto.
Qed.

Lemma ischained_mapfst_eq : 
  (forall (T_281:(map (prod bitstring bitstring) bitstring)),
   (forall (c1_280:(list (prod bitstring bitstring))),
    (forall (c2_279:(list (prod bitstring bitstring))),
     (forall (z1_278:bitstring),
      (forall (z2_277:bitstring),
       ((ischained T_281 IV c1_280 z1_278) = true ->
        ((ischained T_281 IV c2_279 z2_277) = true ->
         ((mapfst c1_280) = (mapfst c2_279) -> c1_280 = c2_279 /\
          z1_278 = z2_277)))))))).
Proof.
intros T c1 c2 z1 z2.
intros Hch1 Hch2 Heq.
generalize Hch1 Hch2; clear Hch1 Hch2.
generalize IV as Y.
generalize Heq; clear Heq.
generalize c2; clear c2.
apply list_ind with (l := c1).
 (* case c1 = [] *)
 intros. destruct_list c2 as b bl.
  (* c2 = b::bl *)
  clear - Heq. apply False_ind.
  rewrite mapfst_nil in Heq. rewrite <- (surjective_pairing _ _ b) in Heq. rewrite mapfst_cons in Heq.
  exact (Nil_neq_Cons _ _ _ Heq).
  (* c2 = [] *)
  clear Heq.
  rewrite ischained_nil in *.
  rewrite <- Hch1. rewrite <- Hch2.
  tauto.

 (* case c1 = a::al *)
 intros a al IH. intros.
 destruct_list c2 as b bl.
  (* c2 = b::bl *)
  specialize (IH bl).
  rewrite <- (surjective_pairing _ _ a) in Heq. rewrite <- (surjective_pairing _ _ b) in Heq.
  repeat rewrite mapfst_cons in Heq.
  apply Cons_inj in Heq.
  destruct Heq as (Hfsteq,Hmapeq).
  specialize (IH Hmapeq); clear Hmapeq.
  rewrite <- (Append_nil _ (Cons a al)) in Hch1.
  rewrite <- (Append_nil _ (Cons b bl)) in Hch2.
  rewrite <- ischained_app in Hch1.
  rewrite <- ischained_app in Hch2.
  destruct Hch1 as ((Hsndeq',_),Hch1).
  destruct Hch2 as ((Hsndeq,_),Hch2).
  rewrite ischained_nil in Hsndeq, Hsndeq'.
  rewrite Hsndeq' in Hsndeq; clear Hsndeq'.
  assert (a = b) as Heq.
   clear - Hfsteq Hsndeq.
   rewrite <- (surjective_pairing _ _ a). rewrite <- (surjective_pairing _ _ b).
   rewrite Hfsteq, Hsndeq. reflexivity.
  clear Hfsteq Hsndeq.
  rewrite Heq in *; clear Heq.
  specialize (IH (get_map T b) Hch1 Hch2); clear Hch1 Hch2.
  destruct IH as (Heq,Heq'). rewrite Heq, Heq'.
  split; reflexivity.
  (* c2 = [] *)
  clear - Heq. apply False_ind.
  rewrite mapfst_nil in Heq. rewrite <- (surjective_pairing _ _ a) in Heq. rewrite mapfst_cons in Heq.
  symmetry in Heq.
  exact (Nil_neq_Cons _ _ _ Heq).
Qed.

Lemma ischained_inclusion :
  (forall (T'_507:(map (prod bitstring bitstring) bitstring)),
   (forall (T_506:(map (prod bitstring bitstring) bitstring)),
    (forall (Y_505:bitstring),
     (forall (c_504:(list (prod bitstring bitstring))),
      (forall (z_503:bitstring),
       ((Inclusion T'_507 T_506) ->
        ((ischained T'_507 Y_505 c_504 z_503) = true ->
         (ischained T_506 Y_505 c_504 z_503) = true))))))).
Proof.
intros T' T Y c z.
intros Hsub.
generalize Y; clear Y.
apply list_ind with (l := c).
 (* base case *)
 intro Y. repeat rewrite ischained_nil; trivial.
 (* induction step, c = a::ab *)
 intros a ab IH Y Hch.
 assert (Cons a ab = Append Nil (Cons a ab)).
  clear. rewrite Append_nil. reflexivity.
 rewrite H in *; clear H.
 apply ischained_app.
 apply ischained_app in Hch.
 repeat split. 
 (* ischained T Y Nil (snd_prod a) = true *)
 clear - Hch.
 rewrite ischained_nil in *. tauto.
 (* in_dom_map a T = true *)
 clear - Hsub Hch.
 destruct Hch as ((_,Hdom),_).
 unfold Inclusion in Hsub.
 destruct Hsub as (Hsub,_).
 exact (Hsub a Hdom).
 (* ischained T (get_map T a) ab z = true *)
 clear - IH Hsub Hch.
 destruct Hch as ((_,Hdom),Hch).
 unfold Inclusion in Hsub.
 destruct Hsub as (_,Hsub).
 specialize (Hsub a Hdom).
 rewrite <- Hsub; clear Hsub.
 exact (IH (get_map T' a) Hch).
Qed.

Lemma ischained_helpful_upd : 
  (forall (T_529:(map (prod bitstring bitstring) bitstring)),
   (forall (c_528:(list (prod bitstring bitstring))),
    (forall (x_527:bitstring),
     (forall (y_526:bitstring),
      (forall (y'_525:bitstring),
       (forall (z_524:bitstring),
        (~(ischained T_529 IV c_528 y'_525) = true ->
         ((ischained (upd_map T_529 (pair x_527 y_526) z_524) IV c_528 y'_525) =
          true -> (in_list (pair x_527 y_526) c_528) = true)))))))).
Proof.
intros T c x y y' z.
generalize IV as Y.
apply list_ind with (l := c).

 (* case c = [] *)
 intros Y Hnch Hch. apply False_ind.
 apply ischained_nil in Hch. 
 subst. rewrite ischained_nil in Hnch.
 auto.

 (* case c = a::ab *)
 intros a ab IH.
 intros Y Hnch Hch.
 rewrite in_list_Cons. rewrite bool_or_def. rewrite poly_eq_eq.
 apply not_imply_to_or; intros.
 destruct_list ab as a' ab'.
  (* case ab = a'::ab' *)
  specialize (IH (get_map (upd_map T (pair x y) z) a)).
  (* now we have to show:
      ischained T (get_map (upd_map T (pair x y) z) a) (Cons a' ab') y' <> true *)
  assert ( ischained T (get_map (upd_map T (pair x y) z) a) (Cons a' ab') y' <> true ) as Hnch'.
   clear - Hch Hnch H.
   rewrite ischained_conscons in Hch.
   destruct Hch as (((Hdom,Heq),HTa),_).
   rewrite ischained_conscons in Hnch.
   duplicate H as H'.
   apply upd_map_dom_diff with (m := T) (b := z) in H.
   rewrite H in Hdom; clear H.
   apply get_upd_map_diff with (m := T) (b := z) in H'.
   rewrite H' in HTa; clear H'.
   intro. rewrite (ischained_lasteq _ _ _ _ _ H) in H.
   tauto.
  rewrite ischained_conscons in Hch.
  clear - IH Hch Hnch'.
  destruct Hch as ((_,Heq),Hch).
  rewrite <- Heq in Hch; clear Heq.
  apply IH; assumption.
  (* case ab = [] *)
  apply False_ind. clear - Hnch Hch H.
  assert (ischained T Y (Cons a Nil) y' = true).
   clear Hnch.
   rewrite ischained_cons in *.
   destruct Hch as ((Hdom, Heq), HTa).
   repeat split; [|assumption|].
    (* a in dom(T) *)
    apply upd_map_dom_diff with (m := T) (b := z) in H.   
    rewrite H in Hdom. assumption.
    (* T[a] = y' *)
    apply get_upd_map_diff with (m := T) (b := z) in H.   
    rewrite H in HTa. assumption.
  exact (Hnch H0).
Qed.

Lemma ischained_last_cases : 
  (forall (T_449:(map (prod bitstring bitstring) bitstring)),
   (forall (c_448:(list (prod bitstring bitstring))),
    (forall (z_447:bitstring),
     ((ischained T_449 IV c_448 z_447) = true -> z_447 = IV \/
      (exists x_446:bitstring,
       (exists y_445:bitstring,
        (in_dom_map (pair x_446 y_445) T_449) = true /\
        (get_map T_449 (pair x_446 y_445)) = z_447)))))).
Proof.
(* derived by the SMT solvers using:
exists_last, ischained_nil, ischained_app *)
intros T c z.
intros Hch.
case exists_last with (c  := c).
 (* c = [] *)
 intros e; rewrite e in *; clear e.
 left. rewrite ischained_nil in Hch.
 auto.
 (* c = al@[a] *)
 intros e. destruct e as (c',(xy',e)).
 rewrite e in *; clear e.
 right. exists (fst_prod xy'), (snd_prod xy').
 rewrite surjective_pairing.
 apply ischained_app in Hch. rewrite ischained_nil in Hch.
 destruct Hch as ((_,Hdom),Hnext).
 auto.
Qed.

Lemma claim4 : 
  (forall (T_583:(map (prod bitstring bitstring) bitstring)),
   (~(in_rng_map IV T_583) = true ->
    ((Injective T_583) ->
     (forall (c1_582:(list (prod bitstring bitstring))),
      (forall (c2_581:(list (prod bitstring bitstring))),
       (forall (xy_580:(prod bitstring bitstring)),
        (forall (xy'_579:(prod bitstring bitstring)),
         ((ischained T_583 IV c1_582 (snd_prod xy_580)) = true ->
          (~(unpad
             (mapfst
              (Append c1_582 (Cons xy_580 (@Nil (prod bitstring bitstring)))))) =
            (@None (list bool)) ->
           ((ischained T_583 IV c2_581 (snd_prod xy'_579)) = true ->
            (~(unpad
               (mapfst
                (Append
                 c2_581 (Cons xy'_579 (@Nil (prod bitstring bitstring)))))) =
              (@None (list bool)) ->
             ~(in_list xy_580 c2_581) = true))))))))))).
Proof.
intros T HB1 HB2 c1 c2 xy xy'.
move HB1 after xy'. move HB2 after HB1.
intros Hch1 Hpad1 Hch2 Hpad2.
intro C.
apply in_split in C.
destruct C as (al,(bl,C)). move al after xy'. move bl after xy'.
rewrite C in *; clear C c2; rename c1 into c.
assert (al = c).
 clear - HB1 HB2 Hch1 Hch2.
 rewrite <- ischained_app in Hch2.
 destruct Hch2 as ((Hch2,_),_).
 eapply ischained_inj; eauto.
rewrite H in *; clear H.
clear - Hpad1 Hpad2.
remember (prefixfree' (mapfst (Append c (Cons xy Nil))) (mapfst (Append bl (Cons xy' Nil)))) as C; clear HeqC.
rewrite <- mapfst_app in C.
rewrite append_assoc in *. rewrite Append_Cons in *. rewrite Append_nil in C.
apply C in Hpad2; clear C.
 (* here we get the contradiction *)
 exact (Hpad1 Hpad2).
 (* it remains to prove that mapfst (Append bl (Cons xy' Nil)) <> Nil *)
 clear. destruct_list bl as b' bl'.
  (* case bl = b'::bl' *)
  rewrite Append_Cons. rewrite <- (surjective_pairing _ _ b'). rewrite mapfst_cons.
  intro C. symmetry in C. apply Nil_neq_Cons in C. assumption.
  (* case bl = [] *)
  rewrite Append_nil. rewrite <- (surjective_pairing _ _ xy'). rewrite mapfst_cons.
  intro C. symmetry in C. apply Nil_neq_Cons in C. assumption.
Qed.


(* lemmas on find_seq *)
(**********************)

Lemma find_seq_complete_unique :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (x:bitstring),
    (forall (y:bitstring),
     (forall (c:(list (prod bitstring bitstring))),
      ((Injective T) ->
       (~(in_rng_map IV T) = true ->
        ((ischained T IV c y) = true ->
         (~(unpad
            (mapfst
             (Append
              c (Cons
                     (pair x y) (@Nil (prod bitstring bitstring)))))) =
           (@None (list bool)) ->
          ~(find_seq x y T) =
           (@None (list (prod bitstring bitstring))) /\
          (find_seq x y T) = (Some c))))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_complete, find_seq_ischained, ischained_inj *)
Admitted.

Lemma find_seq_complete_valid_chain :
  (forall (T_419:(map (prod bitstring bitstring) bitstring)),
   (forall (x_418:bitstring),
    (forall (y_417:bitstring),
     (forall (c_416:(list (prod bitstring bitstring))),
      ((Injective T_419) ->
       (~(in_rng_map IV T_419) = true ->
        ((valid_chain
          (Append
           c_416 (Cons (pair x_418 y_417) (@Nil (prod bitstring bitstring)))) T_419) ->
         ~(find_seq x_418 y_417 T_419) =
          (@None (list (prod bitstring bitstring)))))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_complete, ischained_app *)
Admitted.

Lemma find_seq_complete_unique_valid_chain :
  (forall (T_427:(map (prod bitstring bitstring) bitstring)),
   (forall (x_426:bitstring),
    (forall (y_425:bitstring),
     (forall (c_424:(list (prod bitstring bitstring))),
      ((Injective T_427) ->
       (~(in_rng_map IV T_427) = true ->
        ((valid_chain
          (Append
           c_424 (Cons (pair x_426 y_425) (@Nil (prod bitstring bitstring)))) T_427) ->
         ~(find_seq x_426 y_425 T_427) =
          (@None (list (prod bitstring bitstring))) /\
         (proj (find_seq x_426 y_425 T_427)) = c_424))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_complete_unique, ischained_app *)
Admitted.

Lemma find_seq_mapfst_eq : 
  (forall (T_373:(map (prod bitstring bitstring) bitstring)),
   (forall (x1_372:bitstring),
    (forall (y1_371:bitstring),
     (forall (x2_370:bitstring),
      (forall (y2_369:bitstring),
       (~(find_seq x1_372 y1_371 T_373) =
         (@None (list (prod bitstring bitstring))) ->
        (~(find_seq x2_370 y2_369 T_373) =
          (@None (list (prod bitstring bitstring))) ->
         ((proj
           (unpad
            (mapfst
             (Append
              (proj (find_seq x2_370 y2_369 T_373)) (Cons
                                                     (pair x2_370 y2_369) (
                                                     @Nil (prod bitstring bitstring))))))) =
          (proj
           (unpad
            (mapfst
             (Append
              (proj (find_seq x1_372 y1_371 T_373)) (Cons
                                                     (pair x1_372 y1_371) (
                                                     @Nil (prod bitstring bitstring))))))) ->
          (pair x1_372 y1_371) = (pair x2_370 y2_369))))))))).
Proof.
intros T x1 y1 x2 y2.
intros Hseq1 Hseq2 Heq.
duplicate Hseq1 as Hseq1'.
duplicate Hseq2 as Hseq2'.
apply find_seq_ischained in Hseq1.
apply find_seq_ischained in Hseq2.
apply find_seq_unpad in Hseq1'.
apply find_seq_unpad in Hseq2'.

apply Proj_eq in Heq.
 (* main goal *)
 apply unpad_inj in Heq; [|exact Hseq2'].
 clear Hseq2'.
 repeat rewrite mapfst_app in Heq.
 repeat rewrite mapfst_cons in Heq.
 repeat rewrite mapfst_nil in Heq.
 apply app_inj_tail in Heq. destruct Heq.
 symmetry in H. symmetry in H0.
 remember (proj2 (ischained_mapfst_eq T (proj (find_seq x1 y1 T)) (proj (find_seq x2 y2 T)) y1 y2 Hseq1 Hseq2 H)).
 clear Hseq1 Hseq2 H Heqe.
 subst. reflexivity.
 (* unpad (proj (find_seq x2 y2 T)++(x2,y2)::[]) <> None *)
 clear - Hseq2'. intro e. rewrite e in *; clear e.
 auto.
 (* unpad (proj (find_seq x2 y2 T)++(x2,y2)::[]) <> None *)
 clear - Hseq1'. intro e. rewrite e in *; clear e.
 auto.
Qed.

Lemma find_seq_Inclusion_eq :
  (forall (T'_527:(map (prod bitstring bitstring) bitstring)),
   (forall (T_526:(map (prod bitstring bitstring) bitstring)),
    (forall (x_525:bitstring),
     (forall (y_524:bitstring),
      ((Inclusion T'_527 T_526) ->
       ((Injective T_526) ->
        (~(in_rng_map IV T_526) = true ->
         (~(find_seq x_525 y_524 T'_527) =
           (@None (list (prod bitstring bitstring))) ->
          (find_seq x_525 y_524 T_526) = (find_seq x_525 y_524 T'_527))))))))).
Proof.
intros T' T x y Hsub HB2 HB1 Hseq.
duplicate Hseq as Hseq'.
apply find_seq_ischained in Hseq.
apply find_seq_complete_unique with (x := x) in Hseq.
 (* find_seq x y T = find_seq x y T' *)
 destruct Hseq as (_,Hsome).
 duplicate Hseq' as Hpad; rename Hseq' into Hch.
 apply find_seq_ischained in Hch.
 apply find_seq_unpad in Hpad.
 apply ischained_inclusion with (T_506 := T) in Hch; [|assumption].
 clear Hsub.
 apply find_seq_complete_unique with (x := x) in Hch; try assumption.
 rewrite <- Hsome in Hch.
 tauto.
 (* Injective T' *)
 clear - Hsub HB2.
 apply inclusion_injective with (T' := T') in HB2; assumption.
 (* in_rng_map IV T' <> true *)
 clear - Hsub HB1.
 apply inclusion_not_rng with (T' := T') in HB1; assumption.
 (* unpad ... (find_seq x y T') ++ [(x,y)] <> None *)
 clear - Hseq'. 
 apply find_seq_unpad in Hseq'; assumption.
Qed.


Lemma find_seq_Inclusion_upd_eq :
  (forall (T_459:(map (prod bitstring bitstring) bitstring)),
   (forall (T':(map (prod bitstring bitstring) bitstring)),
    (forall (x_457:bitstring),
     (forall (y_456:bitstring),
      (forall (x'_455:bitstring),
       (forall (y'_454:bitstring),
        (forall (z'_453:bitstring),
         ((Inclusion T' T_459) ->
          ((Injective T_459) ->
           (~(in_rng_map IV T_459) = true ->
            (~z'_453 = IV ->
             (~(in_rng_map z'_453 T_459) = true ->
              (~(in_dom_map (pair x'_455 y'_454) T_459) = true ->
               (~(find_seq x_457 y_456 T') =
                 (@None (list (prod bitstring bitstring))) ->
                (find_seq
                 x_457 y_456 (upd_map T_459 (pair x'_455 y'_454) z'_453)) =
                (find_seq x_457 y_456 T'))))))))))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_Inclusion_eq *)
Admitted.

Lemma find_seq_last_in_dom_ischained :
  (forall (T_543:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_542:(map (prod bitstring bitstring) bitstring)),
    (forall (x_541:bitstring),
     (forall (y_540:bitstring),
      ((Inclusion T'_542 T_543) ->
       (~(find_seq x_541 y_540 T'_542) =
         (@None (list (prod bitstring bitstring))) ->
        ((in_dom_map (pair x_541 y_540) T_543) = true ->
         (ischained
          T_543 IV (Append
                    (proj (find_seq x_541 y_540 T'_542)) (Cons
                                                          (pair x_541 y_540) (
                                                          @Nil (prod bitstring bitstring)))) (
          get_map T_543 (pair x_541 y_540))) =
         true))))))).
Proof.
(* derived by the SMT solvers using:
ischained_app, ischained_nil, ischained_inclusion, find_seq_ischained *)
Admitted.

Lemma find_seq_last_in_dom_valid :
  (forall (T_475:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_474:(map (prod bitstring bitstring) bitstring)),
    (forall (x_473:bitstring),
     (forall (y_472:bitstring),
      ((Inclusion T'_474 T_475) ->
       (~(find_seq x_473 y_472 T'_474) =
         (@None (list (prod bitstring bitstring))) ->
        ((in_dom_map (pair x_473 y_472) T_475) = true ->
         (valid_chain
          (Append
           (proj (find_seq x_473 y_472 T'_474)) (Cons
                                                 (pair x_473 y_472) (
                                                 @Nil (prod bitstring bitstring)))) T_475)))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_unpad, find_seq_last_in_dom_ischained *)
Admitted.

Lemma find_seq_upd' : 
  (forall (T_469:(map (prod bitstring bitstring) bitstring)),
   (forall (xy_468:(prod bitstring bitstring)),
    (forall (x'_467:bitstring),
     (forall (y'_466:bitstring),
      (forall (z_465:bitstring),
       ((Injective T_469) ->
        (~(in_rng_map IV T_469) = true ->
         (~(in_dom_map xy_468 T_469) = true ->
          (~(in_rng_map z_465 T_469) = true ->
           (~z_465 = IV ->
            ((find_seq x'_467 y'_466 (upd_map T_469 xy_468 z_465)) =
             (@None (list (prod bitstring bitstring))) ->
             (find_seq x'_467 y'_466 T_469) =
             (@None (list (prod bitstring bitstring)))))))))))))).
Proof.
(* Note: this is an immediate consequence of find_seq_Inclusion_upd_eq in classical logic;
and probably also in constructive logic, provided we know any option is either None or Some,
and that None <> Some (which implies any option type is either None or not None).
However, the smt solvers have trouble with the surjective_pairing, i.e. matching of xy:block*state
to x:block and y:state, so here is a quick proof in classical logic. *)
intros T xy x' y' z.
intros HB2 HB1 Hndom Hnrng HnIV Hnone.
apply NNPP; intros Hsome.
assert ( find_seq x' y' (upd_map T xy z) = find_seq x' y' T ) as C.
 rewrite <- (surjective_pairing _ _ xy) in *.
 apply find_seq_Inclusion_upd_eq; trivial.
 (* Inclusion T T *)
 clear. unfold Inclusion. tauto.
rewrite Hnone in C. rewrite <- C in Hsome.
tauto.
Qed.

Lemma find_seq_pred_in_T' : 
  (forall (T'_597:(map (prod bitstring bitstring) bitstring)),
   (forall (T_596:(map (prod bitstring bitstring) bitstring)),
    (forall (x'_595:bitstring),
     (forall (y'_594:bitstring),
      (forall (x_593:bitstring),
       (forall (y_592:bitstring),
        ((Inclusion T'_597 T_596) ->
         ((Injective T_596) ->
          (~(in_rng_map IV T_596) = true ->
           ((in_dom_map (pair x'_595 y'_594) T_596) = true ->
            ((get_map T_596 (pair x'_595 y'_594)) = y_592 ->
             (~(find_seq x_593 y_592 T'_597) =
               (@None (list (prod bitstring bitstring))) ->
              (in_dom_map (pair x'_595 y'_594) T'_597) = true)))))))))))).
Proof.
intros T' T x' y' x y.
intros Hsub HB2 HB1 Hdom Hpred Hseq.
apply find_seq_ischained in Hseq.
assert ( exists c, (proj (find_seq x y T')) = Append c (Cons (pair x' y') Nil) ) as Hproj.
 generalize Hseq; clear Hseq.
 generalize (proj (find_seq x y T')) as c'.
 intros. case exists_last with (c := c').
  (* case c' = [] *)
  clear Hsub HB2.
  intros. apply False_ind.
  subst. rewrite ischained_nil in Hseq.
  apply in_dom_in_rng_map in Hdom. rewrite <- Hseq in Hdom; clear Hseq.
  exact (HB1 Hdom).
  (* case c' = al@[a] *)
  clear HB1.
  intro s; destruct s as (al,(a,e)); repeat rewrite e in *; clear e.
  exists al.
  rewrite <- ischained_app in Hseq. destruct Hseq as ((_,Hdoma),Hpreda).
  rewrite ischained_nil in Hpreda.
  unfold Inclusion in Hsub. destruct Hsub as (Hsubdom,Hsubeq).
  duplicate Hdoma as Hdoma'.
  apply Hsubdom in Hdoma; clear Hsubdom.
  apply Hsubeq in Hdoma'; clear Hsubeq.
  rewrite Hdoma' in Hpreda; clear Hdoma'.
  rewrite <- Hpred in Hpreda; clear Hpred.
  unfold Injective in HB2. specialize (HB2 a (pair x' y') Hdoma Hdom Hpreda).
  subst. reflexivity.
clear - Hseq Hproj.
destruct Hproj as (c,Hproj).
rewrite Hproj in Hseq; clear Hproj.
apply ischained_in_dom with (c := (Append c (Cons (pair x' y') Nil))) (z := y); [|exact Hseq].
clear.
apply last_in.
Qed.

Lemma find_seq_helpful_upd : 
  (forall (T_555:(map (prod bitstring bitstring) bitstring)),
   (forall (x_554:bitstring),
    (forall (y_553:bitstring),
     (forall (x'_552:bitstring),
      (forall (y'_551:bitstring),
       (forall (z_550:bitstring),
        ((Injective T_555) ->
         (~(in_rng_map IV T_555) = true ->
          ((find_seq x'_552 y'_551 T_555) =
           (@None (list (prod bitstring bitstring))) ->
           (~(find_seq x'_552 y'_551 (upd_map T_555 (pair x_554 y_553) z_550)) =
             (@None (list (prod bitstring bitstring))) ->
            (in_list
             (pair x_554 y_553) (proj
                                 (find_seq
                                  x'_552 y'_551 (upd_map
                                                 T_555 (pair x_554 y_553) z_550)))) =
            true)))))))))).
Proof.
(* derived by the SMT solvers using:
find_seq_ischained, find_seq_unpad, ischained_helpful_upd, find_seq_complete
Here is small proof for better intuition. *)
intros T x y x' y' z.
intros HB2 HB1 Hnseq Hseq.
assert ( ~( ischained T IV (proj (find_seq x' y' (upd_map T (pair x y) z))) y' = true) ) as Hnch.
 intro C.
 apply find_seq_unpad in Hseq.
 apply find_seq_complete with (x := x') in C; [|exact HB2|exact HB1|exact Hseq]; clear Hseq.
 exact (C Hnseq).
clear Hnseq.
apply find_seq_ischained in Hseq.
eapply ischained_helpful_upd; eauto.
Qed.

Lemma find_seq_useless_upd : 
  (forall (T'_469:(map (prod bitstring bitstring) bitstring)),
   (forall (T_468:(map (prod bitstring bitstring) bitstring)),
    (forall (x_467:bitstring),
     (forall (y_466:bitstring),
      (forall (x'_465:bitstring),
       (forall (y'_464:bitstring),
        ((Inclusion T'_469 T_468) ->
         ((Injective T_468) ->
          (~(in_rng_map IV T_468) = true ->
           (~(find_seq x_467 y_466 T'_469) =
             (@None (list (prod bitstring bitstring))) ->
            ((in_dom_map (pair x_467 y_466) T_468) = true ->
             (find_seq
              x'_465 y'_464 (upd_map
                             T'_469 (pair x_467 y_466) (get_map
                                                        T_468 (pair
                                                               x_467 y_466)))) =
             (find_seq x'_465 y'_464 T'_469)))))))))))).
Proof.
intros T' T x y x' y'.
intros Hsub HB2 HB1 Hseq Hdom.

assert ( Inclusion T' (upd_map T' (pair x y) (get_map T (pair x y))) ) as Hsub'.
 clear - Hsub Hdom.
 apply inclusion_upd; trivial.
assert ( Inclusion (upd_map T' (pair x y) (get_map T (pair x y))) T ) as Hsub''.
 clear - Hsub Hdom.
 apply inclusion_upd'; trivial.
apply inclusion_injective with (T' := (upd_map T' (pair x y) (get_map T (pair x y)))) in HB2; [|exact Hsub''].
apply inclusion_not_rng with (T' := (upd_map T' (pair x y) (get_map T (pair x y)))) in HB1; [|exact Hsub''].

destruct (none_or_notnone _ (find_seq x' y' T')).
 (* case (find_seq x' y' T') <> None *)
 clear - HB1 HB2 n0 Hsub'.
 apply find_seq_Inclusion_eq; assumption.

 (* case (find_seq x' y' T') = None *)
 case (none_or_notnone _ (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y))))) as [Hseq'|e0].
  (* case (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y)))) <> None *)
  apply False_ind.
  clear Hsub Hsub'' Hdom.
  assert ( in_list (pair x y) (proj (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y))))) = true ) as Hin.
   apply find_seq_helpful_upd; try assumption.
   (* Injective T' *)
   apply inclusion_injective with (T' := T') in HB2; [|exact Hsub']. assumption.
   (* in_rng_map IV T' <> true *)
   apply inclusion_not_rng with (T' := T') in HB1; [|exact Hsub']. assumption.
  clear e.
  assert ( find_seq x y (upd_map T' (pair x y) (get_map T (pair x y))) = find_seq x y T' ).
   clear - HB1 HB2 Hseq Hsub'.
   apply find_seq_Inclusion_eq; assumption.
  rewrite <- H in Hseq; clear H.
  clear Hsub'.
  generalize HB1 HB2 Hseq Hseq' Hin; clear HB1 HB2 Hseq Hseq' Hin.
  generalize (upd_map T' (pair x y) (get_map T (pair x y))) as T''.
  clear T; intro T; intros.
  duplicate Hseq as Hpad; rename Hseq into Hch.
  apply find_seq_ischained in Hch.
  apply find_seq_unpad in Hpad.
  duplicate Hseq' as Hpad'; rename Hseq' into Hch'.
  apply find_seq_ischained in Hch'.
  apply find_seq_unpad in Hpad'.
  remember (claim4 T HB1 HB2 (proj (find_seq x y T)) (proj (find_seq x' y' T)) (pair x y) (pair x' y')) as C; clear HeqC.
  repeat rewrite snd_pair in C.
  specialize (C Hch Hpad Hch' Hpad').
  exact (C Hin).
  (* case (find_seq x' y' (upd_map T' (pair x y) (get_map T (pair x y)))) = None *)
  rewrite e, e0. reflexivity.
Qed.

Lemma find_seq_upd_nohelp : 
  (forall (T_545:(map (prod bitstring bitstring) bitstring)),
   (forall (x_544:bitstring),
    (forall (y_543:bitstring),
     (forall (z_542:bitstring),
      (forall (x'_541:bitstring),
       (forall (y'_540:bitstring),
        ((Injective T_545) ->
         (~(in_rng_map IV T_545) = true ->
          (~(in_dom_map (pair x_544 y_543) T_545) = true ->
           (~z_542 = IV ->
            (~(in_rng_map z_542 T_545) = true ->
             (~z_542 = y_543 ->
              (~(exists x0_539:bitstring,
                 (in_dom_map (pair x0_539 z_542) T_545) = true) ->
               ((in_dom_map
                 (pair x'_541 y'_540) (upd_map T_545 (pair x_544 y_543) z_542)) =
                true ->
                (find_seq
                 x'_541 y'_540 (upd_map T_545 (pair x_544 y_543) z_542)) =
                (find_seq x'_541 y'_540 T_545))))))))))))))).
Proof.
intros T x y z x' y'.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom.

destruct (none_or_notnone _ (find_seq x' y' T)).
 (* case (find_seq x' y' T) <> None *)
 clear Hneq Hnex Hdom.
 apply find_seq_Inclusion_upd_eq; trivial.
 unfold Inclusion; auto.

 (* case (find_seq x' y' T) = None *)
 destruct (none_or_notnone _ (find_seq x' y' (upd_map T (pair x y) z))).
  (* case find_seq x' y' (upd_map T (pair x y) z) <> None *)
  clear Hndom HnzIV Hnzrng.
  apply False_ind.
  assert ( in_list (pair x y) (proj (find_seq x' y' (upd_map T (pair x y) z))) = true ) as Hin.
   clear - HB2 HB1 e n0.
   apply find_seq_helpful_upd; assumption.
  clear HB1 HB2 e.
  rename n0 into Hseq.
  apply find_seq_ischained in Hseq.
  generalize Hseq Hin; clear Hin Hseq.
  generalize (proj (find_seq x' y' (upd_map T (pair x y) z))) as c; intros c.
  (* now, this could be written as a lemma: maybe with this lemma the smt solvers would derive _nohelp :-) *)
  generalize IV as Y.
(* induktion ueber c
 wenn c = []
  so ist widerspruch zu Hin
 wenn c = a::al
  dann fallunterscheidung (x y) = a -> dann ist das nächste element entwder nochmal (x,y), aber
                                       das ist wiederspruch zu Hneq; oder es ist etwas anderes als
                                       (x,y) und es hat die form (x0,z) und ist in der dom(T)

                                       wenn kein naechstes element, so ist z = y'. mit Hdom
                                       erhalten wir dann: in_dom( (x',y'), upd(T,(x,y),z) )
                                       und somit in_dom (x',y'), T), denn (x',y') != (x,y);
                                       wäre (x',y') = (x,y), so y' = y aber z = y' also z = y widerspruch;
                                       schliesslich: Hdom wird zu in_dom((x',z),T) widerspruch zu Hnex
                          (x y) != a -> dann können wir irgendwie die induktionshypothese anwenden... *)
  apply list_ind with (l := c).
   (* case c = [] *)
   intros Y _ C. clear - C.
   rewrite in_list_Nil in C. inversion C.
   (* case c = a::al *)
   intros a al IH. intros.
   destruct (eq_prod_dec a (pair x y)) as [e|n].
    (* case a = (x,y) *)
    rewrite e in *. clear e a.
    clear IH Hin.
    destruct_list al as a' al'.
     (* case al = a'::al' *)
(* also erstmal wollen wir
 get_map (upd(T)) (x,y) = snd(a')
dann fallunterscheidung:
 a' = (x,y) (nochmal (x,y)) -->  T[xy] = snd(a') = y = z aber z <> y
 a' <> (x,y) --> wir wissen also: a' in dom(upd(T))
                               get_map (upd(T)) (x,y) = snd(a')
                               also in_dom_map((fst(a'),z),upd(T))
                               da aber a' <> (x',y') wissen wir:
                               in_dom_map((fst(a'),z),T) widerspruch zu Hnex! *)
      rewrite ischained_conscons in Hseq.
      destruct Hseq as ((_,Heq),Hch).
      rewrite get_upd_map_same in Heq.
      destruct (eq_prod_dec a' (pair x y)) as [e|n].
      (* case a' = (x,y) *)
      clear - Hneq Heq e.
      rewrite <- (surjective_pairing _ _ a') in e.
      apply pair_inj in e. destruct e as (_,e).
      rewrite e in Heq; clear e.
      exact (Hneq Heq).
      (* case a' <> (x,y) *)
      clear Hneq Hdom.
      rewrite <- (Append_nil _ (Cons a' al')) in Hch.
      apply ischained_app in Hch.
      destruct Hch as ((_,Hdom'),_).
      rewrite <- (surjective_pairing _ _ a') in Hdom', n.
      rewrite <- Heq in Hdom', n.
      rewrite (upd_map_dom_diff _ _ T (pair x y) (pair (fst_prod a') z) z) in Hdom'; [|auto].
      clear - Hnex Hdom'.
      assert (exists x0, in_dom_map (pair x0 z) T = true); eauto.
     (* case al = [] *)
     rewrite ischained_cons in Hseq.
     destruct Hseq as (_,Heq).
     rewrite get_upd_map_same in Heq.
     destruct (eq_prod_dec (pair x y) (pair x' y')) as [e|n].
      (* case (x,y) = (x',y') *)
      clear - Hneq Heq e.
      rewrite Heq in Hneq; clear Heq.
      apply pair_inj in e. destruct e as (_,e).
      symmetry in e.
      exact (Hneq e).
      (* case (x,y) <> (x',y') *)
      rewrite (upd_map_dom_diff _ _ T (pair x y) (pair x' y') z n) in Hdom.
      rewrite <- Heq in Hdom.
      clear - Hnex Hdom.
      assert (exists x0, in_dom_map (pair x0 z) T = true); eauto.
    (* case a <> (x,y) - here we use the induction hypothesis *)
    rewrite in_list_Cons in Hin. rewrite bool_or_def in Hin. rewrite poly_eq_eq in Hin.
    destruct Hin as [C|Hin].
     (* (x,y) = a *)
     clear - C n. symmetry in C.
     exact (n C).
     (* in_list (x,y) al *)
     clear - IH Hseq Hin.
     rewrite <- (Append_nil _ (Cons a al)) in Hseq.
     apply ischained_app in Hseq.
     destruct Hseq as (_,Hseq).
     eapply IH; eauto.

  (* case find_seq x' y' (upd_map T (pair x y) z) = None *)
  rewrite e, e0. reflexivity.
Qed.


(* lemmas on valid_chain *)
(*************************)

Lemma valid_chain_upd :
  (forall (T:(map (prod bitstring bitstring) bitstring)),
   (forall (xy:(prod bitstring bitstring)),
    (forall (z:bitstring),
     (forall (c:(list (prod bitstring bitstring))),
      (~(in_dom_map xy T) = true ->
       ((valid_chain c T) ->
        (valid_chain c (upd_map T xy z)))))))).
Proof.
(* derived by the SMT solvers using:
ischained_in_dom, ischained_upd *)
intros.
unfold valid_chain in *.
destruct H0 as (z', (H1, H2)); exists z'; trivial.
split; trivial.
apply ischained_upd; trivial.
intros Heq; apply H.
apply ischained_in_dom with (2 := H1); trivial.
Admitted.

Lemma valid_chain_empty : 
  (forall (c_643:(list (prod bitstring bitstring))),
   (forall (xy_642:(prod bitstring bitstring)),
    ~(valid_chain
      (Append c_643 (Cons xy_642 (@Nil (prod bitstring bitstring)))) (
      @empty_map bitstring (prod bitstring bitstring))))).
Proof.
(* derived by the SMT solvers using: ischained_app *)
intros c xy.
intro C.
unfold valid_chain in C. destruct C as (z,(C,_)).
apply ischained_app in C. destruct C as ((_,C),_).
rewrite empty_in_dom_map in C. inversion C.
Qed.

Lemma valid_chain_upd_nohelp :
  (forall (T_559:(map (prod bitstring bitstring) bitstring)),
   (forall (x_558:bitstring),
    (forall (y_557:bitstring),
     (forall (z_556:bitstring),
      (forall (xy'_555:(prod bitstring bitstring)),
       (forall (c_554:(list (prod bitstring bitstring))),
        ((Injective T_559) ->
         (~(in_rng_map IV T_559) = true ->
          (~(in_dom_map (pair x_558 y_557) T_559) = true ->
           (~z_556 = IV ->
            (~(in_rng_map z_556 T_559) = true ->
             (~z_556 = y_557 ->
              (~(exists x0_553:bitstring,
                 (in_dom_map (pair x0_553 z_556) T_559) = true) ->
               ((in_dom_map xy'_555 (upd_map T_559 (pair x_558 y_557) z_556)) =
                true ->
                ((find_seq x_558 y_557 T_559) =
                 (@None (list (prod bitstring bitstring))) ->
                 ((valid_chain
                   (Append
                    c_554 (Cons xy'_555 (@Nil (prod bitstring bitstring)))) (
                   upd_map T_559 (pair x_558 y_557) z_556)) <->
                  (valid_chain
                   (Append
                    c_554 (Cons xy'_555 (@Nil (prod bitstring bitstring)))) T_559))))))))))))))))).
Proof.
intros T x y z xy' c.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom Hnone.

split.

 (* -> *)
 intros Hval.
 assert (Injective (upd_map T (pair x y) z)) as HB2'.
  clear - HB2 Hnzrng.
  apply Injective_upd; assumption.
 assert (in_rng_map IV (upd_map T (pair x y) z) <> true) as HB1'.
  clear - HB1 HnzIV.
  apply IV_not_rng_upd; assumption.
 rewrite <- (surjective_pairing _ _ xy') in Hval, Hdom.
 apply (find_seq_complete_unique_valid_chain (upd_map T (pair x y) z) (fst_prod xy') (snd_prod xy') c HB2' HB1') in Hval.
 clear HB1' HB2'.
 destruct Hval as (Hval,e).
 rewrite <- e; clear e c.
 rewrite find_seq_upd_nohelp; try assumption.
 rewrite find_seq_upd_nohelp in Hval; try assumption.
 case (eq_prod_dec xy' (pair x y)).
  (* xy' = (x,y) *)
  intros. clear - e Hval Hnone.
  apply False_ind.
  rewrite e in *; clear e xy'.
  rewrite fst_pair, snd_pair in Hval.
  exact (Hval Hnone).
  (* (x,y) <> (x',y') *)
  intros. clear - n0 Hval Hdom.
  rewrite (surjective_pairing _ _ xy') in Hdom.
  rewrite upd_map_dom_diff in Hdom; [|auto].
  remember (find_seq_last_in_dom_valid T T (fst_prod xy') (snd_prod xy')); clear Heqv.
  rewrite (surjective_pairing _ _ xy') in v.
  apply v; try assumption.
  unfold Inclusion; auto.

 (* <- *)
 intros HVal.
 apply valid_chain_upd; assumption.
Qed.


Lemma valid_chain_upd_nohelp' : 
  (forall (T_573:(map (prod bitstring bitstring) bitstring)),
   (forall (x_572:bitstring),
    (forall (y_571:bitstring),
     (forall (z_570:bitstring),
      (forall (xy'_569:(prod bitstring bitstring)),
       (forall (c_568:(list (prod bitstring bitstring))),
        ((Injective T_573) ->
         (~(in_rng_map IV T_573) = true ->
          (~(in_dom_map (pair x_572 y_571) T_573) = true ->
           (~z_570 = IV ->
            (~(in_rng_map z_570 T_573) = true ->
             (~z_570 = y_571 ->
              (~(exists x0_567:bitstring,
                 (in_dom_map (pair x0_567 z_570) T_573) = true) ->
               ((in_dom_map xy'_569 T_573) = true ->
                ((valid_chain
                  (Append
                   c_568 (Cons xy'_569 (@Nil (prod bitstring bitstring)))) (
                  upd_map T_573 (pair x_572 y_571) z_570)) <->
                 (valid_chain
                  (Append
                   c_568 (Cons xy'_569 (@Nil (prod bitstring bitstring)))) T_573)))))))))))))))).
Proof.
intros T x y z xy' c.
intros HB2 HB1 Hndom HnzIV Hnzrng Hneq Hnex Hdom.

split.

 (* -> *)
 intros Hval.
 assert (Injective (upd_map T (pair x y) z)) as HB2'.
  clear - HB2 Hnzrng.
  apply Injective_upd; assumption.
 assert (in_rng_map IV (upd_map T (pair x y) z) <> true) as HB1'.
  clear - HB1 HnzIV.
  apply IV_not_rng_upd; assumption.
 assert (in_dom_map xy' (upd_map T (pair x y) z) = true) as Hdom'.
  clear - Hdom.
  remember (in_dom_upd_map1 _ _ T (pair x y) xy' z); clear Heqe.
  tauto.
 rewrite <- (surjective_pairing _ _ xy') in Hval, Hdom'.
 apply (find_seq_complete_unique_valid_chain (upd_map T (pair x y) z) (fst_prod xy') (snd_prod xy') c HB2' HB1') in Hval.
 clear HB1' HB2'.
 destruct Hval as (Hval,e).
 rewrite <- e; clear e c.
 rewrite find_seq_upd_nohelp; try assumption.
 rewrite find_seq_upd_nohelp in Hval; try assumption.
 clear - Hval Hdom.
 remember (find_seq_last_in_dom_valid T T (fst_prod xy') (snd_prod xy')); clear Heqv.
 rewrite (surjective_pairing _ _ xy') in v.
 apply v; try assumption.
 unfold Inclusion; auto.

 (* <- *)
 intros HVal.
 apply valid_chain_upd; assumption.
Qed.


(* lemmas on set_bad4 *)
(**********************)

Lemma set_bad4_def' :
  (forall (z_623:bitstring),
   (forall (T'_622:(map (prod bitstring bitstring) bitstring)),
    (forall (T_621:(map (prod bitstring bitstring) bitstring)),
     (forall (invT_620:(map bitstring (prod bitstring bitstring))),
      ((set_bad4 z_623 T'_622 T_621 invT_620) = true <->
       ((in_dom_map z_623 invT_620) = true /\
       ~(in_dom_map (get_map invT_620 z_623) T'_622) = true) /\
       (forall (c_619:(list (prod bitstring bitstring))),
        ~(valid_chain
          (Append
           c_619 (Cons
                  (get_map invT_620 z_623) (@Nil (prod bitstring bitstring)))) T_621))))))).
Proof.
(* derived by the SMT solvers using: set_bad4_def *)
Admitted.

Lemma set_bad4_eq :
  (forall (z_655:bitstring),
   (forall (T1'_654:(map (prod bitstring bitstring) bitstring)),
    (forall (T1_653:(map (prod bitstring bitstring) bitstring)),
     (forall (invT1_652:(map bitstring (prod bitstring bitstring))),
      (forall (T2'_651:(map (prod bitstring bitstring) bitstring)),
       (forall (T2_650:(map (prod bitstring bitstring) bitstring)),
        (forall (invT2_649:(map bitstring (prod bitstring bitstring))),
         ((((set_bad4 z_655 T1'_654 T1_653 invT1_652) = true <->
            (set_bad4 z_655 T2'_651 T2_650 invT2_649) = true)) ->
          (set_bad4 z_655 T1'_654 T1_653 invT1_652) =
          (set_bad4 z_655 T2'_651 T2_650 invT2_649))))))))).
(*
 forall z T1' T1 invT1 T2' T2 invT2, ((set_bad4 z T1' T1 invT1) = true <-> (set_bad4 z T2' T2 invT2) = true)
                                  -> (set_bad4 z T1' T1 invT1 = set_bad4 z T2' T2 invT2).
*)
Proof.
intros z T1' T1 invT1 T2' T2 invT2 H.
case (eq_bool (set_bad4 z T1' T1 invT1)).
 (* set_bad4 ... = true *)
 intros. rewrite e. apply H in e. rewrite e. reflexivity.
 (* set_bad4 ... = false *)
 intros. rewrite e in *; clear e.
 case (eq_bool (set_bad4 z T2' T2 invT2)).
  (* set_bad4 ... = true *)
  intros. apply False_ind.
  rewrite e in H; clear e. intuition.
  (* set_bad4 ... = false *)
  clear. intros. rewrite e. reflexivity.
Qed.

Lemma set_bad4_upd : 
  (forall (T'_643:(map (prod bitstring bitstring) bitstring)),
   (forall (T_642:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_641:(map bitstring (prod bitstring bitstring))),
     (forall (x_640:bitstring),
      (forall (y_639:bitstring),
       (forall (y0_638:bitstring),
        (forall (z_637:bitstring),
         ((Inclusion T'_643 T_642) ->
          ((Injective T_642) ->
           ((Inverse T_642 invT_641) ->
            (~(in_rng_map IV T_642) = true ->
             (~(in_dom_map (pair x_640 y_639) T_642) = true ->
              (~(in_rng_map z_637 T_642) = true ->
               (~z_637 = IV ->
                (~(find_seq x_640 y_639 T'_643) =
                  (@None (list (prod bitstring bitstring))) ->
                 (set_bad4
                  y0_638 (upd_map T'_643 (pair x_640 y_639) z_637) (upd_map
                                                                    T_642 (
                                                                    pair
                                                                    x_640 y_639) z_637) (
                  upd_map invT_641 z_637 (pair x_640 y_639))) =
                 (set_bad4 y0_638 T'_643 T_642 invT_641)))))))))))))))).
Proof.
intros T' T invT x y y0 z.
intros Hsub HB2 Hinv HB1 Hndom Hnzrng HnzIV Hseq'.
apply set_bad4_eq.

(* TODO: instead of using eq_bstr_dec, we may "split" first and in each case
asserting that y0 <> z. to show the contradiction, just use intro e. and then
the respective proofs are just as below *)
case ( eq_bstr_dec y0 z ).

 (* case y0 = z *)
(* y0 = z is a contradiction in all cases:
for ->, we know that !in_dom( (upd(invT,z,(x,y)))[z], upd(T',(x,y),z)), i.e. !in_dom( (x,y), upd(T',(x,y),z)) contradiction
for <-, we know that in_dom(z, invT), but at the same time we have the premises !in_rng(z, T) and Inverse T invT
 *)
 intros. rewrite e; clear e y0.
 repeat rewrite set_bad4_def'.
 split.
  (* -> *) (* we only need Hbad *)
  intros Hbad. clear - Hbad. apply False_ind.
  destruct Hbad as ((_,C),_).
  rewrite get_upd_map_same in C.
  rewrite upd_map_dom_same in C.
  auto.

  (* <- *) (* we need Hinv Hnzrng Hbad *)
  intros Hbad. clear - Hinv Hnzrng Hbad. destruct Hbad as ((Hdom,_),_).
  apply False_ind.
  apply Inverse_dom_rng with (z := z) in Hinv; try assumption.
  exact (Hnzrng Hinv).

 (* case y0 <> z *)
(*
if y0 <> z, the equality of set_bad4 works out:
for ->, if y0 was not in the range updated T, then it also was not in the range of T;
         and if there is no valid_chain in the updated T, there is none in T either
for <-, the idea is that since y0 <> z we know find_seq x y (upd(T,(x,y),z)) <> none,
        then the update cannot have completed another chain, because from claim4 we know
        that in well-formed T, no end of a chain occurs in another one. and since we
        know y0 <> z, we also know invT[y0] <> pair x y, so we are indeed talking about
        another chain (i.e., with another end element) here.
*)
 intros n0. split.

 (* -> *) (* we need Hndom and n0 *)
 clear - Hndom n0. intros Hbad.
 rewrite set_bad4_def' in *.
 destruct Hbad as ((Hrng,Hndom'),Hnval).
 rewrite upd_map_dom_diff in Hrng; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff in Hndom'; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff in Hnval; [|auto]. (* n0 is used here *)
 repeat split.
  (* y0 in dom(invT) *)
  clear - Hrng. assumption.
  (* invT[y0] in dom(T') *)
  clear - Hndom'. intro C.
  remember (in_dom_upd_map1 _ _ T' (pair x y) (get_map invT y0) z); clear Heqe.
  tauto.  
  (* forall c, ~valid_chain(c++invT[y0], T) *)
  intros c Hval.
  specialize (Hnval c).
  apply valid_chain_upd with (xy := pair x y) (z := z) in Hval; try assumption.
  exact (Hnval Hval).

 (* <- *) (* we need ALL premises! *)
 intros Hbad.
 rewrite set_bad4_def' in *.
 destruct Hbad as ((Hrng,Hndom'),Hnval).
 rewrite upd_map_dom_diff; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff; [|auto]. (* n0 is used here *)
 assert ( get_map invT y0 <> pair x y ) as n1.
  clear - Hinv Hrng Hndom.
  intro. rewrite <- H in Hndom.
  unfold Inverse in Hinv. destruct Hinv as (_,Hinv2).
  specialize (Hinv2 y0 Hrng).
  tauto.
 repeat split.
  (* y0 in dom(invT) *)
  clear - Hrng. assumption.
  (* invT[y0] in dom(T') *)
  clear - Hndom' n1. intro C.
  rewrite upd_map_dom_diff in C; [|auto]. (* n1 is used here *)
  exact (Hndom' C).
  (* forall c, ~valid_chain(c++invT[y0], T) *)
  intros c' Hval. clear - Hsub HB1 HB2 HnzIV Hnzrng Hndom n1 Hseq' Hval Hnval.
  specialize (Hnval c').
  assert (find_seq x y (upd_map T (pair x y) z) <> None) as Hseq.
   rewrite find_seq_Inclusion_upd_eq with (T' := T'); assumption.
  assert (Injective (upd_map T (pair x y) z)) as HB2'; [|clear HB2; rename HB2' into HB2].
   clear - HB2 Hnzrng.
   apply Injective_upd; assumption.
  assert (in_rng_map IV (upd_map T (pair x y) z) <> true) as HB1'; [|clear HB1; rename HB1' into HB1].
   clear - HB1 HnzIV.
   apply IV_not_rng_upd; assumption.
  clear Hsub Hseq' HnzIV Hnzrng Hndom T'.
  assert ( in_list (pair x y) (Append c' (Cons (get_map invT y0) Nil)) = true ) as Hin.
   clear - Hval Hnval.
   unfold valid_chain in *.
   (* this is nice... not so easy to deal with a negated conjunction in Coq ;-) *)
   destruct Hval as (z0,(Hch,Hpad)).
   assert ( ischained T IV (Append c' (Cons (get_map invT y0) Nil)) z0 <> true ) as Hnch.
    intros C.
    destruct Hnval. exists z0.
    split; assumption.
   clear - Hch Hnch.
   eapply ischained_helpful_upd; eauto.
  clear Hnval.
  duplicate Hseq as Hpad; rename Hseq into Hch.
  apply find_seq_ischained in Hch. apply find_seq_unpad in Hpad.
  unfold valid_chain in Hval.
  destruct Hval as (z0,(Hch',Hpad')).
  generalize HB1 HB2 Hch Hpad Hch' Hpad' Hin n1; clear HB1 HB2 Hch Hpad Hch' Hpad' Hin n1.
  generalize (proj (find_seq x y (upd_map T (pair x y) z))) as c.
  generalize (upd_map T (pair x y) z) as T'; clear T.
  generalize (get_map invT y0) as xy'.
  clear. intros xy' T c. intros. (* now we are almost ready to apply claim4 *)
  apply ischained_app in Hch'. destruct Hch' as ((Hch',_),_); clear z0.
  rewrite <- (snd_pair _ _ x y) in Hch.
  remember (claim4 T HB1 HB2 c c' (pair x y) xy' Hch Hpad Hch' Hpad') as n2; clear Heqn2.
  clear - Hin n1 n2.
  rewrite in_list_Append in Hin. rewrite in_list_Cons in Hin. rewrite in_list_Nil in Hin.
  repeat rewrite bool_or_def in Hin. rewrite poly_eq_eq in Hin.
  intuition.
Qed.

Lemma set_bad4_upd' : 
  (forall (T'_671:(map (prod bitstring bitstring) bitstring)),
   (forall (T_670:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_669:(map bitstring (prod bitstring bitstring))),
     (forall (x_668:bitstring),
      (forall (y_667:bitstring),
       (forall (y0_666:bitstring),
        (forall (z_665:bitstring),
         ((Inclusion T'_671 T_670) ->
          ((Injective T_670) ->
           ((Inverse T_670 invT_669) ->
            (~(in_rng_map IV T_670) = true ->
             (~(in_dom_map (pair x_668 y_667) T_670) = true ->
              (~(in_rng_map z_665 T_670) = true ->
               (~z_665 = IV ->
                (~z_665 = y_667 ->
                 (~(exists x0_664:bitstring,
                    (in_dom_map (pair x0_664 z_665) T_670) = true) ->
                  (set_bad4
                   y0_666 (upd_map T'_671 (pair x_668 y_667) z_665) (
                   upd_map T_670 (pair x_668 y_667) z_665) (upd_map
                                                            invT_669 z_665 (
                                                            pair x_668 y_667))) =
                  (set_bad4 y0_666 T'_671 T_670 invT_669))))))))))))))))).
Proof.
intros T' T invT x y y0 z.
intros Hsub HB2 Hinv HB1 Hndom Hnzrng HnzIV Hneq Hnex.
apply set_bad4_eq.

(* TODO: instead of using eq_bstr_dec, we may "split" first and in each case
asserting that y0 <> z. to show the contradiction, just use intro e. and then
the respective proofs are just as below *)
case ( eq_bstr_dec y0 z ).

 (* case y0 = z *)
(* y0 = z is a contradiction in all cases:
for ->, we know that !in_dom( (upd(invT,z,(x,y)))[z], upd(T',(x,y),z)), i.e. !in_dom( (x,y), upd(T',(x,y),z)) contradiction
for <-, we know that in_dom(z, invT), but at the same time we have the premises !in_rng(z, T) and Inverse T invT
 *)
 intros. rewrite e; clear e y0.
 repeat rewrite set_bad4_def'.
 split.
  (* -> *) (* we only need Hbad *)
  intros Hbad. clear - Hbad. apply False_ind.
  destruct Hbad as ((_,C),_).
  rewrite get_upd_map_same in C.
  rewrite upd_map_dom_same in C.
  auto.

  (* <- *) (* we need Hinv Hnzrng Hbad *)
  intros Hbad. clear - Hinv Hnzrng Hbad. destruct Hbad as ((Hdom,_),_).
  apply False_ind.
  apply Inverse_dom_rng with (z := z) in Hinv; try assumption.
  exact (Hnzrng Hinv).

 (* case y0 <> z *)
(*
if y0 <> z, the equality of set_bad4 works out:
for ->, if y0 was not in the range updated T, then it also was not in the range of T;
         and if there is no valid_chain in the updated T, there is none in T either
for <-, if there is no valid chain in upd(T), there cannot have been a valid chain in T because,
         similarly as in find_seq_upd_nohelp, the update was "no help".
*)
 intros n0. split.

 (* -> *) (* we need Hndom and n0 *)
 clear - Hndom n0. intros Hbad.
 rewrite set_bad4_def' in *.
 destruct Hbad as ((Hrng,Hndom'),Hnval).
 rewrite upd_map_dom_diff in Hrng; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff in Hndom'; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff in Hnval; [|auto]. (* n0 is used here *)
 repeat split.
  (* y0 in dom(invT) *)
  clear - Hrng. assumption.
  (* invT[y0] in dom(T') *)
  clear - Hndom'. intro C.
  remember (in_dom_upd_map1 _ _ T' (pair x y) (get_map invT y0) z); clear Heqe.
  tauto.  
  (* forall c, ~valid_chain(c++invT[y0], T) *)
  intros c Hval.
  specialize (Hnval c).
  apply valid_chain_upd with (xy := pair x y) (z := z) in Hval; try assumption.
  exact (Hnval Hval).

 (* <- *) (* we need ALL premises! *)
 intros Hbad.
 rewrite set_bad4_def' in *.
 destruct Hbad as ((Hrng,Hndom'),Hnval).
 rewrite upd_map_dom_diff; [|auto]. (* n0 is used here *)
 rewrite get_upd_map_diff; [|auto]. (* n0 is used here *)
 assert ( get_map invT y0 <> pair x y ) as n1.
  clear - Hinv Hrng Hndom.
  intro. rewrite <- H in Hndom.
  unfold Inverse in Hinv. destruct Hinv as (_,Hinv2).
  specialize (Hinv2 y0 Hrng).
  tauto.
 repeat split.
  (* y0 in dom(invT) *)
  clear - Hrng. assumption.
  (* invT[y0] in dom(T') *)
  clear - Hndom' n1. intro C.
  rewrite upd_map_dom_diff in C; [|auto]. (* n1 is used here *)
  exact (Hndom' C).
  (* forall c, ~valid_chain(c++invT[y0], T) *)
  intros c Hval.
  clear - Hsub HB1 HB2 HnzIV Hnzrng Hndom Hnex Hneq Hval Hnval n1.
  specialize (Hnval c).
  assert (Injective (upd_map T (pair x y) z)) as HB2'; [|clear HB2; rename HB2' into HB2].
   clear - HB2 Hnzrng.
   apply Injective_upd; assumption.
  assert (in_rng_map IV (upd_map T (pair x y) z) <> true) as HB1'; [|clear HB1; rename HB1' into HB1].
   clear - HB1 HnzIV.
   apply IV_not_rng_upd; assumption.
  clear Hsub HnzIV Hnzrng Hndom T'.
  assert ( in_list (pair x y) (Append c (Cons (get_map invT y0) Nil)) = true ) as Hin.
   clear - Hval Hnval.
   unfold valid_chain in *.
   (* this is nice... not so easy to deal with a negated conjunction in Coq ;-) *)
   destruct Hval as (z0,(Hch,Hpad)).
   assert ( ischained T IV (Append c (Cons (get_map invT y0) Nil)) z0 <> true ) as Hnch.
    intros C.
    destruct Hnval. exists z0.
    split; assumption.
   clear - Hch Hnch.
   eapply ischained_helpful_upd; eauto.
  clear Hnval.
  assert ( in_list (pair x y) c = true) as Hin'; [|clear Hin; rename Hin' into Hin].
   clear - Hin n1.
   rewrite in_list_Append in Hin. rewrite in_list_Cons in Hin. rewrite in_list_Nil in Hin.
   repeat rewrite bool_or_def in Hin. rewrite poly_eq_eq in Hin.
   intuition.
  clear HB1 HB2 n1.
  apply in_split in Hin.
  destruct Hin as (al,(bl,e)). move al after z. move bl after z.
  rewrite e in *; clear e c.
  destruct_list bl as b' bl'.
   (* case bl = b'::bl' *)
   unfold valid_chain in Hval. destruct Hval as (z0,(Hch,_)).
   rewrite append_assoc in Hch. repeat rewrite Append_Cons in Hch.
   apply ischained_app in Hch. destruct Hch as (_,Hch).
   rewrite get_upd_map_same in Hch.
   destruct_list bl' as b'' bl''.
    (* case bl' = b''::bl'' *)
    rewrite Append_Cons in Hch. rewrite ischained_conscons in Hch. destruct Hch as (((Hdom,Heq),_),_).
    destruct (eq_prod_dec b' (pair x y)) as [e|n].
     (* b' = (x,y) *)
     clear - Hneq Heq e. rewrite e in *; clear e b'.
     rewrite snd_pair in Heq. exact (Hneq Heq).
     (* b' <> (x,y) *)
     clear - Hnex Hdom Heq n. rewrite upd_map_dom_diff in Hdom; [clear n|auto].
     destruct Hnex. exists (fst_prod b').
     rewrite Heq. rewrite surjective_pairing. assumption.
    (* case bl' = [] *)
    rewrite Append_nil in Hch. rewrite ischained_conscons in Hch. destruct Hch as (((Hdom,Heq),_),_).
    destruct (eq_prod_dec b' (pair x y)) as [e|n].
     (* b' = (x,y) *)
     clear - Hneq Heq e. rewrite e in *; clear e b'.
     rewrite snd_pair in Heq. exact (Hneq Heq).
     (* b' <> (x,y) *)
     clear - Hnex Hdom Heq n. rewrite upd_map_dom_diff in Hdom; [clear n|auto].
     destruct Hnex. exists (fst_prod b').
     rewrite Heq. rewrite surjective_pairing. assumption.
   (* case bl = [] *)
   unfold valid_chain in Hval. destruct Hval as (z0,(Hch,_)).
   rewrite append_assoc in Hch. rewrite Append_Cons in Hch.
   rewrite Append_nil in Hch. apply ischained_app in Hch. destruct Hch as (_,Hch).
   rewrite get_upd_map_same in Hch.
   rewrite ischained_cons in Hch. destruct Hch as ((Hdom,Heq),_).
    destruct (eq_prod_dec (get_map invT y0) (pair x y)) as [e|n].
     (* invT[y0] = (x,y) *)
     clear - Hneq Heq e. rewrite e in *; clear e y0 invT.
     rewrite snd_pair in Heq. exact (Hneq Heq).
     (* b' <> (x,y) *)
     clear - Hnex Hdom Heq n. rewrite upd_map_dom_diff in Hdom; [clear n|auto].
     destruct Hnex. exists (fst_prod (get_map invT y0)).
     rewrite Heq. rewrite surjective_pairing. assumption.
Qed.

Lemma set_bad4_upd_I : 
  (forall (T_693:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_692:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_691:(map bitstring (prod bitstring bitstring))),
     (forall (x_690:bitstring),
      (forall (y_689:bitstring),
       (forall (z_688:bitstring),
        (forall (I_687:(map Z (prod bitstring bool))),
         (forall (i_686:Z),
          (forall (icount_685:Z),
           ((Injective T_693) ->
            (~(in_rng_map IV T_693) = true ->
             (~z_688 = IV ->
              (~(in_rng_map z_688 T_693) = true ->
               ((forall (i_684:Z),
                 ((in_dom_map i_684 I_687) = true ->
                  ~z_688 = (fst_prod (get_map I_687 i_684)))) ->
                ((forall (i_682:Z),
                  ((in_dom_map i_682 I_687) = true ->
                   ((set_bad4
                     (fst_prod (get_map I_687 i_682)) T'_692 T_693 invT_691) =
                    true <-> (snd_prod (get_map I_687 i_682)) = true))) ->
                 (~(in_dom_map (pair x_690 y_689) T_693) = true ->
                  ((in_dom_map
                    i_686 (upd_map I_687 icount_685 (pair z_688 false))) =
                   true ->
                   (~(find_seq x_690 y_689 T_693) =
                     (@None (list (prod bitstring bitstring))) ->
                    ((set_bad4
                      (fst_prod
                       (get_map
                        (upd_map I_687 icount_685 (pair z_688 false)) i_686)) T'_692 (
                      upd_map T_693 (pair x_690 y_689) z_688) (upd_map
                                                               invT_691 z_688 (
                                                               pair
                                                               x_690 y_689))) =
                     true ->
                     (snd_prod
                      (get_map
                       (upd_map I_687 icount_685 (pair z_688 false)) i_686)) =
                     true))))))))))))))))))).
Proof.
intros T T' invT x y z I i icount.
intros.
rewrite set_bad4_def in H8.
destruct H8.
destruct H8.
rewrite in_dom_upd_map_I in H6.
destruct H6.
 rewrite <- H6 in *.
 rewrite get_upd_map_same in H9.
 rewrite fst_pair in H9.
 rewrite get_upd_map_same in H9.
 assert (False).
   apply H9.
   exists (proj(find_seq x y (upd_map T (pair x y) z))).
   apply find_seq_last_in_dom_valid.
   unfold Inclusion.
   apply conj.
    intros; trivial.
    intros; trivial.
   intro.
   apply H7.
   apply (find_seq_upd' T (pair x y) x y z).
   trivial.
   trivial.
   trivial.
   trivial.
   trivial.
   trivial.
   apply in_dom_upd_map1.
   left; trivial.
 intuition.
 
 destruct H6.
 rewrite (get_upd_map_diff _ _ _ _ _ _ H6).
 rewrite <- (H4 _ H11).
 rewrite (get_upd_map_diff _ _ _ _ _ _ H6) in H8.
 rewrite (get_upd_map_diff _ _ _ _ _ _ H6) in H10.
 rewrite (get_upd_map_diff _ _ _ _ _ _ H6) in H9.
 apply H3 in H11.
 rewrite set_bad4_def.
 apply conj.
 apply conj.
  apply in_dom_upd_map2 in H8.
  destruct H8.   
   intuition.
   trivial.

  rewrite (get_upd_map_diff _ _ _ _ _ _ H11) in H10.
  trivial.

  rewrite (get_upd_map_diff _ _ _ _ _ _ H11) in H9.
  intro.
  apply H9.
  destruct H12.
  exists x0.
  apply valid_chain_upd.
   trivial.
   trivial.
Qed.


(* lemmas on Claim5 *)
(********************)

Lemma ischained_last_in_dom_Claim5 :
  (forall (T_727:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_726:(map (prod bitstring bitstring) bitstring)),
    (forall (c_725:(list (prod bitstring bitstring))),
     (forall (xy_724:(prod bitstring bitstring)),
      (forall (xy'_723:(prod bitstring bitstring)),
       ((Inclusion T'_726 T_727) ->
        ((Injective T_727) ->
         (~(in_rng_map IV T_727) = true ->
          ((ischained
            T_727 IV (Append
                      c_725 (Cons xy'_723 (@Nil (prod bitstring bitstring)))) (
            snd_prod xy_724)) =
           true ->
           (~(unpad
              (mapfst
               (Append
                c_725 (Cons
                       xy'_723 (Cons xy_724 (@Nil (prod bitstring bitstring))))))) =
             (@None (list bool)) ->
            ((in_dom_map xy'_723 T'_726) = true ->
             ((Claim5 T'_726 T_727) ->
              (ischained
               T'_726 IV (Append
                          c_725 (Cons
                                 xy'_723 (@Nil (prod bitstring bitstring)))) (
               snd_prod xy_724)) =
              true)))))))))))).
Proof.
intros T T' c xy xy'.
intros Hsub HB2 HB1 Hch Hpad Hdom Hord.

(* We cannot induct over the premises Hch and Hpad, because the induction premises would be unfulfillable.
We have to replace Hpad with a more suited premise, which tells us exactly what we need and which is suitable
for induction at the same time. We will call it Hnone and use it instead of Hpad. *)
assert ( forall x0 y0, in_list (pair x0 y0) c = true -> find_seq x0 y0 T = None ) as Hnone.
 clear - HB1 HB2 Hch Hpad.
 intros x0 y0 Hin.
 apply NNPP; intro Hch'.
 duplicate Hch' as Hpad'.
 apply find_seq_ischained in Hch'.
 apply find_seq_unpad in Hpad'.
 generalize Hch' Hpad'; clear Hch' Hpad'.
 generalize (proj (find_seq x0 y0 T)) as c'. intros.
 remember (claim4 T HB1 HB2 c' (Append c (Cons xy' Nil)) (pair x0 y0) xy) as C; clear HeqC.
 clear HB2 HB1.
 rewrite snd_pair in C.
 specialize (C Hch' Hpad'); clear Hch' Hpad'.
 rewrite append_assoc in C. rewrite Append_Cons in C. rewrite Append_nil in C.
 specialize (C Hch Hpad); clear - Hin C.
 rewrite in_list_Append in C. rewrite bool_or_def in C.
 apply C. left; assumption.
clear Hpad.

generalize Hch Hnone; clear Hch Hnone.
generalize IV as Y.
apply list_ind with (l := c).
 (* case c = [] *)
 intros. clear - Hsub Hdom Hch. rewrite Append_nil in *.
 rewrite ischained_cons in *.
 destruct Hch as ((_,Heq),Heq').
 repeat split; try assumption.
 unfold Inclusion in Hsub. destruct Hsub as (_,Hsub).
 specialize (Hsub xy' Hdom).
 rewrite <- Hsub in Heq'. assumption.
 (* case c = a::al *)
 clear Hdom HB1 HB2.
 intros a al. intros IH. intros.
(* first we solve the premises for IH. this will give us the chainedness of al in T',
which we can use to fulfill the premises of Claim5 (in particular in_dom(hd(al)) if al is not Nil *)
 destruct_list al as a' al'.
  (* case al = a'::al' *)
  repeat rewrite Append_Cons in *. rewrite ischained_conscons in Hch.
  destruct Hch as (((Hdom,HeqY),HeqTa),Hch).
  specialize (IH (snd_prod a') Hch); clear Hch.
  assert ( forall x0 y0, in_list (pair x0 y0) (Cons a' al') = true -> find_seq x0 y0 T = None ) as Hall.
   clear - Hnone.
   intros. apply Hnone. clear - H.
   rewrite in_list_Cons. rewrite bool_or_def. right.
   assumption.
  specialize (IH Hall); clear Hall.
  (* now the premises for the IH are solved, we want to use Claim5 *)
  unfold Claim5 in Hord.
  specialize (Hord (fst_prod a) (snd_prod a) (fst_prod a') (snd_prod a')).
  repeat rewrite surjective_pairing in Hord.
  specialize (Hord Hdom HeqTa); clear Hdom.
  assert ( in_dom_map a' T' = true ) as Hdom.
   clear - IH.
   rewrite <- (Append_nil _ (Cons a' (Append al' (Cons xy' Nil)))) in IH.
   apply ischained_app in IH. destruct IH as ((_,Hdom),_). assumption.
  specialize (Hord Hdom); clear Hdom.
  specialize (Hnone (fst_prod a) (snd_prod a)).
  rewrite surjective_pairing in Hnone.
  rewrite in_list_Cons in Hnone. rewrite bool_or_def in Hnone. rewrite poly_eq_eq in Hnone.
  intuition.
  (* the rest is easy *)
  rename H into Hdom; clear - Hsub IH Hdom HeqTa HeqY.
  unfold Inclusion in Hsub. destruct Hsub as (_,Hsub).
  specialize (Hsub a Hdom). rewrite <- Hsub in HeqTa; clear Hsub.
  rewrite ischained_conscons.
  repeat split; assumption.
  (* case al = [] *)
  rewrite Append_nil in *. rewrite Append_Cons in *. rewrite Append_nil in *. rewrite ischained_conscons in Hch.
  destruct Hch as (((Hdom,HeqY),HeqTa),Hch).
  specialize (IH (snd_prod xy') Hch); clear Hch.
  assert ( forall x0 y0, in_list (pair x0 y0) Nil = true -> find_seq x0 y0 T = None ) as Hall.
   clear. intros. apply False_ind.
   rewrite in_list_Nil in H.
   inversion H.
  specialize (IH Hall); clear Hall.
  (* now the premises for the IH are solved, we want to use Claim5 *)
  unfold Claim5 in Hord.
  specialize (Hord (fst_prod a) (snd_prod a) (fst_prod xy') (snd_prod xy')).
  repeat rewrite surjective_pairing in Hord.
  specialize (Hord Hdom HeqTa); clear Hdom.
  assert ( in_dom_map xy' T' = true ) as Hdom.
   clear - IH.
   rewrite ischained_cons in IH. destruct IH as ((Hdom,_),_). assumption.
  specialize (Hord Hdom); clear Hdom.
  specialize (Hnone (fst_prod a) (snd_prod a)).
  rewrite surjective_pairing in Hnone.
  rewrite in_list_Cons in Hnone. rewrite bool_or_def in Hnone. rewrite poly_eq_eq in Hnone.
  intuition.
  (* the rest is easy *)
  rename H into Hdom; clear - Hsub IH Hdom HeqTa HeqY.
  unfold Inclusion in Hsub. destruct Hsub as (_,Hsub).
  specialize (Hsub a Hdom). rewrite <- Hsub in HeqTa; clear Hsub.
  rewrite ischained_conscons.
  repeat split; assumption.
Qed.

Lemma find_seq_set_bad4_Claim5 : 
  (forall (T_727:(map (prod bitstring bitstring) bitstring)),
   (forall (T'_726:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_725:(map bitstring (prod bitstring bitstring))),
     (forall (x_724:bitstring),
      (forall (y_723:bitstring),
       ((Inclusion T'_726 T_727) ->
        ((Inverse T_727 invT_725) ->
         ((Injective T_727) ->
          (~(in_rng_map IV T_727) = true ->
           (~(set_bad4 y_723 T'_726 T_727 invT_725) = true ->
            ((Claim5 T'_726 T_727) ->
             (~(find_seq x_724 y_723 T_727) =
               (@None (list (prod bitstring bitstring))) ->
              ~(find_seq x_724 y_723 T'_726) =
               (@None (list (prod bitstring bitstring))))))))))))))).
Proof.
intros T T' invT x y.
intros Hsub Hinv HB2 HB1 Hnbad Hord Hseq.
intro C.

rewrite set_bad4_def' in Hnbad.
apply Hnbad; clear Hnbad.
(* we have  ~
          ((in_dom_map y invT = true /\
            in_dom_map (get_map invT y) T' <> true) /\
           (forall c_619 : list (prod bitstring bitstring),
            ~ valid_chain (Append c_619 (Cons (get_map invT y) Nil)) T))

1. if ~ (in_dom_map y invT = true) -> this is a contradiction to Hseq! y has to be in rng(T)

2. if in_dom invT[y] T' = true -> we have to use Claim5 and maybe reason inductively. all elements of the chain have
                               to be in T', so we can conclude find_seq x y T' <> None

3. if ex c, valid_chain c++invT[y] T -> this is a contradiction to find_seq x y T <> None which tells us
                                 valid_chain (proj find_seq x y T)++(x,y) T,
                                 i.e. valid_chain c'++invT[y]::(x,y), so contradiction to prefix-freeness
*)
repeat split.

 (* 1. we show in_dom y invT = true *)
 clear - HB1 HB2 Hsub Hinv Hseq C. (* don't need Hord here *)
 apply Inverse_rng_dom with (T := T); [assumption|clear Hinv].
 duplicate Hseq as Hpad; rename Hseq into Hch.
 apply find_seq_ischained in Hch.   
 apply find_seq_unpad in Hpad.
 generalize Hch Hpad; clear Hch Hpad.
 generalize (proj (find_seq x y T)) as c. intros.
 case exists_last with (c := c).
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch Hpad C.
  intro e. rewrite e in *; clear e c.
  apply False_ind.
  apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
  apply inclusion_injective with (T' := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch. rewrite <- ischained_nil in Hch. (* this replaces T with an existential variable *)
  instantiate (1:=T') in Hch.
  remember (find_seq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *)
  clear - Hch.
  intro e. destruct e as (c',(xy',e)).
  rewrite e in Hch; clear e c.  
  apply ischained_app in Hch. destruct Hch as ((_,Hdom),Heq).
  rewrite ischained_nil in Heq.
  apply in_dom_in_rng_map in Hdom.
  rewrite Heq in Hdom. assumption.

 (* 2. here we have the assumption invT[y] in dom(T'). we can therefore use Claim5 to show that
       find_seq x y T' <> None, yielding a contradiction to C. *)
 intros Hdom.
 duplicate Hseq as Hpad; rename Hseq into Hch.
 apply find_seq_ischained in Hch.
 apply find_seq_unpad in Hpad.
 generalize Hch Hpad; clear Hch Hpad.
 generalize (proj (find_seq x y T)) as c. intros.
 case exists_last with (c := c).
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch Hpad C.
  intro e. rewrite e in *; clear e c.
  apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
  apply inclusion_injective with (T' := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch. rewrite <- ischained_nil in Hch. (* this replaces T with an existential variable *)
  instantiate (1:=T') in Hch.
  remember (find_seq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *) (* all premises are needed here *)
  intro e. destruct e as (c',(xy',e)).
  rewrite e in Hch, Hpad; clear e c.  
  assert ( get_map invT y = xy' ) as e.
   clear - Hinv Hch.
   apply ischained_app in Hch. destruct Hch as ((_,Hdom),Heq).
   rewrite ischained_nil in Heq.
   unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv xy' Hdom). destruct Hinv as (_,Heq').
   rewrite Heq in Heq'. assumption.
  rewrite e in *; clear e.
  clear Hinv invT.
  rewrite append_assoc in Hpad. rewrite Append_Cons in Hpad. rewrite Append_nil in Hpad.
  rewrite <- (snd_pair _ _ x y) in Hch.
  remember (ischained_last_in_dom_Claim5 T T' c' (pair x y) xy' Hsub HB2 HB1 Hch Hpad Hdom Hord) as Hch'; clear - Hsub HB1 HB2 Hch' Hpad C.
  rewrite (snd_pair _ _ x y) in Hch'.
  apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
  apply inclusion_injective with (T' := T') in HB2; [|assumption].
  remember (find_seq_complete T' x y (Append c' (Cons xy' Nil)) HB2 HB1) as Hseq; clear - Hseq Hpad Hch' C.
  rewrite append_assoc in Hseq. rewrite Append_Cons in Hseq. rewrite Append_nil in Hseq.
  specialize (Hseq Hch' Hpad); clear - Hseq C.
  exact (Hseq C).

 (* 3. with Hseq and Hval we obtain a contradiction to prefix-freeness. *)
 clear - Hinv Hsub HB2 HB1 Hseq C. (* don't need Hord *)
 intros c Hval.
(* again we will need to make a case distinction on the chain returned by find_seq x y T.
if it is [] -> then we know y = IV and (x,y) is a valid padding. but then we would have find_seq x y T' <> none,
                yielding a contradiction to C; i.e. in this case actually show the conclusion of the lemma,
                find_seq x y T' <> None, instead of showing a contradiction to the other premises
if it has the form al@[a] -> then we know from Hseq that ischained(T,IV,al++[a],y).
                             from Hval we know that ischained(T,IV,c++[invT[y]],z0).
                             we conclude a = invT[y] since we have from the first chain T[a] = y.
                             so we can rewrite the second chain as ischained(T,IV,c++a,y).
                             then we use ischained_inj to obtain al=c.
                             now: from the original Hseq we knew al++[a]::(x,y) is a valid padding
                                  from the original Hval we know c++invT[y] = al++[a] is a valid padding
                             contradiction to prefix-freeness! *)
 unfold valid_chain in Hval. destruct Hval as (z0,(Hch,Hpad)).
 duplicate Hseq as Hpad'; rename Hseq into Hch'.
 apply find_seq_ischained in Hch'.
 apply find_seq_unpad in Hpad'.
 generalize Hch' Hpad'; clear Hch' Hpad'.
 generalize (proj (find_seq x y T)) as c'. intros.
 case exists_last with (c := c').
  (* c = [] *)
  clear - HB1 HB2 Hsub Hch' Hpad' C.
  intro e. rewrite e in *; clear e c'.
  apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
  apply inclusion_injective with (T' := T') in HB2; [|assumption].
  clear Hsub.
  rewrite ischained_nil in Hch'. rewrite <- ischained_nil in Hch'. (* this replaces T with an existential variable *)
  instantiate (1:=T') in Hch'.
  remember (find_seq_complete T' x y Nil HB2 HB1 Hch' Hpad') as Hseq'; clear - Hseq' C.
  exact (Hseq' C).
  (* c = al@[a] *)
  clear - HB2 HB1 Hinv Hch Hpad Hch' Hpad'.
  intro e. destruct e as (al,(a,e)).
  rewrite e in Hch', Hpad'; clear e c'.
  assert ( get_map invT y = a ) as e.
   clear - Hinv Hch'.
   apply ischained_app in Hch'. destruct Hch' as ((_,Hdom),Heq).
   rewrite ischained_nil in Heq.
   unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
   specialize (Hinv a Hdom). destruct Hinv as (_,Heq').
   rewrite Heq in Heq'. assumption.
  rewrite e in *; clear e.
  clear Hinv invT.
  apply ischained_app in Hch. destruct Hch as ((Hch,_),_).
  rewrite <- (snd_pair _ _ x y) in Hch'.
  remember (claim4 T HB1 HB2 c (Append al (Cons a Nil)) a (pair x y) Hch Hpad Hch' Hpad') as C; clear - C.
  apply C. apply last_in.
Qed.

Lemma Claim5_upd : 
  (forall (T'_747:(map (prod bitstring bitstring) bitstring)),
   (forall (T_746:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_745:(map bitstring (prod bitstring bitstring))),
     (forall (x_744:bitstring),
      (forall (y_743:bitstring),
       ((Injective T_746) ->
        (~(in_rng_map IV T_746) = true ->
         ((Inverse T_746 invT_745) ->
          ((in_dom_map (pair x_744 y_743) T_746) = true ->
           (~(set_bad4 y_743 T'_747 T_746 invT_745) = true ->
            ((Claim5 T'_747 T_746) ->
             (Claim5
              (upd_map
               T'_747 (pair x_744 y_743) (get_map T_746 (pair x_744 y_743))) T_746)))))))))))). 
Proof.
intros T' T invT x y.
intros HB2 HB1 Hinv Hdom Hnbad Hord.
unfold Claim5.
intros x' y' x0 y0.
intros Hdom' Hnext Hdom0 Hnone.
(* from Hdom0 we know either (x0,y0) = (x,y) or (x0,y0) was already in dom(T') *)
apply in_dom_upd_map2 in Hdom0. destruct Hdom0 as [e|Hdom0'].
 (* case (x0,y0) = (x,y) *)
 apply pair_inj in e. destruct e as (_,e).
 rewrite <- e in Hnext; clear e y0.
 rewrite set_bad4_def' in Hnbad.
 apply NNPP; intro C. apply Hnbad; clear Hnbad.
 assert ( get_map invT y = pair x' y' ) as e.
  clear - Hinv Hdom' Hnext.
  unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (_,Hinv). rewrite Hnext in Hinv.
  assumption.
 rewrite e; clear e.
 (* we split bad4 into its three premises. the first and third premises give a contradiction, therefore, intuitively,
if bad4 did not hold, it was because the second premise was not fulfilled, i.e. we must have had invT[y] in dom(T').
but then it is easy to conclude the goal, invT[y] in dom(upd(T',(x,y),T[(x,y)])).
we perform the proof by contradiction: if the conclusion did not hold, then all premises of bad4 would have been fulfilled.
thus, to prove the contradiction, we prove that bad4 holds by splitting its into its three premises. *)
 repeat split.
  (* y in dom(invT) *)
  clear - Hinv Hdom' Hnext.
  unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (Hinv,_). rewrite Hnext in Hinv.
  assumption.
  (* (x',y') not in dom(T') *)
  clear - C. intro Hdom'. apply C.
  apply in_dom_upd_map1.
  right; assumption.
  (* forall c, ~ valid_chain c++(x',y') *)
  clear - HB1 HB2 Hnone. intros c Hval.
  remember (find_seq_complete_valid_chain T x' y' c HB2 HB1 Hval) as Hseq; clear HeqHseq.
  exact (Hseq Hnone).

 (* case (x0,y0) in dom(T') *)
 (* here we can use Claim5 to obtain the conclusion *)
 clear - Hord Hdom' Hnext Hdom0' Hnone.
 unfold Claim5 in Hord.
 specialize (Hord x' y' x0 y0).
 specialize (Hord Hdom' Hnext Hdom0' Hnone).
 clear - Hord.
 apply in_dom_upd_map1.
 right. assumption.
Qed.

Lemma Claim5_upd' : 
  (forall (T'_759:(map (prod bitstring bitstring) bitstring)),
   (forall (T_758:(map (prod bitstring bitstring) bitstring)),
    (forall (invT_757:(map bitstring (prod bitstring bitstring))),
     (forall (x_756:bitstring),
      (forall (y_755:bitstring),
       (forall (z_754:bitstring),
        ((Inclusion T'_759 T_758) ->
         ((Injective T_758) ->
          (~(in_rng_map IV T_758) = true ->
           ((Inverse T_758 invT_757) ->
            (~(in_dom_map (pair x_756 y_755) T_758) = true ->
             (~z_754 = IV ->
              (~(in_rng_map z_754 T_758) = true ->
               (~(set_bad4 y_755 T'_759 T_758 invT_757) = true ->
                ((Claim5 T'_759 T_758) ->
                 (Claim5
                  (upd_map T'_759 (pair x_756 y_755) z_754) (upd_map
                                                             T_758 (pair
                                                                    x_756 y_755) z_754))))))))))))))))).
Proof.
intros T' T invT x y z.
intros Hsub HB2 HB1 Hinv Hndom HnzIV Hnzrng Hnbad Hord.
unfold Claim5.
intros x' y' x0 y0.
intros Hdom' Hnext Hdom0 Hnone.
(* from Hdom0 we know either (x0,y0) = (x,y) or (x0,y0) was already in dom(T') *)
apply in_dom_upd_map2 in Hdom0. destruct Hdom0 as [e|Hdom0'].
 (* case (x0,y0) = (x,y) *)
 apply pair_inj in e. destruct e as (_,e).
 rewrite <- e in Hnext; clear e y0.
 (* case distinction: (x,y) = (x',y') or (x,y) <> (x',y') *)
 case (eq_prod_dec (pair x y) (pair x' y')).
  (* case (x',y') = (x,y) *)
  intro e.  clear - e. rewrite e.
  apply upd_map_dom_same.
  (* case (x',y') <> (x,y). this implies (x',y') in dom(T') with Hdom'. *)
  intro n0.
  rewrite upd_map_dom_diff in Hdom'; [|trivial].
  rewrite get_upd_map_diff in Hnext; [|trivial].
 assert ( find_seq x' y' T = None ) as Hnone'; [|clear Hnone; rename Hnone' into Hnone].
  clear - Hsub HB2 HB1 HnzIV Hnzrng Hndom Hnone.
  apply NNPP; intro Hseq.
  rewrite find_seq_Inclusion_upd_eq with (T' := T) in Hnone; auto.
  unfold Inclusion; auto.
 rewrite set_bad4_def' in Hnbad.
 apply NNPP; intro C. apply Hnbad; clear Hnbad.
 assert ( get_map invT y = pair x' y' ) as e.
  clear - Hinv Hdom' Hnext.
  unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (_,Hinv). rewrite Hnext in Hinv.
  assumption.
 rewrite e; clear e.
 (* we split bad4 into its three premises. the first and third premises give a contradiction, therefore, intuitively,
if bad4 did not hold, it was because the second premise was not fulfilled, i.e. we must have had invT[y] in dom(T').
but then it is easy to conclude the goal, invT[y] in dom(upd(T',(x,y),T[(x,y)])).
we perform the proof by contradiction: if the conclusion did not hold, then all premises of bad4 would have been fulfilled.
thus, to prove the contradiction, we prove that bad4 holds by splitting its into its three premises. *)
 repeat split.
  (* y in dom(invT) *)
  clear - Hinv Hdom' Hnext.
  unfold Inverse in Hinv. destruct Hinv as (Hinv,_).
  specialize (Hinv (pair x' y') Hdom'); clear Hdom'.
  destruct Hinv as (Hinv,_). rewrite Hnext in Hinv.
  assumption.
  (* (x',y') not in dom(T') *)
  clear - C. intro Hdom'. apply C.
  apply in_dom_upd_map1.
  right; assumption.
  (* forall c, ~ valid_chain c++(x',y') *)
  clear - HB1 HB2 Hnone. intros c Hval.
  remember (find_seq_complete_valid_chain T x' y' c HB2 HB1 Hval) as Hseq; clear HeqHseq.
  exact (Hseq Hnone).

 (* case (x0,y0) in dom(T') *)
 (* here we can use Claim5 to obtain the conclusion *)
 (* case distinction: (x,y) = (x',y') or (x,y) <> (x',y') *)
 case (eq_prod_dec (pair x y) (pair x' y')).
  (* case (x',y') = (x,y) *)
  intro e.  clear - e. rewrite e.
  apply upd_map_dom_same.
  (* case (x',y') <> (x,y). this implies (x',y') in dom(T') with Hdom'. *)
  intro n0.
  apply in_dom_upd_map1. right.
  rewrite upd_map_dom_diff in Hdom'; [|trivial].
  unfold Claim5 in Hord.
  specialize (Hord x' y' x0 y0).
  specialize (Hord Hdom').
  assert ( get_map T (pair x' y') = y0 ) as Hnext'.
   clear - n0 Hnext.
   rewrite get_upd_map_diff in Hnext; trivial.
  specialize (Hord Hnext' Hdom0').
  assert ( find_seq x' y' T = None ) as Hnone'.
   clear - Hsub HB2 HB1 HnzIV Hnzrng Hndom Hnone.
   apply NNPP; intro Hseq.
   rewrite find_seq_Inclusion_upd_eq with (T' := T) in Hnone; auto.
   unfold Inclusion; auto.
  exact (Hord Hnone').
Qed.

Lemma find_seq_Claim5_tmp : 
  (forall (T'_777:(map (prod bitstring bitstring) bitstring)),
   (forall (T_776:(map (prod bitstring bitstring) bitstring)),
    (forall (x_775:bitstring),
     (forall (y_774:bitstring),
      (forall (z_773:bitstring),
       ((Inclusion T'_777 T_776) ->
        ((Injective T_776) ->
         (~(in_rng_map IV T_776) = true ->
          (~(in_rng_map z_773 T_776) = true ->
           (~z_773 = IV ->
            ((Claim5
              (upd_map T'_777 (pair x_775 y_774) z_773) (upd_map
                                                         T_776 (pair
                                                                x_775 y_774) z_773)) ->
             ((find_seq x_775 y_774 T'_777) =
              (@None (list (prod bitstring bitstring))) ->
              (find_seq x_775 y_774 (upd_map T_776 (pair x_775 y_774) z_773)) =
              (@None (list (prod bitstring bitstring))))))))))))))).
Proof.
intros T' T x y z.
intros Hsub HB2 HB1 Hnzrng HnzIV Hord Hnone.
apply NNPP; intro Hch.
duplicate Hch as Hpad.
apply find_seq_ischained in Hch.
apply find_seq_unpad in Hpad.
generalize Hch Hpad; clear Hch Hpad.
generalize (proj (find_seq x y (upd_map T (pair x y) z))) as c.
intros.
case exists_last with (c := c).
 (* case c = [] *)
 intro e. rewrite e in *; clear e c.
 apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
 apply inclusion_injective with (T' := T') in HB2; [|assumption].
 clear Hsub.
 rewrite ischained_nil in Hch. rewrite <- ischained_nil in Hch. (* this replaces T with an existential variable *)
 instantiate (1:=T') in Hch.
 remember (find_seq_complete T' x y Nil HB2 HB1 Hch Hpad) as Hseq; clear - Hseq Hnone.
 exact (Hseq Hnone).
 (* case c = a::al *)
 intro e. destruct e as (al,(a,e)). rewrite e in *; clear e c.
 remember (ischained_last_in_dom_Claim5 (upd_map T (pair x y) z) (upd_map T' (pair x y) z) al (pair x y) a) as Hbig; clear HeqHbig.
 assert ( Inclusion (upd_map T' (pair x y) z) (upd_map T (pair x y) z) ) as Hsub'.
  clear - Hsub.
  apply inclusion_upd''; assumption.
 specialize (Hbig Hsub'); clear Hsub'.
 assert ( Injective (upd_map T (pair x y) z) ) as HB2'.
  clear - HB2 Hnzrng.
  apply Injective_upd; assumption.
 specialize (Hbig HB2').
 assert ( in_rng_map IV (upd_map T (pair x y) z) <> true ) as HB1'.
  clear - HB1 HnzIV.
  apply IV_not_rng_upd; assumption.
 specialize (Hbig HB1').
 rewrite snd_pair in Hbig.
 specialize (Hbig Hch).
 rewrite append_assoc in Hpad. rewrite Append_Cons in Hpad. rewrite Append_nil in Hpad.
 specialize (Hbig Hpad).
 assert ( in_dom_map a (upd_map T' (pair x y) z) = true ) as Hdom.
  unfold Claim5 in Hord.
  specialize (Hord (fst_prod a) (snd_prod a) x y).
  rewrite surjective_pairing in Hord.
  apply Hord; clear Hord.
   (* a in dom(upd(T,(x,y),z)) *)
   clear - Hch. apply ischained_app in Hch.
   destruct Hch as ((_,Hdom),_). assumption.
   (* upd(T,(x,y),z)[a] = y *)
   clear - Hch. apply ischained_app in Hch.
   destruct Hch as ((_,_),Heq). rewrite ischained_nil in Heq.
   assumption.
   (* (x,y) in dom(upd(T',(x,y),z)) *)
   clear. rewrite upd_map_dom_same. reflexivity.
   (* find_seq fst(a) snd(a) upd(T,(x,y),z) = None *)
   clear - HB2' HB1' Hch Hpad.
   apply NNPP; intro Hch'.
   duplicate Hch' as Hpad'.
   apply find_seq_ischained in Hch'.
   apply find_seq_unpad in Hpad'.
   rewrite surjective_pairing in Hpad'.
   generalize Hch' Hpad'; clear Hch' Hpad'.
   generalize (proj (find_seq (fst_prod a) (snd_prod a) (upd_map T (pair x y) z))) as c'.
   intros.
   remember (claim4 (upd_map T (pair x y) z) HB1' HB2' c' (Append al (Cons a Nil)) a (pair x y)) as C; clear HeqC.
   clear HB1' HB2'.
   specialize (C Hch' Hpad'); clear Hch' Hpad'.
   rewrite snd_pair in C. rewrite append_assoc in C. rewrite Append_Cons in C. rewrite Append_nil in C.
   specialize (C Hch Hpad); clear Hch Hpad.
   apply C. apply last_in.
 clear HB1' HB2'.
 specialize (Hbig Hdom); clear Hdom.
 specialize (Hbig Hord); clear Hord.
 assert ( Injective (upd_map T' (pair x y) z) ) as HB2'.
  clear - Hsub HB2 Hnzrng.
  apply Injective_upd.
  apply inclusion_not_rng with (T := T); assumption.
  apply inclusion_injective with (T := T); assumption.
 assert ( in_rng_map IV (upd_map T' (pair x y) z) <> true ) as HB1'.
  clear - Hsub HB1 HnzIV.
  apply IV_not_rng_upd; [|assumption].
  apply inclusion_not_rng with (T := T); assumption.
 remember (find_seq_complete (upd_map T' (pair x y) z) x y (Append al (Cons a Nil)) HB2' HB1' Hbig) as Hseq; clear HeqHseq.
 rewrite append_assoc in Hseq. rewrite Append_Cons in Hseq. rewrite Append_nil in Hseq.
 specialize (Hseq Hpad).
 clear - Hsub HB1 HB2 HB1' HB2' Hseq Hnone.
 apply inclusion_not_rng with (T' := T') in HB1; [|assumption].
 apply inclusion_injective with (T' := T') in HB2; [|assumption].
 clear Hsub.
 remember (find_seq_helpful_upd T' x y x y z HB2 HB1 Hnone Hseq) as Hin; clear HeqHin.
 clear Hnone HB1 HB2.
 duplicate Hseq as Hpad; rename Hseq into Hch.
 apply find_seq_ischained in Hch.
 apply find_seq_unpad in Hpad.
 generalize Hch Hpad Hin; clear Hch Hpad Hin.
 generalize (proj (find_seq x y (upd_map T' (pair x y) z))) as c; intros.
 rewrite <- (snd_pair _ _ x y) in Hch at 2.
 remember (claim4 (upd_map T' (pair x y) z) HB1' HB2' c c (pair x y) (pair x y) Hch Hpad Hch Hpad) as C; clear - Hin C.
 exact (C Hin).
Qed.

Lemma help : forall (i:Z) (I:map Z (bitstring * bool)%type) 
 (Z':list bitstring) (z1 z2:bitstring), 
  in_dom_map i I = false ->
  (forall (z:bitstring), 
   in_list z Z' = true -> 
   exists i1:Z, in_dom_map i1 I = true /\ fst (get_map I i1) = z) -> 
   in_list z1 (Cons z2 Z') = true -> 
   exists iqt:Z,
    in_dom_map iqt (upd_map I i (z2, false)) = true /\ 
    fst (get_map (upd_map I i (z2, false)) iqt) = z1.
Proof.
 intros.
 rewrite in_list_Cons in H1.
 rewrite bool_or_def in H1. 
 destruct H1.

 rewrite poly_eq_eq in H1; subst.
 exists i; split.
 apply upd_map_dom_same.
 rewrite get_upd_map_same; trivial.

 destruct (H0 _ H1) as [i' [? ?] ].
 exists i'; split.
 rewrite upd_map_dom_diff; trivial.
 intros ?; subst; rewrite H in H2; discriminate.
 rewrite get_upd_map_diff; trivial.
 intros ?; subst; rewrite H in H2; discriminate.
Qed.

Axiom find_seq_Claim5 : 
  forall invT,
  (forall (T'_777:(map (prod bitstring bitstring) bitstring)),
   (forall (T_776:(map (prod bitstring bitstring) bitstring)),
    (forall (x_775:bitstring),
     (forall (y_774:bitstring),
      (forall (z_773:bitstring),
       ((Inclusion T'_777 T_776) ->
        ((Injective T_776) ->
         (~(in_rng_map IV T_776) = true ->
          Inverse T_776 invT ->
          ~(in_dom_map (pair x_775 y_774) T_776 = true) ->
          (~(in_rng_map z_773 T_776) = true ->
           (~z_773 = IV ->
            ((Claim5 T'_777 T_776) ->
            ~(set_bad4 y_774 T'_777 T_776 invT = true) ->
             ((find_seq x_775 y_774 T'_777) =
              (@None (list (prod bitstring bitstring))) ->
              (find_seq x_775 y_774 (upd_map T_776 (pair x_775 y_774) z_773)) =
              (@None (list (prod bitstring bitstring))))))))))))))).

Lemma help1 : 
  forall (I:map Z (bitstring * bool)%type) (ZZ:list bitstring) (j:Z), 
  (forall (z:bitstring), 
    in_list z ZZ = true -> 
    exists i:Z, in_dom_map i I = true /\ fst (get_map I i) = z) ->
  forall (z:bitstring),
   let I' := upd_map I j (fst (get_map I j), false) in 
   in_list z ZZ = true ->
  exists i:Z, in_dom_map i I' = true /\ fst (get_map I' i) = z.
Proof.
 intros.
 destruct (H z H0) as [i [H1 H2]].
 case_eq (poly_eq i j); intro Heq.
 rewrite poly_eq_eq in Heq; subst.

 exists j; unfold I'; split.
 apply upd_map_dom_same.
 rewrite get_upd_map_same; trivial.

 exists i; unfold I'; split. 
 rewrite upd_map_dom_diff; trivial.
 intros ?; subst; rewrite poly_eq_refl in Heq; discriminate.
 rewrite get_upd_map_diff; trivial.
 intros ?; subst; rewrite poly_eq_refl in Heq; discriminate. 
Qed.

Definition ROmapinT (ROmap:map (list bool) (prod bitstring Z)) 
  (T:map (prod bitstring bitstring) bitstring) : Prop := 
  (forall (m:list bool), 
   in_dom_map m ROmap = true -> 
   exists x:bitstring, exists y:bitstring,
    find_seq x y T <> None /\
    m = proj(unpad(mapfst(Append(proj(find_seq x y T)) (Cons (pair x y) Nil)))) /\ 
    in_dom_map (pair x y) T = true) /\ 
  (forall (x:bitstring) (y:bitstring), 
    find_seq x y T <> None ->
    in_dom_map(proj(unpad(mapfst(Append(proj(find_seq x y T)) 
       (Cons (pair x y) Nil))))) ROmap = true ->
    in_dom_map (pair x y) T = true) /\ 
  (forall (x:bitstring) (y:bitstring),
    find_seq x y T <> None -> 
    in_dom_map (pair x y) T = true ->
    in_dom_map (proj(unpad(mapfst(Append(proj(find_seq x y T)) 
      (Cons (pair x y) Nil))))) ROmap = true /\
     fst_prod (get_map ROmap 
       (proj(unpad(mapfst(Append(proj(find_seq x y T)) (Cons (pair x y) Nil)))))) =
     get_map T (pair x y)).

Lemma ROmapinT_upd2 : forall (T T':map (prod bitstring bitstring) bitstring) 
  (invT:map bitstring (prod bitstring bitstring)) (x:bitstring) (y z:bitstring)
  (ROmap:map (list bool) (prod bitstring Z)%type), 
  Inclusion T' T -> 
  Injective T -> 
  in_rng_map IV T <> true ->
  Inverse T invT -> 
  in_dom_map (pair x y) T <> true -> 
  in_rng_map z T <> true ->
  z <> y -> 
  z <> IV -> 
  (forall (x0:bitstring), in_dom_map (pair x0 z) T <> true) -> 
  set_bad4 y T' T invT <> true ->
  Claim5 T' T ->
  find_seq x y T' = None -> 
  ROmapinT ROmap T ->
  ROmapinT ROmap (upd_map T (pair x y) z).
Proof.
 intros; unfold ROmapinT in *.
 destruct H11; destruct H12.
 assert (forall m : list bool,
    in_dom_map m ROmap = true ->
    exists x0 : bitstring, exists y0 : bitstring,
        find_seq x0 y0 (upd_map T (pair x y) z) <> None /\
        m =
        proj
          (unpad
             (mapfst
                (Append (proj (find_seq x0 y0 (upd_map T (pair x y) z)))
                   (Cons (pair x0 y0) Nil)))) /\
        in_dom_map (pair x0 y0) (upd_map T (pair x y) z) = true).
  intros.
  apply H11 in H14.
  destruct H14.
  destruct H14.
  rename x1 into y0.
  destruct H14.
  destruct H15.
  exists x0, y0.
  rewrite find_seq_upd_nohelp; trivial.
  split; trivial.
  split; trivial.
  rewrite in_dom_upd_map1; trivial.
  right; trivial.
  apply all_not_not_ex; trivial.
  rewrite in_dom_upd_map1; trivial.
  right; trivial.
  split; trivial.
  split; intros.
  apply H14 in H16.
  destruct H16.
  destruct H16.
  rename x2 into y1.
  destruct H16.
  destruct H17.
  rewrite <- (find_seq_mapfst_eq _ _ _ _ _ H16 H15 H17).
  trivial.
  intros.
  remember H15 as F; clear HeqF.
  rewrite find_seq_upd_nohelp; trivial.
 rewrite find_seq_upd_nohelp in H15; trivial.
 apply in_dom_upd_map2 in H16.
 destruct H16.
 apply pair_inj in H16; destruct H16; subst.
 destruct F.
 apply (find_seq_Claim5 invT T' T); trivial.
 rewrite get_upd_map_diff.
 apply (H13 _ _ H15 H16).
 intro.
 rewrite H17 in *.
 intuition.
 apply all_not_not_ex; trivial.
 apply all_not_not_ex; trivial.
Qed.
