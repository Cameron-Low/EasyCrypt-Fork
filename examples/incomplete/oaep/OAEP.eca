require import AllCore List FSet NewFMap.
require import Distr DBool DProd.
require (*--*) Ring ROM.

pragma +implicits.
pragma -oldip.

(* Type for G's outputs (and H's inputs)                                    *)
clone import Ring.ZModule as GTag
rename [type] "t" as "gtag".

op dgtag: { gtag distr |    is_lossless dgtag
                         /\ is_uniform  dgtag
                         /\ is_full     dgtag } as dgtag_ll_uni_fu.

lemma dgtag_ll  : is_lossless dgtag by smt(dgtag_ll_uni_fu).
lemma dgtag_uni : is_uniform  dgtag by smt(dgtag_ll_uni_fu).
lemma dgtag_fu  : is_full     dgtag by smt(dgtag_ll_uni_fu).
lemma dgtag_funi: is_funiform dgtag by smt(dgtag_ll_uni_fu).

(* Type for H's outputs (and G's inputs)                                    *)
clone import Ring.ZModule as HTag
rename [type] "t" as "htag".

op dhtag: { htag distr |    is_lossless dhtag
                         /\ is_uniform  dhtag
                         /\ is_full     dhtag } as dhtag_ll_uni_fu.

lemma dhtag_ll  : is_lossless dhtag by smt(dhtag_ll_uni_fu).
lemma dhtag_uni : is_uniform  dhtag by smt(dhtag_ll_uni_fu).
lemma dhtag_fu  : is_full     dhtag by smt(dhtag_ll_uni_fu).
lemma dhtag_funi: is_funiform dhtag by smt(dhtag_ll_uni_fu).

(* The type of plaintext must be injected strictly into gtag:               *)
(*                                  redundancy is crucial for OAEP to work! *)
type ptxt.

op pad  : ptxt -> gtag.
op unpad: gtag -> ptxt option.

axiom padK  : pcancel pad unpad.
axiom unpadK: ocancel unpad pad.

(* The permutation works on pairs of GTag and HTag                          *)
clone import Ring.ZModule as D with
  type t                       <- gtag * htag,
  op   zeror                   <- (GTag.zeror,HTag.zeror),
  op   (+) (x y : gtag * htag) <- ((x.`1 + y.`1),(x.`2 + y.`2)),
  op   [-] (x : gtag * htag)   <- (-x.`1,-x.`2)
proof *.
realize addrA. by move=> x y z /=; rewrite GTag.addrA HTag.addrA. qed.
realize addrC. by move=> x y /=; rewrite GTag.addrC HTag.addrC. qed.
realize add0r. by move=> [x1 x2] /=; rewrite GTag.add0r HTag.add0r. qed.
realize addNr. by move=> [x1 x2] /=; rewrite GTag.addNr HTag.addNr. qed.

op dd = dgtag `*` dhtag.

lemma dd_ll  : is_lossless dd by rewrite dprod_ll dgtag_ll dhtag_ll.
lemma dd_uni : is_uniform  dd by rewrite dprod_uni 1:dgtag_uni// dhtag_uni.
lemma dd_fu  : is_full     dd by rewrite dprod_fu dgtag_fu dhtag_fu.
lemma dd_funi: is_funiform dd by rewrite dprod_funi 1:dgtag_funi// dhtag_funi.

(* The permutation itself (with abstract keys)                              *)
type pkey, skey.

op dkeys : { (pkey * skey) distr | is_lossless dkeys } as dkeys_ll.

op f : pkey -> gtag * htag -> gtag * htag.
op fi: skey -> gtag * htag -> gtag * htag.

axiom fK pk sk : (pk,sk) \in dkeys => cancel (f pk) (fi sk).
axiom fiK pk sk: (pk,sk) \in dkeys => cancel (fi sk) (f pk).

(* The G random oracle                                                      *)
clone import ROM.Lazy as G with
  type from      <- htag,
  type to        <- gtag,
  op   dsample _ <- dgtag
proof *
rename
  "RO"     as "G"
  "Oracle" as "Gt".
import Types.

(* The H random oracle                                                      *)
clone import ROM.Lazy as H with
  type from      <- gtag,
  type to        <- htag,
  op   dsample _ <- dhtag
proof *
rename
  "RO"     as "H"
  "Oracle" as "Ht".
import Types.

(* ------------------------------------------------------------------------ *)
module OAEP (H : AH) (G : AG) = {
  proc kg() = {
    var pk, sk;

    (pk,sk) <$ dkeys;
    return (pk,sk);
  }

  proc enc(pk : pkey, m : ptxt) = {
    var r, s, t;

    r <$ dhtag;
    s <@ G.o(r);
    s <- s + (pad m);
    t <@ H.o(s);
    t <- t + r;
    return f pk (s,t);
  }

  proc dec(sk : skey, c : gtag * htag) = {
    var s, t, r, m;

    (s,t) <- fi sk c;
    r <@ H.o(s);
    r <- r + t;
    m <@ G.o(r);
    m <- m + s;
    return unpad m;
  }
}.

(* ------------------------------------------------------------------------ *)
module type PKE = {
  proc kg(): pkey * skey
  proc enc(pk : pkey, m : ptxt): gtag * htag
  proc dec(sk : skey, c : gtag * htag): ptxt option
}.

module type HG_PKE (H : AH) (G : AG) = {
  proc kg(): pkey * skey
  proc enc(pk : pkey, m : ptxt): gtag * htag
  proc dec(sk : skey, c : gtag * htag): ptxt option
}.

module type APKE = {
  proc dec(c : gtag * htag): ptxt option
}.

module type CCA_ADV (H : AH) (G : AG) (S : APKE) = {
  proc choose(pk : pkey): ptxt * ptxt
  proc guess(c : gtag * htag): bool
}.

module IND_CCA (H : Ht) (G : Gt) (S : HG_PKE) (A : CCA_ADV) = {
  var sk : skey
  var c' : gtag * htag

  module Sc = {
    proc dec(c : gtag * htag) = {
      var r <- None;

      r <@ S(H,G).dec(sk,c);
      return r;
    }
  }

  module Sg = {
    proc dec(c : gtag * htag) = {
      var r <- None;

      if (c <> c') {
        r <@ S(H,G).dec(sk,c);
      }
      return r;
    }
  }

  proc main() = {
    var pk, m0, m1, b, b';

               H.init();
               G.init();

    (pk,sk) <$ dkeys;
    (m0,m1) <@ A(H,G,Sc).choose(pk);
    b       <$ {0,1};
    c'      <@ S(H,G).enc(pk,b?m0:m1);
    b'      <@ A(H,G,Sg).guess(c');
    return b = b';
  }
}.

(* ------------------------------------------------------------------------ *)
(* A quick note here: our inverter *does not* take over the random oracles, *)
(* but simply uses them. This does not really make a difference if this is  *)
(* the end of the proof, but will make a huge difference if we then compose *)
(* this proof with another one that requires the random oracles to be true  *)
(* random oracles. It may be a good idea to write something about this...   *)
(* ------------------------------------------------------------------------ *)
module type Inverter (H : AH) (G : AG) = {
  proc invert(pk : pkey, c : gtag * htag): gtag list (* could use fset *)
}.

module SPDOW (H : Ht) (G : Gt) (I : Inverter) = {
  proc main() = {
    var pk, sk, s, t, ss;

               H.init();
               G.init();

    (pk,sk) <$ dkeys;
    (s,t)   <$ dd;
    ss      <@ I(H,G).invert(pk,f pk (s,t));
    return s \in ss;
  }
}.

(*
op extract (p : 'x -> bool) (xs : 'x list) =
  with xs = []    => None
  with xs = x::xs =>
    if   p x
    then Some x
    else extract p xs. 

op extract2 (p : 'x -> 'y -> bool) (xs : 'x list) (ys : 'y list) =
  with xs = []    => None
  with xs = x::xs =>
    let y = extract (p x) ys in
    if   y <> None
    then Some (x,oget y)
    else extract2 p xs ys.

lemma extract_correct (p : 'x -> bool) xs a:
     extract p xs = Some a
  => p a.
proof. by elim: xs=> //= x xs ih; case: (p x). qed.

lemma extract2_correct (p : 'x -> 'y -> bool) xs ys a b:
     extract2 p xs ys = Some (a,b)
  => p a b.
proof.
elim: xs=> //= x xs ih.
case: {-1}(extract (p x) ys) (eq_refl (extract (p x) ys))=> // y.
by move=> /extract_correct; rewrite oget_some=> /= + [#] <- <-.
qed.

module I (A : CCA_ADV) (H : AH) (G : AG) = {
  var pk  : pkey
  var logH: (gtag * htag) list
  var logG: (htag * gtag) list

  module H' = {
    proc o(x : gtag) = {
      var r;

      r    <@ H.o(x);
      logH <- (x,r)::logH;
      return r;
    }
  }

  module G' = {
    proc o(x : htag) = {
      var r;

      r    <@ G.o(x);
      logG <- (x,r)::logG;
      return r;
    }
  }

  module S = {
    proc dec(c : gtag * htag): ptxt option = {
      var sg, s, g;
      var m <- None;

      (* Could probably reduce asymptotic and proof complexity here.        *)
      sg <- extract2 (fun (sh : gtag * htag) (rg : htag * gtag)=>
                        let (s,h) = sh in
                        let (r,g) = rg in
                            c = f pk (s,r + h)
                         /\ unpad (s + g) <> None)
                     logH logG;
      if (sg <> None) {
        (s,g) <- ((oget sg).`1.`1,(oget sg).`2.`2);
        m     <- unpad (s + g);
      }
      return m;
    }
  }

  proc invert(pk' : pkey, c : gtag * htag) = {
    var m0, m1;

    logH    <- [];
    logG    <- [];
    pk      <- pk';

    (m0,m1) <@ A(H,G,S).choose(pk);
               A(H,G,S).guess(c);
    return logH;
  }
}.
*)

section.
declare module A : CCA_ADV {H, G,(* I,*) IND_CCA}.

axiom A_choose_ll (H <: AH {A}) (G <: AG {A}) (S <: APKE {A}):
  islossless S.dec => islossless G.o => islossless H.o =>
  islossless A(H,G,S).choose.

axiom A_guess_ll (H <: AH {A}) (G <: AG {A}) (S <: APKE {A}):
  islossless S.dec => islossless G.o => islossless H.o =>
  islossless A(H,G,S).guess.

local module Game0 (H : Ht) (G : Gt) = {
  var sk: skey
  var c': gtag * htag

  module Sc = {
    proc dec(c : gtag * htag) = {
      var r <- None;

      r <@ OAEP(H,G).dec(sk,c);
      return r;
    }
  }

  module Sg = {
    proc dec(c : gtag * htag) = {
      var r <- None;

      if (c <> c') {
        r <@ OAEP(H,G).dec(sk,c);
      }
      return r;
    }
  }

  proc main() = {
    var pk, m0, m1, b, b', r, s, t;

               H.init();
               G.init();

    (pk,sk) <$ dkeys;
    (m0,m1) <@ A(H,G,Sc).choose(pk);
    b       <$ {0,1};
    r       <$ dhtag;
    s       <@ G.o(r);
    s       <- s + pad (b?m0:m1);
    t       <@ H.o(s);
    t       <- t + r;
    c'      <- f pk (s,t);
    b'      <@ A(H,G,Sg).guess(c');
    return b = b';
  }
}.

local lemma eq_INDCCA_Game0 (H <: Ht {A, Game0, IND_CCA})
                            (G <: Gt {A, H, Game0, IND_CCA}):
  equiv [IND_CCA(H,G,OAEP,A).main ~ Game0(H,G).main:
           ={glob A, glob H, glob G} ==> ={res}].
proof.
proc; call (:   ={glob H, glob G}
             /\ ={sk,c'}(IND_CCA,Game0)).
+ by sim.
+ by sim.
+ by sim.
inline OAEP(H,G).enc.
auto; call (: true).
auto; call (: true).
auto.
call (:   ={glob H, glob G}
       /\ ={sk}(IND_CCA,Game0)).
+ by sim.
+ by sim.
+ by sim.
by auto; call (: true); call (: true).
qed.

local module Game1 (H : Ht) (G : Gt) = {
  var sk : skey
  var r  : htag
  var c' : gtag * htag
  var log: htag fset

  module G' = {
    proc o(x : htag) = {
      var r;

      log <- log `|` fset1 x;
      r   <@ G.o(x);
      return r;
    }
  }

  module Sc = {
    proc dec(c : gtag * htag) = {
      var p <- None;

      p <@ OAEP(H,G).dec(sk,c);
      return p;
    }
  }

  module Sg = {
    proc dec(c : gtag * htag) = {
      var p <- None;

      if (c <> c') {
        p <@ OAEP(H,G).dec(sk,c);
      }
      return p;
    }
  }

  proc main() = {
    var pk, m0, m1, b, b', s, t;

               H.init();
    log     <- fset0;
               G.init();

    (pk,sk) <$ dkeys;
    r       <$ dhtag;
    s       <$ dgtag;
    (m0,m1) <@ A(H,G,Sc).choose(pk);
    t       <@ H.o(s);
    t       <- t + r;
    c'      <- f pk (s,t);
    b       <$ {0,1};
    b'      <@ A(H,G,Sg).guess(c');
    return b = b';
  }
}.

local lemma eq_upto_G_o P:
  equiv [G.o ~ G.o:
    (forall x, x \in dom G.m{2} => !P x) /\
    ={x} /\
    eq_except G.m{1} G.m{2} P
    ==> (forall x, x \in dom G.m{2} => !P x) =>
        ={res} /\
        eq_except G.m{1} G.m{2} P].
proof.
proc; auto=> /> &1 &2 not_bad eqe g _; split.
+ rewrite !getP_eq dom_set eq_except_set=> //= x_notin_m2 x_in_m1 /(_ x{2}).
  rewrite in_fsetU in_fset1=> //= x_notin_P.
  have /iffLR /(_ eqe x{2} x_notin_P) eq_mx:= eq_exceptP G.m{1} G.m{2} P.
  by move: x_in_m1 x_notin_m2; rewrite !in_dom eq_mx.
rewrite !getP_eq oget_some=> ^ + /not_bad x_notin_P.
have /iffLR /(_ eqe x{2} x_notin_P) eq_mx:= eq_exceptP G.m{1} G.m{2} P.
by rewrite !in_dom eq_mx.
qed.

local lemma eq_upto1_G_o r:
  equiv [G.o ~ G.o:
    !(r \in dom G.m){2} /\
    ={x} /\
    eq_except G.m{1} G.m{2} (pred1 r)
    ==> !(r \in dom G.m){2} =>
        ={res} /\
        eq_except G.m{1} G.m{2} (pred1 r)].
proof.
have not_memP: forall (s : htag fset),
  !(r \in s) <=> (forall x, x \in s => x <> r).
+ smt().
by conseq (eq_upto_G_o (pred1 r))=> /#.
qed.

local lemma eq_upto_OAEP_dec (H <: Ht {G, Game0, Game1}):
  equiv [OAEP(H,G).dec ~ OAEP(H,G).dec:
    !(Game1.r \in dom G.m){2} /\
    ={glob H, c, sk} /\
    ={sk, c'}(Game0,Game1) /\
    eq_except G.m{1} G.m{2} (pred1 Game1.r{2})
    ==> !(Game1.r \in dom G.m){2} =>
        ={glob H, res} /\
        ={sk, c'}(Game0,Game1) /\
        eq_except G.m{1} G.m{2} (pred1 Game1.r{2})].
proof.
proc; exists * Game1.r{2}; elim *=> r.
wp; call (eq_upto1_G_o r).
wp; call (: true).
by auto=> /#.
qed.

local lemma OAEP_dec_ll (H <: Ht) (G <: Gt):
  islossless H.o =>
  islossless G.o =>
  islossless OAEP(H,G).dec.
proof.
by move=> H_o_ll G_o_ll; proc; wp; call G_o_ll; wp; call H_o_ll; auto.
qed.

local lemma eq_Game0_Game1 (H <: Ht {G, Game0, Game1}):
  islossless H.o =>
  equiv [Game0(H,G).main ~ Game1(H,G).main:
           ={glob A, glob H} ==>
              !(Game1.r \in dom G.m){2}
           => ={res}].
proof.
move=> H_o_ll; proc.
swap{2} [5..6] 1. swap{2} 11 -5.
call (: Game1.r \in dom G.m,
        ={glob H} /\
        ={sk, c'}(Game0,Game1) /\
        eq_except G.m{1} G.m{2} (pred1 Game1.r{2})).
+ exact/A_guess_ll.
+ by proc; sp; if=> //=; call (eq_upto_OAEP_dec H); auto=> /#.
+ by move=> _ _; proc; sp; if=> //=; call (OAEP_dec_ll H G H_o_ll (G_o_ll dgtag_ll)).
+ move=> _; conseq (: true) (: Game1.r \in dom G.m ==> Game1.r \in dom G.m)=> //=.
  + by proc; inline *; sp; if=> //=; auto; call (: true); auto=> />; smt(dom_set in_fsetU).
  by proc; sp; if=> //=; call (OAEP_dec_ll H G H_o_ll (G_o_ll dgtag_ll)).
+ by proc *; exists * Game1.r{2}; elim *=> r; call (eq_upto1_G_o r).
+ move=> _ _; exact/(G_o_ll dgtag_ll).
+ move=> _; conseq (G_o_ll dgtag_ll) (: Game1.r \in dom G.m ==> Game1.r \in dom G.m)=> //=.
  by proc; auto=> />; smt(dom_set in_fsetU).
+ by proc *; call (: true).
+ move=> _ _; exact/H_o_ll.
+ by move=> />; conseq H_o_ll (: true).
wp; call (: Game1.r \in dom G.m, true); inline G.o; wp.
rnd (fun x=> x + pad (if b then m0 else m1){2})
    (fun x=> x - pad (if b then m0 else m1){2}).
auto.
call (: ={glob H, glob G} /\ ={sk}(Game0,Game1)).
+ by sim.
+ by sim.
+ by sim.
inline *; auto; call (: true); auto=> /> [pk sk] vk [m0 m1] Gm b _ r _; split=> [g _ /=|_].
+ by rewrite subrK.
split=> [g _|_ g _].
+ exact/dgtag_funi.
rewrite dgtag_fu /= -addrA subrr addr0 /= !getP /= oget_some /=.
by rewrite set_eq_except /= /#.
qed.

local lemma pr_INDCCA_Game1 (H <: Ht {A, G, Game0, Game1, IND_CCA}) &m:
  islossless H.init =>
  islossless H.o =>
     Pr[IND_CCA(H,G,OAEP,A).main() @ &m: res] - 1%r/2%r
  <= Pr[Game1(H,G).main() @ &m: Game1.r \in dom G.m].
proof.
move=> H_init_ll H_o_ll.
have ->:   Pr[IND_CCA(H,G,OAEP,A).main() @ &m: res]
         = Pr[Game0(H,G).main() @ &m: res].
+ by byequiv (eq_INDCCA_Game0 H G).
rewrite StdOrder.RealOrder.ler_subl_addl.
have <-: Pr[Game1(H,G).main() @ &m: res] = 1%r/2%r.
+ byphoare=> //=; proc; swap 11 1; rnd (pred1 b').
  conseq (: true)=> //=.
  + by move=> b'; rewrite dbool1E.
  call (A_guess_ll H G (<: Game1(H,G).Sg) _ _ _).
  + proc; sp; if=> //=; call (: true)=> //=.
    by wp; call (G_o_ll dgtag_ll); wp; call H_o_ll; auto.
  + exact/(G_o_ll dgtag_ll).
  + exact/H_o_ll.
  auto; call H_o_ll.
  call (A_choose_ll H G (<: Game1(H,G).Sc) _ _ _).
  + proc; call (: true); auto=> //=.
    by wp; call (G_o_ll dgtag_ll); wp; call H_o_ll; auto.
  + exact/(G_o_ll dgtag_ll).
  + exact/H_o_ll.
  auto; call G_init_ll; auto; call H_init_ll; auto=> />.
  by rewrite dkeys_ll dhtag_ll dgtag_ll.
by byequiv (eq_Game0_Game1 H H_o_ll)=> /#.
qed.

end section.
