\documentclass[]{article}

\usepackage{enumerate}
\usepackage{amsmath}

\newtheorem{definition}{Definition}

\begin{document}

\title{AKE proof sketch}
\author{}
\maketitle

% misc
\newcommand{\tr}{\mathit{tr}}

% events
\newcommand{\StaticRev}{\mathsf{StaticRev}}
\newcommand{\EphemeralRev}{\mathsf{EphemeralRev}}
\newcommand{\SessionRev}{\mathsf{SessionRev}}
\newcommand{\Start}{\mathsf{Start}}
\newcommand{\Accept}{\mathsf{Accept}}
\newcommand{\Init}{\mathsf{Init_1}}
\newcommand{\Initt}{\mathsf{Init_2}}
\newcommand{\Resp}{\mathsf{Resp}}

\newcommand{\HasMatching}{\mathsf{HasMatching}}

% types
\newcommand{\psid}{\mathit{psid}}
\newcommand{\sid}{\mathit{sid}}
\newcommand{\agent}{\mathit{agent}}
\newcommand{\epk}{\mathit{epk}}
\newcommand{\esk}{\mathit{esk}}

% session data
\newcommand{\actor}[1]{#1_{\mathit{actor}}}
\newcommand{\role}[1]{#1_{\mathit{role}}}
\newcommand{\peer}[1]{#1_{\mathit{peer}}}
\newcommand{\sent}[1]{#1_{\mathit{sent}}}
\newcommand{\rcvd}[1]{#1_{\mathit{rcvd}}}
\newcommand{\fresh}{\mathit{fresh}}

\section{The eCK model}

For a session $t$, we use $\actor{t}$, $\role{t}$, $\peer{t}$ to denote the
  actor, the role, and the (intended) peer.
We use $\sent{t}$ to denote $t$'s ephemeral public key and $\rcvd{t}$ to denote
  the received ephemeral public key.

\begin{definition}
Let $t\in \sid$ with $t=(A,B,X,Y,r)$.
We define the matching function $(\cdot)^{*} : \sid \to \sid$
  such that $t^* = (B,A,Y,X, \neg r)$,
  the partial session function $p : \sid \to \psid$ such that
  $p(t) = (A,B,X)$,
  and the session completion function
  $c : \psid \times \epk \to \sid$ such that $c(p(t), \rcvd{t}) = t$.
\end{definition}

The following events can occur in the trace and correspond roughly to oracle queries.
\begin{description}
\item[$\StaticRev(\hat{A} : \agent)$:] Static secret key of agent $\hat{A}$ revealed.
\item[$\EphemeralRev(s : \psid)$:] Ephemeral secret key of session with partial session
  id $s$ revealed.
\item[$\SessionRev(s : \sid)$:] Session key of session with session id $s$ revealed.
\item[$\Start(p : \psid)$:] The Initiator session with partial session id $p$ has
  been start.
\item[$\Accept(s : \sid)$:] Session with session id $s$ accepts session key.
\end{description}



\begin{definition}
We say a test session $t$ is fresh with respect to a trace $\tr$ (written $\fresh(\tr, t)$)
  unless one of the following statements hold:
\begin{enumerate}
\item $\SessionRev(t) \in \tr$.
\item $\EphemeralRev(t) \in \tr \land \StaticRev(\actor{t}) \in \tr$.
\item $\SessionRev(t^*) \in \tr$.
\item $\StaticRev(\peer{t}) \in \tr \land (\EphemeralRev(p(t^*)) \in \tr \lor \neg \HasMatching(\tr, t))$.
\end{enumerate}
where
\[
  \HasMatching(\tr, t)) = (\Accept(t^*) \in \tr\; \lor\; (\Start(p(t^*)) \in \tr
    \land \neg (\exists Y.\, \Accept(c(p(t^*),Y)))))
\]
\end{definition}

Note that our definition is stronger than the standard $eCK$ definition where
  $\HasMatching(\tr, t)) = \Accept(t^*) \in \tr$, but weaker than the
  $eCK^w$ definition.
The definition is meant to capture that $t$ has a matching session if there is a session
  that can be completed to a matching session $t^*$.
Note that this intuition is not excactly captured if there are collisions, e.g., if two sessions
  with the same session id $s=p(t^*)$ have been started and one has been completed to $s' \neq t^*$,
  then $\HasMatching(\tr, t)$ is false, but the second session with session id $s$ can
  still be completed to~$t^*$. 

\newcommand{\Ake}{\mathsf{AKE}}
\newcommand{\Ev}[1]{\mathit{Ev}_{#1}}

\section{Initial Game $AKE$ and winning condition}

The main function is defined as
\begin{align*}
& t \leftarrow A_1(pks) \\
& b \leftarrow\!\!\$ \; \{0,1\} \\
& b' \leftarrow A_2(b\, ?\, sessionkey(t) : r)
\end{align*}
where the adversary has access to $h_1^A$, $h_2^A$, $\StaticRev$,
  $\EphemeralRev$, $\SessionRev$, $\Init$, $\Initt$, and $\Resp$.
The oracles all work as expected and only return $\bot$ if the adversary
  performs an invalid query.
They do not enforce freshness.

We want to prove an upper bound on
\[
  Pr[\Ake : \fresh(t, \tr) \land b = b'].
\]

\subsection{No collisions of ephemeral secret keys}

Bound probability of collisions in sampling ephemeral secret keys:
\begin{align*}
  & Pr[\Ake : \fresh(t, \tr) \land b = b'] \\
  \leq{}&   Pr[\Ake : \fresh(t, \tr) \land b = b' \land \neg collision]
          + Pr[\Ake : collision]
\end{align*}


\subsection{No $H_1$ guessing of ephemeral secret keys by adversary}

Change $H_1^A$ to

\begin{verbatim}
H1A(a,x) =
res = None
if (exists psinfo in mstarted. EphemeralRev(public(psinfo)) notin tr
                               /\ esk(psinfo) = x) {
  bad = true
} else {
  < normal code >
}
return res
\end{verbatim}
%
Guess $i_{sess}$ which is $eid$ of the given session, and $i_{H_1}$ which is critical
  hash query.
%
Where is $x$ used
\begin{itemize}
\item in $Init_1$ (forget $Resp$)
\item used in H1A
\end{itemize}

\section{Choices for up-to failure steps}

For

\[
  Pr[G_1 : A] \leq Pr[G_2 : A \land \neg F] + Pr[G_2 : F]
\]
%
it suffices to show that
\[
  Pr[G_1 : A \land \neg F] \leq Pr[G_2 : A \land \neg F]
\]
and
 \[
   Pr[G_1 : F] \leq Pr[G_2 : F].
 \]
%
Or we can even directly prove an equiv of the form
\begin{verbatim}
  G_1 ~ G_2 : true ==> A<1> => (F \/ (A /\ !F})<2>
\end{verbatim}
which implies the first inequality.

Alternatively, we can conclude that
\[
  Pr[G_1 : A] \leq Pr[G_2 : A \land \neg F] + Pr[G_1 : A \land F]
\]
%
if we can show that
\[
  Pr[G_1 : A \land \neg F] \leq Pr[G_2 : A \land \neg F].
\]

\end{document}





