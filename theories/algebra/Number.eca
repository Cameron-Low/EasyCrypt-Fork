(* --------------------------------------------------------------------
 * Copyright (c) - 2012--2015 - IMDEA Software Institute
 * Copyright (c) - 2012--2015 - Inria
 * 
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

(* -------------------------------------------------------------------- *)
require import Int Fun Pred.
require Ring.

pragma +implicits.

(* -------------------------------------------------------------------- *)
pred homo2 ['a 'b] (op_ : 'a -> 'b) (aR : 'a rel) (rR : 'b rel) =
  forall x y, aR x y => rR (op_ x) (op_ y).

pred mono2 ['a 'b] (op_ : 'a -> 'b) (aR : 'a rel) (rR : 'b rel) =
  forall x y, rR (op_ x) (op_ y) <=> aR x y.

lemma mono2W f (aR : 'a rel) (rR : 'b rel) :
  mono2 f aR rR => homo2 f aR rR.
proof. by move=> + x y - ->. qed.

lemma monoLR ['a 'b] f g (aR : 'a rel) (rR : 'b rel) :
  cancel g f => mono2 f aR rR => forall x y,
    rR (f x) y <=> aR x (g y).
proof. by move=> can_gf mf x y; rewrite -{1}can_gf mf. qed.

lemma monoRL ['a 'b] f g (aR : 'a rel) (rR : 'b rel) :
  cancel g f => mono2 f aR rR => forall x y,
    rR x (f y) <=> aR (g x) y.
proof. by move=> can_gf mf x y; rewrite -{1}can_gf mf. qed.

(* -------------------------------------------------------------------- *)
type t.

clone import Ring.IDomain as Domain with type t <- t.

op "`|_|" : t -> t.
op ( <= ) : t -> t -> bool.
op ( <  ) : t -> t -> bool.

theory Axioms.
  axiom nosmt ler_norm_add (x y : t): `|x + y| <= `|x| + `|y|.
  axiom nosmt addr_gt0     (x y : t): zeror < x => zeror < y => zeror < (x + y).
  axiom nosmt norm_eq0     (x   : t): `|x| = zeror => x = zeror.
  axiom nosmt ger_leVge    (x y : t): zeror <= x => zeror <= y => (x <= y) \/ (y <= x).
  axiom nosmt normrM       (x y : t): `|x * y| = `|x| * `|y|.
  axiom nosmt ler_def      (x y : t): x <= y <=> `|y - x| = y - x.
  axiom nosmt ltr_def      (x y : t): x < y <=> (y <> x) /\ x <= y.
end Axioms.

lemma nosmt ler_norm_add (x y : t): `|x + y| <= `|x| + `|y|.
proof. by apply/Axioms.ler_norm_add. qed.

lemma nosmt addr_gt0 (x y : t): zeror < x => zeror < y => zeror < x + y.
proof. by apply/Axioms.addr_gt0. qed.

lemma nosmt normr0_eq0 (x : t): `|x| = zeror => x = zeror.
proof. by apply/Axioms.norm_eq0. qed.

lemma nosmt ger_leVge (x y : t):
  zeror <= x => zeror <= y => (x <= y) \/ (y <= x).
proof. by apply/Axioms.ger_leVge. qed.

lemma nosmt normrM (x y : t): `|x * y| = `|x| * `|y|.
proof. by apply/Axioms.normrM. qed.

lemma nosmt ler_def (x y : t): (x <= y) <=> (`|y - x| = y - x).
proof. by apply/Axioms.ler_def. qed.

lemma nosmt ltr_def (x y : t): (x < y) <=> (y <> x) /\ (x <= y).
proof. by apply/ Axioms.ltr_def. qed.

lemma ger0_def (x : t): (zeror <= x) <=> (`|x| = x).
proof. by rewrite ler_def subr0. qed.

lemma subr_ge0 (x y : t): (zeror <= x - y) <=> (y <= x).
proof. by rewrite ger0_def -ler_def. qed.

lemma oppr_ge0 (x : t): (zeror <= -x) <=> (x <= zeror).
proof. by rewrite -sub0r subr_ge0. qed.

lemma ler01: zeror <= oner.
proof.                        (* FIXME: anomaly with (inj_eq mulfI) *)
have n1_nz: `|oner| <> zeror by apply/(contraNneq _ oner_neq0) => /normr0_eq0->.
rewrite ger0_def; have /inj_eq <- := mulfI _ n1_nz.
by rewrite -normrM !mulr1.
qed.

lemma ltr01: zeror < oner.
proof. by rewrite ltr_def oner_neq0 ler01. qed.

lemma ltrW (x y : t): x < y => x <= y.
proof. by rewrite ltr_def. qed.

lemma nosmt lerr (x : t): x <= x.
proof.
have n2: `|ofint 2| = (ofint 2).
  rewrite -ger0_def @(ofintS 1) // ofint1 ltrW //.
  by rewrite addr_gt0 ?ltr01.
rewrite ler_def subrr -(inj_eq (addrI `|zeror|)) /= addr0.
by rewrite -mulr2z -mulr_intr -n2 -normrM mul0r.
qed.

lemma nosmt ltrr (x : t): !(x < x).
proof. by rewrite ltr_def. qed.

lemma nosmt ltr_neqAle (x y : t):
  (x < y) <=> (x <> y) /\ (x <= y).
proof. by rewrite ltr_def eq_sym. qed.

lemma nosmt ler_eqVlt (x y : t):
  (x <= y) <=> (x = y) \/ (x < y).
proof. by rewrite ltr_neqAle; case: (x = y)=> // ->; rewrite lerr. qed.

lemma nosmt lt0r (x : t):
  (zeror < x) <=> (x <> zeror) /\ (zeror <= x).
proof. by rewrite ltr_def. qed.

lemma nosmt le0r (x : t):
  (zeror <= x) <=> (x = zeror) \/ (zeror < x).
proof. by rewrite ler_eqVlt eq_sym. qed.

lemma nosmt addr_ge0 (x y : t):
  zeror <= x => zeror <= y => zeror <= x + y.
proof.
rewrite le0r; case=> [->|gt0x]; rewrite ?add0r // le0r.
by case=> [->|gt0y]; rewrite ltrW ?addr0 ?addr_gt0.
qed.

lemma nosmt lt0r_neq0 (x : t):
  zeror < x => (x <> zeror).
proof. by rewrite lt0r; case (_ = _). qed.

lemma nosmt ltr0_neq0 (x : t):
  zeror < x => (x <> zeror).
proof. by rewrite lt0r; case: (_ = _). qed.

lemma nosmt gtr_eqF (x y : t):
  y < x => (x <> y).
proof. by rewrite ltr_def => []. qed.

lemma nosmt ltr_eqF (x y : t):
  x < y => (x <> y).
proof. by rewrite eq_sym=> /gtr_eqF ->. qed.

lemma ler0n n : 0 <= n => zeror <= ofint n.
proof.
elim: n => [|n ih h]; first by rewrite mulr0z lerr.
by rewrite ofintS // addr_ge0 // ?ler01.
qed.

lemma ltr0Sn n : 0 <= n => zeror < ofint (n + 1).
proof.
elim: n=> /= [|n ge0n ih]; first by rewrite ofint1 ltr01.
by rewrite ofintS // ?(addz_ge0, addr_gt0) // ltr01.
qed.

lemma ltr0n n : 0 <= n => (zeror < ofint n) = (0 < n).
proof.
elim: n => [|n ge0n _]; first by rewrite mulr0z ltrr.
by rewrite ltr0Sn // ltz_def addz_ge0 ?addz1_neq0.
qed.

lemma pnatr_eq0 n : 0 <= n => (ofint n = zeror) <=> (n = 0).
proof.
elim: n => [|n ge0n _]; rewrite ?mulr0z // gtr_eqF.
  by rewrite ltr0Sn. by rewrite addz1_neq0.
qed.

lemma nosmt pmulr_rgt0 (x y : t):
  zeror < x => (zeror < x * y) <=> (zeror < y).
proof.
rewrite !ltr_def !ger0_def normrM mulf_eq0 -nor.
by case=> ^nz_x -> -> /=; have /inj_eq -> := mulfI _ nz_x.
qed.

lemma nosmt pmulr_rge0 (x y : t):
  zeror < x => (zeror <= x * y) <=> (zeror <= y).
proof.
rewrite !le0r mulf_eq0; case: (y = _) => //= ^lt0x.
by move/lt0r_neq0=> -> /=; apply/pmulr_rgt0.
qed.

lemma nosmt normr_idP (x : t): (`|x| = x) <=> (zeror <= x).
proof. by rewrite ger0_def. qed.

lemma nosmt ger0_norm (x : t): zeror <= x => `|x| = x.
proof. by apply/normr_idP. qed.

lemma nosmt normr0: `|zeror| = zeror.
proof. by apply/ger0_norm/lerr. qed.

lemma nosmt normr1: `|oner| = oner.
proof. by apply/ger0_norm/ler01. qed.

lemma nosmt normr0P (x : t): (`|x| = zeror) <=> (x = zeror).
proof. by split=> [/normr0_eq0|->] //; rewrite normr0. qed.

lemma nosmt normrN1: `|-oner| = oner.
proof.
(*
have: `|-1| ^+ 2 == 1 :> R by rewrite -normrX -signr_odd normr1.
rewrite sqrf_eq1 => /orP[/eqP //|]; rewrite -ger0_def le0r oppr_eq0 oner_eq0.
by move/(addr_gt0 ltr01); rewrite subrr ltrr.
*)
admitted.

lemma nosmt normrN (x : t): `|- x| = `|x|.
proof. by rewrite -mulN1r normrM normrN1 mul1r. qed.

lemma nosmt distrC (x y : t): `|x - y| = `|y - x|.
proof. by rewrite -opprB normrN. qed.

lemma nosmt ler0_def (x : t): (x <= zeror) <=> (`|x| = - x).
proof. by rewrite ler_def sub0r normrN. qed.

lemma nosmt normr_id (x : t): `| `|x| | = `|x|.
proof.
(*
have nz2: 2%:R != 0 :> R by rewrite pnatr_eq0.
apply: (mulfI nz2); rewrite -{1}normr_nat -normrM mulr_natl mulr2n ger0_norm //.
by rewrite -{2}normrN -normr0 -(subrr x) ler_norm_add.
*)
admitted.

lemma nosmt normr_ge0 (x : t): zeror <= `|x|.
proof. by rewrite ger0_def normr_id. qed.

lemma nosmt ler0_norm (x : t): x <= zeror => `|x| = - x.
proof.
move=> x_le0; rewrite eq_sym -@(ger0_norm (-x)).
  by rewrite oppr_ge0. by rewrite normrN.
qed.

lemma nosmt gtr0_norm (x : t): zeror < x => `|x| = x.
proof. by move/ltrW/ger0_norm. qed.

lemma nosmt ltr0_norm (x : t): x < zeror => `|x| = - x.
proof. by move/ltrW/ler0_norm. qed.

lemma nosmt subr_gt0 (x y : t): (zeror < y - x) <=> (x < y).
proof. by rewrite !ltr_def subr_eq0 subr_ge0. qed.

lemma nosmt subr_le0 (x y : t): (y - x <= zeror) <=> (y <= x).
proof. by rewrite -subr_ge0 subrE opprB add0r subr_ge0. qed.

lemma nosmt subr_lt0 (x y : t): (y - x < zeror) <=> (y < x).
proof. by rewrite -subr_gt0 subrE opprB add0r subr_gt0. qed.

lemma nosmt ler_asym (x y : t): x <= y <= x => x = y.
proof.
rewrite !ler_def distrC -opprB -addr_eq0 => [->].
by rewrite -mulr2z -mulr_intl mulf_eq0 subr_eq0 pnatr_eq0.
qed.

lemma nosmt eqr_le (x y : t): (x = y) <=> (x <= y <= x).
proof. by split=> [->|/ler_asym]; rewrite ?lerr. qed.

lemma nosmt ltr_trans (y x z : t): x < y => y < z => x < z.
proof.
move=> le_xy le_yz; rewrite -subr_gt0 -@(subrK z y).
by rewrite !subrE -addrA addr_gt0 -?subrE ?subr_gt0.
qed.

lemma nosmt ler_lt_trans (y x z : t): x <= y => y < z => x < z.
proof. by rewrite !ler_eqVlt => [-> //|/ltr_trans h]; apply/h. qed.

lemma nosmt ltr_le_trans (y x z : t): x < y => y <= z => x < z.
proof. by rewrite !ler_eqVlt => lxy [<- //|lyz]; apply @(ltr_trans y). qed.

lemma nosmt ler_trans (y x z : t): x <= y => y <= z => x <= z.
proof.
rewrite !ler_eqVlt => [-> //|lxy] [<-|].
  by rewrite lxy. by move/(ltr_trans _ _ _ lxy) => ->.
qed.

lemma nosmt ltr_asym (x y : t): ! (x < y < x).
proof. by apply/negP=> -[/ltr_trans hyx /hyx]; rewrite ltrr. qed.

lemma ler_anti (x y : t): x <= y <= x => x = y.
proof. by rewrite -eqr_le. qed.

lemma nosmt ltr_le_asym (x y : t): ! (x < y <= x).
proof. admit. qed.

lemma nosmt ler_lt_asym (x y : t):
  ! (x <= y < x).
proof. by rewrite anda_and andC -anda_and ltr_le_asym. qed.

lemma nosmt ltr_geF (x y : t): x < y => ! (y <= x).
proof. by move=> xy; apply/negP => /(ltr_le_trans _ _ _ xy); rewrite ltrr. qed.

lemma nosmt ler_gtF (x y : t): x <= y => ! (y < x).
proof. by move=> le_xy; apply/negP=> /ltr_geF. qed.

lemma nosmt ltr_gtF (x y : t): x < y => ! (y < x).
proof. by move/ltrW/ler_gtF. qed.

lemma nosmt normr_le0 (x : t): (`|x| <= zeror) <=> (x = zeror).
proof. by rewrite -normr0P eqr_le normr_ge0. qed.

lemma nosmt normr_lt0 (x : t): ! (`|x| < zeror).
proof. by rewrite ltr_neqAle normr_le0 normr0P; case: (_ = _). qed.

lemma nosmt normr_gt0 (x : t): (zeror < `|x|) <=> (x <> zeror).
proof. by rewrite ltr_def normr0P normr_ge0; case: (_ = _). qed.

(* -------------------------------------------------------------------- *)
lemma nosmt mono_inj f : mono2 f (<=) (<=) => injective f.
proof. by move=> mf x y; rewrite eqr_le !mf -eqr_le. qed.

lemma nosmt nmono_inj f : mono2 f (fun y x => x <= y) (<=) => injective f.
proof. by move=> mf x y; rewrite eqr_le !mf -eqr_le. qed.

lemma nosmt lerW_mono f : mono2 f (<=) (<=) => mono2 f (<) (<).
proof.
move=> mf x y; rewrite !ltr_neqAle mf.
by rewrite inj_eq //; apply/mono_inj.
qed.

lemma nosmt lerW_nmono f : mono2 f (fun y x => x <= y) (<=) =>
  mono2 f (fun y x => x < y) (<).
proof.
move=> mf x y; rewrite !ltr_neqAle mf eq_sym.
by rewrite inj_eq //; apply/nmono_inj.
qed.

(* -------------------------------------------------------------------- *)
lemma nosmt ler_opp2 (x y : t): (-x <= -y) <=> (y <= x).
proof. by rewrite -subr_ge0 subrE opprK addrC -subrE subr_ge0. qed.

lemma nosmt ltr_opp2 (x y : t): (-x < -y) <=> (y < x).
proof. by rewrite lerW_nmono //; apply/ler_opp2. qed.

lemma nosmt ler_oppr (x y : t): (x <= - y) <=> (y <= - x).
proof. by rewrite (monoRL opprK ler_opp2). qed.

hint rewrite lter_opp2 : ler_opp2 ltr_opp2.

lemma nosmt ltr_oppr (x y : t): (x < - y) <=> (y < - x).
proof.                          (* FIXME *)
by apply/@(monoRL _ _ (fun y x => x < y) (<) opprK)/lerW_nmono/ler_opp2.
qed.

lemma nosmt ler_oppl (x y : t):
  (- x <= y) <=> (- y <= x).
proof. by rewrite (monoLR opprK ler_opp2). qed.

lemma nosmt ltr_oppl (x y : t):
  (- x < y) <=> (- y < x).
proof.                          (* FIXME *)
by apply/@(monoLR _ _ (fun y x => x < y) (<) opprK)/lerW_nmono/ler_opp2.
qed.

lemma nosmt oppr_gt0 (x : t): (zeror < - x) <=> (x < zeror).
proof. by rewrite ltr_oppr oppr0. qed.

lemma nosmt oppr_le0 (x : t): (- x <= zeror) <=> (zeror <= x).
proof. by rewrite ler_oppl oppr0. qed.

lemma nosmt oppr_lt0 (x : t): (- x < zeror) <=> (zeror < x).
proof. by rewrite ltr_oppl oppr0. qed.

hint rewrite oppr_cp : oppr_le0 oppr_lt0 oppr_ge0 oppr_gt0.

lemma nosmt ler_leVge (x y : t):
  x <= zeror => y <= zeror => (x <= y) \/ (y <= x).
proof. by rewrite -!oppr_ge0 => /(ger_leVge _) h /h; rewrite !ler_opp2 orbC. qed.

lemma ler_add2l (x y z : t) : (z + x <= z + y) <=> (x <= y).
proof. by rewrite -subr_ge0 subrE opprD addrAC addNKr addrC -subrE subr_ge0. qed.

lemma ler_add2r (x y z : t) : (x + z <= y + z) <=> (x <= y).
proof. by rewrite !@(addrC _ z) ler_add2l. qed.

lemma nosmt ltr_add2r (z x y : t): (x + z < y + z) <=> (x < y).
proof.                          (* FIXME *)
by apply/@(lerW_mono (fun t => t + z))=> {x y} x y; apply ler_add2r.
qed.

lemma nosmt ltr_add2l (z x y : t): (z + x < z + y) <=> (x < y).
proof.
by apply/@(lerW_mono ((+) z)) => {x y} x y; apply ler_add2l.
qed.

hint rewrite ler_add2  : ler_add2l ler_add2r.
hint rewrite ltr_add2  : ltr_add2l ltr_add2r.
hint rewrite lter_add2 : ler_add2l ler_add2r ltr_add2l ltr_add2r.

lemma nosmt ler_add (x y z t : t):
  x <= y => z <= t => x + z <= y + t.
proof. by move=> xy zt; rewrite @(ler_trans (y + z)) ?lter_add2. qed.

lemma nosmt ler_lt_add (x y z t : t):
  x <= y => z < t => x + z < y + t.
proof. by move=> xy zt; rewrite @(ler_lt_trans (y + z)) ?lter_add2. qed.

lemma nosmt ltr_le_add (x y z t : t):
  x < y => z <= t => x + z < y + t.
proof. by move=> xy zt; rewrite @(ltr_le_trans (y + z)) ?lter_add2. qed.

lemma nosmt ltr_add (x y z t : t): x < y => z < t => x + z < y + t.
proof. by move=> xy zt; rewrite ltr_le_add // ltrW. qed.

lemma nosmt ler_sub (x y z t : t):
  x <= y => t <= z => x - z <= y - t.
proof. by move=> xy tz; rewrite !subrE ler_add ?lter_opp2. qed.

lemma nosmt ler_lt_sub (x y z t : t):
  x <= y => t < z => x - z < y - t.
proof. by move=> xy zt; rewrite !subrE ler_lt_add ?lter_opp2. qed.

lemma nosmt ltr_le_sub (x y z t : t):
  x < y => t <= z => x - z < y - t.
proof. by move=> xy zt; rewrite !subrE ltr_le_add ?lter_opp2. qed.

lemma nosmt ltr_sub (x y z t : t):
  x < y => t < z => x - z < y - t.
proof. by move=> xy tz; rewrite !subrE ltr_add ?lter_opp2. qed.

lemma nosmt ler_subl_addr (x y z : t):
  (x - y <= z) <=> (x <= z + y).
proof. admit. qed.

lemma nosmt ltr_subl_addr (x y z : t):
  (x - y < z) <=> (x < z + y).
proof. admit. qed.

lemma nosmt ler_subr_addr (x y z : t):
  (x <= y - z) <=> (x + z <= y).
proof. admit. qed.

lemma nosmt ltr_subr_addr (x y z : t):
  (x < y - z) <=> (x + z < y).
proof. admit. qed.

lemma nosmt ler_subl_addl (x y z : t):
  (x - y <= z) <=> (x <= y + z).
proof. admit. qed.

lemma nosmt ltr_subl_addl (x y z : t):
  (x - y < z) <=> (x < y + z).
proof. admit. qed.

lemma nosmt ler_subr_addl (x y z : t):
  (x <= y - z) <=> (z + x <= y).
proof. admit. qed.

lemma nosmt ltr_subr_addl (x y z : t):
  (x < y - z) <=> (z + x < y).
proof. admit. qed.

lemma nosmt ler_addl (x y : t):
  (x <= x + y) <=> (zeror <= y).
proof. admit. qed.

lemma nosmt ltr_addl (x y : t):
  (x < x + y) <=> (zeror < y).
proof. admit. qed.

lemma nosmt ler_addr (x y : t):
  (x <= y + x) <=> (zeror <= y).
proof. admit. qed.

lemma nosmt ltr_addr (x y : t):
  (x < y + x) <=> (zeror < y).
proof. admit. qed.

lemma nosmt ger_addl (x y : t):
  (x + y <= x) <=> (y <= zeror).
proof. admit. qed.

lemma nosmt gtr_addl (x y : t):
  (x + y < x) <=> (y < zeror).
proof. admit. qed.

lemma nosmt ger_addr (x y : t):
  (y + x <= x) <=> (y <= zeror).
proof. admit. qed.

lemma nosmt gtr_addr (x y : t):
  (y + x < x) <=> (y < zeror).
proof. admit. qed.

lemma nosmt ler_paddl (y x z : t):
  zeror <= x => y <= z => y <= x + z.
proof. admit. qed.

lemma nosmt ltr_paddl (y x z : t):
  zeror <= x => y < z => y < x + z.
proof. admit. qed.

lemma nosmt ltr_spaddl (y x z : t):
  zeror < x => y <= z => y < x + z.
proof. admit. qed.

lemma nosmt ltr_spsaddl (y x z : t):
  zeror < x => y < z => y < x + z.
proof. admit. qed.

lemma nosmt ler_naddl (y x z : t):
  x <= zeror => y <= z => x + y <= z.
proof. admit. qed.

lemma nosmt ltr_naddl (y x z : t):
  x <= zeror => y < z => x + y < z.
proof. admit. qed.

lemma nosmt ltr_snaddl (y x z : t):
  x < zeror => y <= z => x + y < z.
proof. admit. qed.

lemma nosmt ltr_snsaddl (y x z : t):
  x < zeror => y < z => x + y < z.
proof. admit. qed.

lemma nosmt ler_paddr (y x z : t):
  zeror <= x => y <= z => y <= z + x.
proof. admit. qed.

lemma nosmt ltr_paddr (y x z : t):
  zeror <= x => y < z => y < z + x.
proof. admit. qed.

lemma nosmt ltr_spaddr (y x z : t):
  zeror < x => y <= z => y < z + x.
proof. admit. qed.

lemma nosmt ltr_spsaddr (y x z : t):
  zeror < x => y < z => y < z + x.
proof. admit. qed.

lemma nosmt ler_naddr (y x z : t):
  x <= zeror => y <= z => y + x <= z.
proof. admit. qed.

lemma nosmt ltr_naddr (y x z : t):
  x <= zeror => y < z => y + x < z.
proof. admit. qed.

lemma nosmt ltr_snaddr (y x z : t):
  x < zeror => y <= z => y + x < z.
proof. admit. qed.

lemma nosmt ltr_snsaddr (y x z : t):
  x < zeror => y < z => y + x < z.
proof. admit. qed.

lemma nosmt paddr_eq0 (x y : t):
  zeror <= x => zeror <= y => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

lemma nosmt naddr_eq0 (x y : t):
  x <= zeror => y <= zeror => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

lemma nosmt addr_ss_eq0 (x y : t):
        (zeror <= x    ) /\ (zeror <= y    )
     \/ (x     <= zeror) /\ (y     <= zeror)
  => (x + y = zeror) <=> (x = zeror) /\ (y = zeror).
proof. admit. qed.

lemma nosmt ler_pmul2l x : zeror < x => forall y z, (y <= z) <=> (x * y <= x * z).
proof. admit. qed.

lemma nosmt ler_pmul2r x : zeror < x => forall y z, (y <= z) <=> (y * x <= z * x).
proof. admit. qed.

lemma nosmt ltr_pmul2l x : zeror < x => forall y z, (y < z) <=> (x * y < x * z).
proof. admit. qed.

lemma nosmt ltr_pmul2r x : zeror < x => forall y z, (y < z) <=> (y * x < z * x).
proof. admit. qed.

lemma nosmt ler_pmul (x1 y1 x2 y2 : t):
  zeror <= x1 => zeror <= x2 => x1 <= y1 => x2 <= y2 => x1 * x2 <= y1 * y2.
proof. admit. qed.

lemma nosmt ltr_pmul (x1 y1 x2 y2 : t):
  zeror <= x1 => zeror <= x2 => x1 < y1 => x2 < y2 => x1 * x2 < y1 * y2.
proof. admit. qed.

lemma nosmt ltrNge (x y : t): (x < y) <=> !(y <= x).
proof. admit. qed.

lemma nosmt ltrN10: -oner < zeror.
proof. by rewrite oppr_lt0 ltr01. qed.

lemma nosmt lerN10: -oner <= zeror.
proof. by rewrite oppr_le0 ler01. qed.

lemma nosmt ltr0N1: !(zeror < -oner).
proof. by rewrite ler_gtF // lerN10. qed.

lemma nosmt ler0N1: !(zeror <= -oner).
proof. by rewrite ltr_geF // ltrN10. qed.

lemma nosmt pmulr_rlt0 (x y : t):
  zeror < x => (x * y < zeror) <=> (y < zeror).
proof.
by move=> x_gt0; rewrite -oppr_gt0 -mulrN pmulr_rgt0 // oppr_gt0.
qed.

lemma nosmt pmulr_rle0 (x y : t):
  zeror < x => (x * y <= zeror) <=> (y <= zeror).
proof.
by move=> x_gt0; rewrite -oppr_ge0 -mulrN pmulr_rge0 // oppr_ge0.
qed.

lemma nosmt pmulr_lgt0 (x y : t):
  zeror < x => (zeror < y * x) <=> (zeror < y).
proof. by move=> x_gt0; rewrite mulrC pmulr_rgt0. qed.

lemma nosmt pmulr_lge0 (x y : t):
  zeror < x => (zeror <= y * x) <=> (zeror <= y).
proof. by move=> x_gt0; rewrite mulrC pmulr_rge0. qed.

lemma nosmt pmulr_llt0 (x y : t):
  zeror < x => (y * x < zeror) <=> (y < zeror).
proof. by move=> x_gt0; rewrite mulrC pmulr_rlt0. qed.

lemma nosmt pmulr_lle0 (x y : t):
  zeror < x => (y * x <= zeror) <=> (y <= zeror).
proof. by move=> x_gt0; rewrite mulrC pmulr_rle0. qed.

lemma nosmt nmulr_rgt0 (x y : t):
  x < zeror => (zeror < x * y) <=> (y < zeror).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rgt0 oppr_cp. qed.

lemma nosmt nmulr_rge0 (x y : t):
  x < zeror => (zeror <= x * y) <=> (y <= zeror).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rge0 oppr_cp. qed.

lemma nosmt nmulr_rlt0 (x y : t):
  x < zeror => (x * y < zeror) <=> (zeror < y).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rlt0 oppr_cp. qed.

lemma nosmt nmulr_rle0 (x y : t):
  x < zeror => (x * y <= zeror) <=> (zeror <= y).
proof. by move=> x_lt0; rewrite -mulrNN pmulr_rle0 oppr_cp. qed.

lemma nosmt nmulr_lgt0 (x y : t):
  x < zeror => (zeror < y * x) <=> (y < zeror).
proof. by move=> x_lt0; rewrite mulrC nmulr_rgt0. qed.

lemma nosmt nmulr_lge0 (x y : t):
  x < zeror => (zeror <= y * x) <=> (y <= zeror).
proof. by move=> x_lt0; rewrite mulrC nmulr_rge0. qed.

lemma nosmt nmulr_llt0 (x y : t):
  x < zeror => (y * x < zeror) <=> (zeror < y).
proof. by move=> x_lt0; rewrite mulrC nmulr_rlt0. qed.

lemma nosmt nmulr_lle0 (x y : t):
  x < zeror => (y * x <= zeror) <=> (zeror <= y).
proof. by move=> x_lt0; rewrite mulrC nmulr_rle0. qed.

lemma nosmt mulr_ge0 (x y : t):
  zeror <= x => zeror <= y => zeror <= x * y.
proof. admit. qed.

lemma nosmt mulr_le0 (x y : t):
  x <= zeror => y <= zeror => zeror <= x * y.
proof. admit. qed.

lemma nosmt mulr_ge0_le0 (x y : t):
  zeror <= x => y <= zeror => x * y <= zeror.
proof. admit. qed.

lemma nosmt mulr_le0_ge0 (x y : t):
  x <= zeror => zeror <= y => x * y <= zeror.
proof. admit. qed.

lemma nosmt mulr_gt0 (x y : t):
  zeror < x => zeror < y => zeror < x * y.
proof. by move=> x_gt0 y_gt0; rewrite pmulr_rgt0. qed.

lemma nosmt ger_pmull (x y : t):
  zeror < y => (x * y <= y) <=> (x <= oner).
proof. admit. qed.

lemma nosmt gtr_pmull (x y : t):
  zeror < y => (x * y < y) <=> (x < oner).
proof. admit. qed.

lemma nosmt ger_pmulr (x y : t):
  zeror < y => (y * x <= y) <=> (x <= oner).
proof. admit. qed.

lemma nosmt gtr_pmulr (x y : t):
  zeror < y => (y * x < y) <=> (x < oner).
proof. admit. qed.

lemma nosmt ler_nmull (x y : t):
  y < zeror => (y <= x * y) <=> (x <= oner).
proof. admit. qed.

lemma nosmt ltr_nmull (x y : t):
  y < zeror => (y < x * y) <=> (x < oner).
proof. admit. qed.

lemma nosmt ler_nmulr (x y : t):
  y < zeror => (y <= y * x) <=> (x <= oner).
proof. admit. qed.

lemma nosmt ltr_nmulr (x y : t):
  y < zeror => (y < y * x) <=> (x < oner).
proof. admit. qed.

lemma nosmt ler_pimull (x y : t):
  zeror <= y => x <= oner => x * y <= y.
proof. admit. qed.

lemma nosmt ler_nimull (x y : t):
  y <= zeror => x <= oner => y <= x * y.
proof. admit. qed.

lemma nosmt ler_pimulr (x y : t):
  zeror <= y => x <= oner => y * x <= y.
proof. admit. qed.

lemma nosmt ler_nimulr (x y : t):
  y <= zeror => x <= oner => y <= y * x.
proof. admit. qed.

lemma nosmt mulr_ile1 (x y : t):
  zeror <= x => zeror <= y => x <= oner => y <= oner => x * y <= oner.
proof. admit. qed.

lemma nosmt mulr_ilt1 (x y : t):
  zeror <= x => zeror <= y => x < oner => y < oner => x * y < oner.
proof. admit. qed.

lemma nosmt invr_gt0 (x : t):
  (zeror < invr x) <=> (zeror < x).
proof. admit. qed.

lemma nosmt invr_ge0 (x : t):
  (zeror <= invr x) <=> (zeror <= x).
proof. admit. qed.

lemma nosmt invr_lt0 (x : t):
  (invr x < zeror) <=> (x < zeror).
proof. admit. qed.

lemma nosmt invrr_le0 (x : t):
  (invr x <= zeror) <=> (x <= zeror).
proof. admit. qed.

lemma nosmt divr_ge0 (x y : t):
  zeror <= x => zeror <= y => zeror <= x / y.
proof. admit. qed.

lemma nosmt divr_gt0 (x y : t):
  zeror < x => zeror < y => zeror < x / y.
proof. admit. qed.

lemma nosmt ler_norm_sub (x y : t):
  `|x - y| <= `|x| + `|y|.
proof. admit. qed.

lemma nosmt ler_dist_add (z x y : t):
  `|x - y| <= `|x - z| + `|z - y|.
proof. admit. qed.

lemma nosmt ler_sub_norm_add (x y : t):
  `|x| - `|y| <= `|x + y|.
proof. admit. qed.

lemma nosmt ler_sub_dist (x y : t):
  `|x| - `|y| <= `|x - y|.
proof. admit. qed.

lemma nosmt ler_dist_dist (x y : t):
  `| `|x| - `|y| | <= `|x - y|.
proof. admit. qed.

lemma nosmt ler_dist_norm_add (x y : t):
  `| `|x| - `|y| | <= `|x + y|.
proof. by rewrite -@(opprK y) normrN -subrE ler_dist_dist. qed.

lemma nosmt ler_nnorml (x y : t): y < zeror => ! (`|x| <= y).
proof. by move=> y_lt0; rewrite ltr_geF // (ltr_le_trans y_lt0) ?normr_ge0. qed.

lemma nosmt ltr_nnorml (x y : t): y <= zeror => ! (`|x| < y).
proof. by move=> y_le0; rewrite ler_gtF // (ler_trans y_le0) ?normr_ge0. qed.

lemma nosmt eqr_norm_id (x : t): (`|x| = x) <=> (zeror <= x).
proof. by rewrite ger0_def. qed.

lemma nosmt eqr_normN (x : t): (`|x| = - x) <=> (x <= zeror).
proof. by rewrite ler0_def. qed.

