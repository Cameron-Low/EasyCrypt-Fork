\documentclass[11pt]{article}

 \usepackage[utf8]{inputenc}

  \usepackage{xspace}
  \usepackage{enumerate}
 \usepackage{paralist}
\usepackage{bussproofs}

\usepackage{cite}
\usepackage{amsmath}
\usepackage{amsthm,amsfonts}

 \usepackage{proof}
  \usepackage{bbm}

 \usepackage{url}

 \usepackage{fullpage}

 \usepackage{graphicx}

\renewcommand{\textit}[1]{ $<$#1$>$}


\begin{document}

%\newcommand{kw}[1]{\ensuremath{ \mathbf{#1}}}
%\newcommand{choose}[1]{\ensuremath{ \mathit{#1}}}

\title{Draft For CIL Mode}
\maketitle

\section{System}

Definition of a system:

A system is a set of oracles, amongst which 
initialization and finalization oracles, which share a
state updated at each query.

To specify a system, one has to give (in this order):
\begin{itemize}
\item the system name \textit{sysname}
\item the type of the system state;
\item the oracles:
  \begin{itemize}
  \item the initialization oracle, 
  \item oracles which are not initialization nor finalization, called
classic oracles,
  \item the finalization oracle.
  \end{itemize}
\end{itemize}

Syntax of definition of a system:

\textbf{system} \textit{sysname} \\
\textbf{state\_type} \textit{type\_of\_the\_state}\\
\textbf{init\_state} \textit{init\_state\_value}\\
\textbf{init\_oracle : } \textit{output\_type\_of\_init\_oracle} 
\textbf{=}
\textit{implementation\_of\_init}\\
\textit{classic\_oracle\_declaration}\\
$\dots$\\
\textbf{final\_oracle : } \textit{input\_type\_of\_final\_oracle} \textbf{=}
\textit{implementation\_of\_final}\\

Syntax of classic oracle declaration:\\
\textbf{oracle } \textit{name\_of\_oracle} \textbf{(} input
\textbf{: }\textit{type\_of \_input} \textbf{) : } result
\textbf{=}\\ \textit{implementation}\\

where implementation contains no assignment in input or return command,
or any variable named stock, inst or tr or st. 

When a system is declared in CIL-mode, it yields declarations in easycrypt
for:

\begin{itemize}
\item the type of states extended with a component
to store traces, named state\_\textit{sysname};
\item the type declaration for trace trace\_\textit{sysname} (TODO: give details about that)
\item a function to represent the initialization oracle as:\\
 
fun init : \textit{output\_type\_of\_init\_oracle} =\\
\{\textit{implementation\_of\_init where before return key word the trace is updated}\}

and type declaration:\\

type output\_type\_init : \textit{output\_type\_of\_init\_oracle}
\item for each classic oracle a function : 

 fun \textit{name\_of\_oracle} ( input : 
\textit{type\_of \_input}) : \\ \textit{type\_of\_output}  = \\
\{\textit{stock:= st; implementation ; (tr:= tr @ ((\textit{name\_of\_oracle}, input, result)) ; return result}\}

and two type declarations 

type input\_type\_\textit{name\_of\_oracle} : \textit{type\_of \_input}
type output\_type\_\textit{name\_of\_oracle} : \textit{type\_of \_output}
\item a function for the finalization oracle as: 

fun final( \textit{name\_of\_input\_var} :
\textit{input\_type\_of\_final\_oracle},
inst : state\_\textit{sysname}) : state\_\textit{sysname} * trace\_\textit{sysname}  =\\
\{\textit{implementation\_of\_final where before return key word the trace is updated}\}

and the type declaration\\
type input\_type\_final : \textit{type\_of \_input\_of\_final\_oracle}

\item a matching adversary as:

adversary  A( \textit{name\_of\_var} : 
\textit{output\_type\_of\_init\_oracle} )  : 
\textit{input\_type\_of\_final\_oracle}
 \{ \textit{type\_of \_input $\rightarrow$ type\_of\_output} (for each classic
oracle provided) \}.

\item a matching game: 

(* here are all type declarations listed above\\ *)
game G\_{\textit{sysname}} = \{ \\
var st : state\_\textit{sysname} ; \\
var tr : trace\_\textit{sysname}; \\
declaration of init, final and classic oracles implementations; \\
abs A = A \{ collection of all classic oracles \} \\
fun Main (): \textit{input\_type\_of\_final\_oracle} = \{ \\
 var x : \textit{output\_type\_of\_init\_oracle} ; \\
 var y : \textit{input\_type\_of\_final\_oracle} ; \\
 (x,st, tr) = init(\textit{init\_state\_value}); \\
 y = A(x); \\
 (st,tr) = final(y,st,tr); \\
 return (y,st,tr);  \\
\} \\
\}. 
\end{itemize}

TODO : write the game for k-adversaries (nb of queries bounded
by k) 

\section{Events and Judgments}
\subsection{Events}
Step-predicate declaration syntax:

\textbf{predicate} \textit{pred\_name} \textit{sysname} \textit{oracle\_name} : 
boolean formula involving a variable q of the input type of oracle
\textit{oracle\_name}, 
a variable a of the output type of oracle
\textit{oracle\_name}, 
and two states m and m' of type state\_type\_\textit{sysname}

Raises the problem of notation m.List, m.variable.... we cannot put 
only variable names if it can be in m or m'. 

This predicate declaration yields easycrypt declaration:

pred \textit{pred\_name} (q:  input\_type\_\textit{name\_of\_oracle},
a: output\_type\_\textit{name\_of\_oracle}, m,m' : state\_\textit{sysname}) =
the same formula.

Once we have the predicates, events are given by the
grammar
event := (Always \textit{predicate}),\textit{sysname}) | (Eventually \textit{predicate},\textit{sysname}) |
(\textit{predicate} Until \textit{predicate},\textit{sysname})  | event and  event | event or  event | (!event).

which translate in easycrypt as: 

??

\subsection{Judgments}
Judgment $system1 \sim_{\epsilon} system2$ :\\
 
can only be said of systems where \textit{input\_type\_of\_final\_oracle}
is the boolean type.
with $\epsilon$ a real number for the time being.\\

Syntax of declaration : 
\textbf{indis} \textit{system1}  \textit{system2} $\epsilon$

corresponds to easycrypt phrase:\\

$ claim : |G\__{system1}.Main[y] - G\__{system2}.Main[y] | <= \epsilon $\\





Judgment $system :_\epsilon E$

$ claim : |G\__{system}.Main[E(st,tr)]| <= \epsilon $\\

Forward bisimulation $ $

\end{document}
