Verifier les fonction add dans ecEnv.

* Pierre-Yves

- reprendre la partie module -> finir la partie typage
- pretty-printing de l'AST typé
- noeud de meta-info dans les AST typés
- local predicates / operators
- ec échoue sur une erreur système lorsque why3 est configuré pour 0 prouveur.

* Benjamin

tactic : 

  + tactic phl/prhl 
    -
    - eqobs_in
    - not_modify
    - hoare -> equiv
    - inlining
    - derandomize
    - call for adversary
    - rename trivial into prover 
    - use trivial for more sofisticated tactic:
          simplify; intuition; subst; try split;prover  
    - subst should also works for program variable.


  + tactic
    - set 
    - apply avec instanciation automatique +
      apply f   
    - notation apply recursive

  + Why3 : 
    - partage des events (* ie. function annonyme *)
    - netoyage des tasks 
    - base de hint  (* Voir avec francois *)
    - triggers      (* Voir avec francois *)

clone : 
  + finir les toutes les instanciations possibles


* Parsing:
- Nom long pour les operateurs infix, 

* Pretty:
- Affichage des noms long ou cours, ty instance

* TODO
- chemins privés (attendre la fin des modules)

- réfléchir sur le pb d'instanciation de modules
  (=> hypothèses sur adversaire - e.g. pour up-to-bad)
- arbre de preuve + contexte dynamique de preuve
- batterie de tests
- mot-clef "use" + nettoyage de task
- raffinements
- diff. for modules


Discussion :
  semantique de hoare f : p => q 
    forall m, p m => range q [f m]
  ou avoir simplement le range.

  rajouter le assume il y a une semantique facile pour le justifier.

    
  Nomage des variables (path) :
    Variables de programe : 
      Globals            :  th_path :: mod_path :: var_id
      Parameters, Locals :  th_path :: mod_path :: fun_id :: var_id

    Locals (let, forall, exists) : var_id.

  EcEnv doit assurer pas de clach de noms long :
    Variables de programe :
       pas deux variables avec le meme qsymbol 
    Locals : pas de contrainte sur le symbol (seulement des idents different)

    Operateurs : pas deux operateurs avec la meme arite 
                            (on peut etre moin restrictif, type non unifiable)
                 avec le meme qsymbol.
    Type : pas deux type avec le meme qsymbol.

    Module :  pas deux type avec le meme qsymbol
      Question : c'est quoi le path d'un parametre de module :
             F (A:T) = { }
             path de F :: A_id
           
    Module type :  pas deux type avec le meme qsymbol

    On doit pas avoir de theory et de module avec la meme qsymbol ? 
       theory T.
        theory M.
           cnst x : int.
        end M.
        module M = {
           var x : int.
        }.
       end T.  



*** Note de discussion

i_inuse : LvMap `Read ok mais aussi `Write

*** 

 - Les types sont étendus avec un constructeur unaire Tglob.  Tglob(M)
   représente le types des variables globales (en tant que n-uplet) de
   M. Il est incertain si Tglob(M) ne contient que le types des
   variables non connues de M ou non.

 - Les formules sont étendues avec un nouveau constructeur
   représentant les variables globales d'un module dans une mémoire
   donnée:

     Cglob : module x mem -> form

 - Faire l'extension de la substitution en conséquence.

***

 - 
