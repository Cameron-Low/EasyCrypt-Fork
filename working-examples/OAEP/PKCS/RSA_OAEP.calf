def const n : int;

def const hBits : int;

// SHA1 takes bitstrings as strings of octets.
// Packing is BigEndian! This will be hidden.
def hash<(len : int)>(input : unsigned bits[len]) : unsigned bits[hBits] {
    def res :  unsigned bits[hBits];
    return res;
}
 
/* Various lengths */
def const nLen : int;                           /* Size of modulus in octets */
def const nBits : int := 8 * nLen;              /* Bit length of modulus octet representation */
def const dbBits : int  := nBits - hBits - 8;   /* EM := 0x00 || Masked Seed || Masked DB */
def const msgBits : int := dbBits - hBits - 8;  /* DB := lHash || PS || 0x01 || M */
                                                /* We will assume PS is empty */
def const TBits : int;  /* Smallest multiple of hBits >= dbBits */

def RSAFun(e : int, msg : int) : int {
  def c : mod[n];
  c := ( (mod[n]) msg ) **e;
  return (int) c;
}

def RSAInv(d : int, c : int) : int {
  def msg : mod[n];
  msg := ( (mod[n]) c ) ** d;
  return (int) msg;
}

def H(maskedDB : unsigned bits[dbBits]) : unsigned bits[hBits] {
  def hashin : unsigned bits[dbBits + 32];
  def hashout : unsigned bits[hBits];
  def C : unsigned bits[32];
  hashin[32..32+dbBits-1] := maskedDB;
  C := (unsigned bits[32])(0);
  hashin[0..0+32-1] := C;
  hashout := hash(hashin);
  return hashout;
}

def G(seed : unsigned bits[hBits]) :  unsigned bits[dbBits] {
  def mask : unsigned bits[dbBits];
  def hashin : unsigned bits[hBits + 32];
  def hashout : unsigned bits[hBits];
  def C : unsigned bits[32];
  def T : unsigned bits[TBits];
  def counter : int := 0;
  hashin[32..32+hBits-1] := seed;
  seq pos := TBits - hBits to 0 by (-hBits) {
    C := (unsigned bits [32])(counter);
    hashin[0..0+32-1] := C;
    hashout := hash(hashin);
    T[pos..pos+hBits-1] := hashout;
    counter := counter + 1;
  }
  mask := T[TBits-dbBits..TBits-1];
  return mask;
}

def Enc(e : int, msg : unsigned bits[msgBits], lHash : unsigned bits[hBits], seed : unsigned bits[hBits]) : int {
  def c : int;
  def DB, dbMask, maskedDB : unsigned bits[dbBits];
  def seedMask, maskedSeed : unsigned bits[hBits];
  def payload : unsigned bits[nBits];
  def m : int;
  def byte0 : unsigned bits[8] := (unsigned bits[8])0;
  def byte1 : unsigned bits[8] := (unsigned bits[8])1;

  DB[0..0+msgBits-1] := msg;
  DB[msgBits..msgBits+8-1] := byte1;
  DB[msgBits+8..msgBits+8+hBits-1] := lHash;
  dbMask := G(seed);
  maskedDB := DB ^ dbMask;
  seedMask := H(maskedDB);
  maskedSeed := seed ^ seedMask;
  payload[0..0+dbBits-1] := maskedDB;
  payload[dbBits..dbBits+hBits-1] := maskedSeed;
  payload[dbBits+hBits..dbBits+hBits+8-1] := byte0;
  m := (int)payload;
  c := RSAFun(e, m);
  return c;
}

def Dec(d : int, c : int, lHash : unsigned bits[hBits]) : bool , unsigned bits[msgBits]  {
  def DB, dbMask, maskedDB : unsigned bits[dbBits];
  def seedMask, maskedSeed, lHash2,seed : unsigned bits[hBits];
  def payload : unsigned bits[nBits];
  def byte : unsigned bits[8];
  def m : int;
  def msg : unsigned bits[msgBits];
  def result, result1, result2, result3 : bool;
  def err_msg : unsigned bits[msgBits] := (unsigned bits[msgBits])0;
  def byte0 : unsigned bits[8] := (unsigned bits[8])0;
  def byte1 : unsigned bits[8] := (unsigned bits[8])1;

  if (c < 0 || c > n-1) { result := false; }
  else {
     m := RSAInv(d, c);
     payload := (unsigned bits[nBits])(m);
     maskedDB := payload[0..0+dbBits-1];
     maskedSeed := payload[dbBits..dbBits+hBits-1];
     seedMask := H(maskedDB);
     seed := maskedSeed ^ seedMask;
     dbMask := G(seed);
     DB := maskedDB ^ dbMask;
     lHash2 := DB[msgBits + 8..msgBits + 8+hBits-1];
     result1 := payload[dbBits+hBits..dbBits+hBits+8-1] == byte0;
     result2 := lHash == lHash2;
     result3 := DB[msgBits..msgBits+8-1] == byte1;
     result := result1 && result2 && result3;
  }
  if (result) { msg := DB[0..0+msgBits-1]; }
  else { msg := err_msg[0..0+msgBits-1]; }  
  return result, msg;
}

def const testPublicExponent : int;
def const testPrivateExponent : int;
def const testLHash : int;
def const testMessage : int;
def const testSeed : int;

def Test() : int {
	def t_e : int := testPublicExponent;
	def t_lh : unsigned bits[hBits] := (unsigned bits[hBits]) testLHash;
	def t_msg : unsigned bits[msgBits] := (unsigned bits[msgBits])testMessage;
	def t_s : unsigned bits[hBits] := (unsigned bits[hBits])testSeed;
	def t_c : int := Enc(t_e,t_msg,t_lh,t_s);
	return t_c;
}
