(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Reals Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Dp_hint bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Dp_hint bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Dp_hint bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Dp_hint bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Dp_hint ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Dp_hint ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Dp_hint lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Dp_hint le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Dp_hint gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Dp_hint ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Dp_hint eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Dp_hint neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Dp_hint abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Dp_hint abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Dp_hint int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Dp_hint int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Dp_hint int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Dp_hint int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Dp_hint math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Dp_hint math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Dp_hint computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Dp_hint computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Dp_hint computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Dp_hint computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Dp_hint computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Dp_hint computer_rounds_toward_zero.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Dp_hint truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Dp_hint truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Dp_hint lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Dp_hint le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Dp_hint gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Dp_hint ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Dp_hint eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Dp_hint neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Dp_hint real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Dp_hint real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Dp_hint real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Dp_hint real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Dp_hint sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Dp_hint sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Dp_hint sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Dp_hint abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Dp_hint abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Dp_hint log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Dp_hint exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Dp_hint prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Dp_hint abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Dp_hint poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Dp_hint poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Dp_hint not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Dp_hint bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Dp_hint not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Dp_hint surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Dp_hint fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Dp_hint snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Dp_hint pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Dp_hint None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Dp_hint Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Dp_hint Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Dp_hint Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Dp_hint Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Dp_hint Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Dp_hint Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Dp_hint in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Dp_hint in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Dp_hint in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Dp_hint length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Dp_hint length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Dp_hint length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Dp_hint head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Dp_hint tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Dp_hint Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Dp_hint Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Dp_hint get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Dp_hint get_upd_map_diff.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Dp_hint upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Dp_hint upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Dp_hint upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true <-> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Dp_hint in_dom_upd_map.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Dp_hint in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Dp_hint upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Dp_hint in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Dp_hint in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Dp_hint in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Dp_hint inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A1 A2)) = false).
Admitted.
Dp_hint empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A2 A1)) = false).
Admitted.
Dp_hint empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Dp_hint triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Dp_hint div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Dp_hint real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Dp_hint real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Dp_hint rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Dp_hint rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Dp_hint rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Dp_hint rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Dp_hint rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Dp_hint rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Dp_hint rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Dp_hint real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Dp_hint real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Dp_hint real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Dp_hint real_of_int_12.

(*Why type*) Definition session: Set.
Admitted.

(*Why type*) Definition secret_key: Set.
Admitted.

(*Why type*) Definition public_key: Set.
Admitted.

(*Why type*) Definition message: Set.
Admitted.

(*Why type*) Definition session_string: Set.
Admitted.

(*Why type*) Definition session_key: Set.
Admitted.

(*Why type*) Definition session_id: Set.
Admitted.

(*Why type*) Definition eph_key: Set.
Admitted.

(*Why type*) Definition session_descr: Set.
Admitted.

(*Why logic*) Definition gen_secret_key : Z -> secret_key.
Admitted.

(*Why logic*) Definition gpk : secret_key -> public_key.
Admitted.

(*Why logic*) Definition gen_session_key : Z -> session_key.
Admitted.

(*Why logic*) Definition mk_sid :
  public_key -> public_key -> message -> message -> session_id.
Admitted.

(*Why logic*) Definition fstpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition sndpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition fstmsg : session_id -> message.
Admitted.

(*Why logic*) Definition sndmsg : session_id -> message.
Admitted.

(*Why logic*) Definition isSome_id : (option session_id) -> bool.
Admitted.

(*Why logic*) Definition isSome_string : (option session_string) -> bool.
Admitted.

(*Why logic*) Definition gen_eph_key : Z -> eph_key.
Admitted.

(*Why logic*) Definition inp : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition out_noclash : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition gen_session_string :
  secret_key -> eph_key -> public_key -> message -> session_string.
Admitted.

(*Why logic*) Definition gen_session_string_sid :
  session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> session_string.
Admitted.

(*Why logic*) Definition mk_session_descr :
  public_key -> message -> bool -> bool -> bool -> session_descr.
Admitted.

(*Why logic*) Definition session_part : session_descr -> public_key.
Admitted.

(*Why logic*) Definition session_msg : session_descr -> message.
Admitted.

(*Why logic*) Definition session_eph_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_key_reveal_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_test_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition same_session_string_abs :
  session_id -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition eqS_abs :
  session_string -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition findelse_sid_abs :
  (map session_id session_key) -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_g_abs :
  (map session_id session_key) -> session_string
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_h_abs :
  (map session_string session_key) -> session_id
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_string).
Admitted.

(*Why logic*) Definition dummy : secret_key.
Admitted.

(*Why logic*) Definition dummy_session_key : session_key.
Admitted.

(*Why logic*) Definition dummy_session_string : session_string.
Admitted.

(*Why logic*) Definition dummy_session_id : session_id.
Admitted.

(*Why logic*) Definition dummy_part : public_key.
Admitted.

(*Why logic*) Definition dummy_msg : message.
Admitted.

(*Why logic*) Definition dummy_string : session_string.
Admitted.

(*Why logic*) Definition dummy_sid : session_id.
Admitted.

(*Why predicate*) Definition invariant1  (LH1_491:(map session_string session_key)) (LH2_492:(map session_string session_key))
  := (forall (str_494:session_string),
      ((in_dom_map str_494 LH2_492) = true ->
       (in_dom_map str_494 LH1_491) = true /\
       (get_map LH1_491 str_494) = (get_map LH2_492 str_494))).

(*Why predicate*) Definition invariant2  (G2_495:(map session_id session_key)) (LH1_496:(map session_string session_key)) (skey2_497:(map public_key secret_key)) (seed2_498:(map (prod message public_key) eph_key))
  := (forall (str_502:session_string),
      (forall (fer_sid_501:session_id),
       ((findelse_g_abs G2_495 str_502 skey2_497 seed2_498) =
        (Some fer_sid_501) -> (in_dom_map str_502 LH1_496) = true /\
        (get_map LH1_496 str_502) = (get_map G2_495 fer_sid_501)))).

(*Why predicate*) Definition invariant3  (G2_503:(map session_id session_key)) (LH1_504:(map session_string session_key)) (LH2_505:(map session_string session_key)) (skey2_506:(map public_key secret_key)) (seed2_507:(map (prod message public_key) eph_key))
  := (forall (str_509:session_string),
      ((in_dom_map str_509 LH1_504) = true ->
       (in_dom_map str_509 LH2_505) = true \/
       ~(findelse_g_abs G2_503 str_509 skey2_506 seed2_507) =
        (@None session_id))).

(*Why predicate*) Definition invariant4  (G2_510:(map session_id session_key)) (LH1_511:(map session_string session_key)) (LH2_512:(map session_string session_key)) (skey2_513:(map public_key secret_key)) (seed2_514:(map (prod message public_key) eph_key))
  := (forall (str_516:session_string),
      ((in_dom_map str_516 LH2_512) = true \/
       ~(findelse_g_abs G2_510 str_516 skey2_513 seed2_514) =
        (@None session_id) ->
       (in_dom_map str_516 LH1_511) = true)).

(*Why axiom*) Lemma session_string_eq_dec :
  (forall (str1_5:session_string),
   (forall (str2_4:session_string), str1_5 = str2_4 \/ ~str1_5 = str2_4)).
Admitted.
Dp_hint session_string_eq_dec.

(*Why axiom*) Lemma session_neq_sym :
  (forall (str1_9:session_string),
   (forall (str2_8:session_string), (~str1_9 = str2_8 -> ~str2_8 = str1_9))).
Admitted.
Dp_hint session_neq_sym.

(*Why axiom*) Lemma session_id_eq_dec :
  (forall (sid1_13:session_id),
   (forall (sid2_12:session_id), sid1_13 = sid2_12 \/ ~sid1_13 = sid2_12)).
Admitted.
Dp_hint session_id_eq_dec.

(*Why axiom*) Lemma session_id_neq_sym :
  (forall (sid1_17:session_id),
   (forall (sid2_16:session_id), (~sid1_17 = sid2_16 -> ~sid2_16 = sid1_17))).
Admitted.
Dp_hint session_id_neq_sym.

(*Why axiom*) Lemma isSome_id_def :
  (forall (x_19:(option session_id)),
   ((isSome_id x_19) = true <-> ~x_19 = (@None session_id))).
Admitted.
Dp_hint isSome_id_def.

(*Why axiom*) Lemma isSome_none : (isSome_id (@None session_id)) = false.
Admitted.
Dp_hint isSome_none.

(*Why axiom*) Lemma isSome_some :
  (forall (x_23:(option session_id)),
   ((isSome_id x_23) = true -> (exists y_22:session_id, x_23 = (Some y_22)))).
Admitted.
Dp_hint isSome_some.

(*Why axiom*) Lemma isSome_string_def :
  (forall (x_25:(option session_string)),
   ((isSome_string x_25) = true <-> ~x_25 = (@None session_string))).
Admitted.
Dp_hint isSome_string_def.

(*Why axiom*) Lemma isSome_string_some :
  (forall (x_29:(option session_string)),
   ((isSome_string x_29) = true ->
    (exists y_28:session_string, x_29 = (Some y_28)))).
Admitted.
Dp_hint isSome_string_some.

(*Why axiom*) Lemma isSome_string_none :
  (isSome_string (@None session_string)) = false.
Admitted.
Dp_hint isSome_string_none.

(*Why axiom*) Lemma session_id_proj :
  (forall (s_31:session_id),
   (mk_sid (fstpart s_31) (sndpart s_31) (fstmsg s_31) (sndmsg s_31)) = s_31).
Admitted.
Dp_hint session_id_proj.

(*Why axiom*) Lemma session_id_proj_fstpart :
  (forall (A_39:public_key),
   (forall (B_38:public_key),
    (forall (X_37:message),
     (forall (Y_36:message), (fstpart (mk_sid A_39 B_38 X_37 Y_36)) = A_39)))).
Admitted.
Dp_hint session_id_proj_fstpart.

(*Why axiom*) Lemma session_id_proj_sndpart :
  (forall (A_47:public_key),
   (forall (B_46:public_key),
    (forall (X_45:message),
     (forall (Y_44:message), (sndpart (mk_sid A_47 B_46 X_45 Y_44)) = B_46)))).
Admitted.
Dp_hint session_id_proj_sndpart.

(*Why axiom*) Lemma session_id_proj_fstmsg :
  (forall (A_55:public_key),
   (forall (B_54:public_key),
    (forall (X_53:message),
     (forall (Y_52:message), (fstmsg (mk_sid A_55 B_54 X_53 Y_52)) = X_53)))).
Admitted.
Dp_hint session_id_proj_fstmsg.

(*Why axiom*) Lemma session_id_proj_sndmsg :
  (forall (A_63:public_key),
   (forall (B_62:public_key),
    (forall (X_61:message),
     (forall (Y_60:message), (sndmsg (mk_sid A_63 B_62 X_61 Y_60)) = Y_60)))).
Admitted.
Dp_hint session_id_proj_sndmsg.

(*Why axiom*) Lemma session_id_eq :
  (forall (s_67:session_id),
   (forall (s'_66:session_id),
    (poly_eq s_67 s'_66) =
    (bool_and
     (bool_and
      (bool_and
       (poly_eq (fstpart s_67) (fstpart s'_66)) (poly_eq
                                                 (sndpart s_67) (sndpart
                                                                 s'_66))) (
      poly_eq (fstmsg s_67) (fstmsg s'_66))) (poly_eq
                                              (sndmsg s_67) (sndmsg s'_66))))).
Admitted.
Dp_hint session_id_eq.

(*Why axiom*) Lemma gen_session_string_sid_abs :
  (forall (sid_73:session_id),
   (forall (skey_72:(map public_key secret_key)),
    (forall (seed_71:(map (prod message public_key) eph_key)),
     (gen_session_string_sid sid_73 skey_72 seed_71) =
     (gen_session_string
      (get_map skey_72 (fstpart sid_73)) (get_map
                                          seed_71 (pair
                                                   (fstmsg sid_73) (fstpart
                                                                    sid_73))) (
      sndpart sid_73) (sndmsg sid_73))))).
Admitted.
Dp_hint gen_session_string_sid_abs.

(*Why axiom*) Lemma session_descr_proj :
  (forall (s_75:session_descr),
   (mk_session_descr
    (session_part s_75) (session_msg s_75) (session_eph_flag s_75) (session_key_reveal_flag
                                                                    s_75) (
    session_test_flag s_75)) =
   s_75).
Admitted.
Dp_hint session_descr_proj.

(*Why axiom*) Lemma session_descr_part :
  (forall (A_85:public_key),
   (forall (X_84:message),
    (forall (ef_83:bool),
     (forall (krf_82:bool),
      (forall (tf_81:bool),
       (session_part (mk_session_descr A_85 X_84 ef_83 krf_82 tf_81)) = A_85))))).
Admitted.
Dp_hint session_descr_part.

(*Why axiom*) Lemma session_descr_msg :
  (forall (A_95:public_key),
   (forall (X_94:message),
    (forall (ef_93:bool),
     (forall (krf_92:bool),
      (forall (tf_91:bool),
       (session_msg (mk_session_descr A_95 X_94 ef_93 krf_92 tf_91)) = X_94))))).
Admitted.
Dp_hint session_descr_msg.

(*Why axiom*) Lemma session_descr_eph :
  (forall (A_105:public_key),
   (forall (X_104:message),
    (forall (ef_103:bool),
     (forall (krf_102:bool),
      (forall (tf_101:bool),
       (session_eph_flag (mk_session_descr A_105 X_104 ef_103 krf_102 tf_101)) =
       ef_103))))).
Admitted.
Dp_hint session_descr_eph.

(*Why axiom*) Lemma session_descr_key_reveal_flag :
  (forall (A_115:public_key),
   (forall (X_114:message),
    (forall (ef_113:bool),
     (forall (krf_112:bool),
      (forall (tf_111:bool),
       (session_key_reveal_flag
        (mk_session_descr A_115 X_114 ef_113 krf_112 tf_111)) =
       krf_112))))).
Admitted.
Dp_hint session_descr_key_reveal_flag.

(*Why axiom*) Lemma session_descr_test_flag :
  (forall (A_125:public_key),
   (forall (X_124:message),
    (forall (ef_123:bool),
     (forall (krf_122:bool),
      (forall (tf_121:bool),
       (session_test_flag
        (mk_session_descr A_125 X_124 ef_123 krf_122 tf_121)) =
       tf_121))))).
Admitted.
Dp_hint session_descr_test_flag.

(*Why axiom*) Lemma session_descr_eq :
  (forall (s_129:session_descr),
   (forall (s'_128:session_descr),
    (poly_eq s_129 s'_128) =
    (bool_and
     (bool_and
      (bool_and
       (bool_and
        (poly_eq (session_part s_129) (session_part s'_128)) (poly_eq
                                                              (session_msg
                                                               s_129) (
                                                              session_msg
                                                              s'_128))) (
       poly_eq (session_eph_flag s_129) (session_eph_flag s'_128))) (
      poly_eq
      (session_key_reveal_flag s_129) (session_key_reveal_flag s'_128))) (
     poly_eq (session_test_flag s_129) (session_test_flag s'_128))))).
Admitted.
Dp_hint session_descr_eq.

(*Why axiom*) Lemma same_string_def1 :
  (forall (sid_137:session_id),
   (forall (sid'_136:session_id),
    (forall (skey_135:(map public_key secret_key)),
     (forall (seed_134:(map (prod message public_key) eph_key)),
      ((same_session_string_abs sid_137 sid'_136 skey_135 seed_134) = true ->
       (gen_session_string_sid sid_137 skey_135 seed_134) =
       (gen_session_string_sid sid'_136 skey_135 seed_134)))))).
Admitted.
Dp_hint same_string_def1.

(*Why axiom*) Lemma same_string_def2 :
  (forall (sid_145:session_id),
   (forall (sid'_144:session_id),
    (forall (skey_143:(map public_key secret_key)),
     (forall (seed_142:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_145 skey_143 seed_142) =
       (gen_session_string_sid sid'_144 skey_143 seed_142) ->
       (same_session_string_abs sid_145 sid'_144 skey_143 seed_142) = true))))).
Admitted.
Dp_hint same_string_def2.

(*Why axiom*) Lemma eqS_def1 :
  (forall (str_153:session_string),
   (forall (sid_152:session_id),
    (forall (skey_151:(map public_key secret_key)),
     (forall (seed_150:(map (prod message public_key) eph_key)),
      ((eqS_abs str_153 sid_152 skey_151 seed_150) = true ->
       (gen_session_string_sid sid_152 skey_151 seed_150) = str_153))))).
Admitted.
Dp_hint eqS_def1.

(*Why axiom*) Lemma eqS_def2 :
  (forall (str_161:session_string),
   (forall (sid_160:session_id),
    (forall (skey_159:(map public_key secret_key)),
     (forall (seed_158:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_160 skey_159 seed_158) = str_161 ->
       (eqS_abs str_161 sid_160 skey_159 seed_158) = true))))).
Admitted.
Dp_hint eqS_def2.

(*Why axiom*) Lemma findelse_sid_abs_none1 :
  (forall (m'_171:(map session_id session_key)),
   (forall (s'_170:session_id),
    (forall (skey'_169:(map public_key secret_key)),
     (forall (seed'_168:(map (prod message public_key) eph_key)),
      ((findelse_sid_abs m'_171 s'_170 skey'_169 seed'_168) =
       (@None session_id) ->
       (forall (x_167:session_id),
        ((in_dom_map x_167 m'_171) = true ->
         ~(same_session_string_abs x_167 s'_170 skey'_169 seed'_168) = true))))))).
Admitted.
Dp_hint findelse_sid_abs_none1.

(*Why axiom*) Lemma findelse_sid_abs_none2 :
  (forall (m'_181:(map session_id session_key)),
   (forall (s'_180:session_id),
    (forall (skey'_179:(map public_key secret_key)),
     (forall (seed'_178:(map (prod message public_key) eph_key)),
      ((forall (x_177:session_id),
        ((in_dom_map x_177 m'_181) = true ->
         ~(same_session_string_abs x_177 s'_180 skey'_179 seed'_178) = true)) ->
       (findelse_sid_abs m'_181 s'_180 skey'_179 seed'_178) =
       (@None session_id)))))).
Admitted.
Dp_hint findelse_sid_abs_none2.

(*Why axiom*) Lemma findelse_sid_abs_some :
  (forall (m'_191:(map session_id session_key)),
   (forall (s'_190:session_id),
    (forall (skey'_189:(map public_key secret_key)),
     (forall (seed'_188:(map (prod message public_key) eph_key)),
      (forall (opres_187:(option session_id)),
       ((findelse_sid_abs m'_191 s'_190 skey'_189 seed'_188) = opres_187 ->
        (~opres_187 = (@None session_id) ->
         (same_session_string_abs (proj opres_187) s'_190 skey'_189 seed'_188) =
         true /\ (in_dom_map (proj opres_187) m'_191) = true))))))).
Admitted.
Dp_hint findelse_sid_abs_some.

(*Why axiom*) Lemma findelse_sid_abs_ident :
  (forall (m'_199:(map session_id session_key)),
   (forall (s'_198:session_id),
    (forall (skey'_197:(map public_key secret_key)),
     (forall (seed'_196:(map (prod message public_key) eph_key)),
      (~(findelse_sid_abs m'_199 s'_198 skey'_197 seed'_196) =
        (@None session_id) ->
       (upd_map
        m'_199 s'_198 (get_map
                       m'_199 (proj
                               (findelse_sid_abs
                                m'_199 s'_198 skey'_197 seed'_196)))) =
       m'_199))))).
Admitted.
Dp_hint findelse_sid_abs_ident.

(*Why axiom*) Lemma findelse_g_abs_none_1 :
  (forall (m'_209:(map session_id session_key)),
   (forall (str_208:session_string),
    (forall (skey'_207:(map public_key secret_key)),
     (forall (seed'_206:(map (prod message public_key) eph_key)),
      ((forall (sid_205:session_id),
        ((in_dom_map sid_205 m'_209) = true ->
         ~(eqS_abs str_208 sid_205 skey'_207 seed'_206) = true)) ->
       (findelse_g_abs m'_209 str_208 skey'_207 seed'_206) =
       (@None session_id)))))).
Admitted.
Dp_hint findelse_g_abs_none_1.

(*Why axiom*) Lemma findelse_g_abs_none_2 :
  (forall (m'_219:(map session_id session_key)),
   (forall (str_218:session_string),
    (forall (skey'_217:(map public_key secret_key)),
     (forall (seed'_216:(map (prod message public_key) eph_key)),
      ((findelse_g_abs m'_219 str_218 skey'_217 seed'_216) =
       (@None session_id) ->
       (forall (sid_215:session_id),
        ((in_dom_map sid_215 m'_219) = true ->
         ~(eqS_abs str_218 sid_215 skey'_217 seed'_216) = true))))))).
Admitted.
Dp_hint findelse_g_abs_none_2.

(*Why axiom*) Lemma findelse_g_abs_some :
  (forall (m'_229:(map session_id session_key)),
   (forall (str_228:session_string),
    (forall (skey'_227:(map public_key secret_key)),
     (forall (seed'_226:(map (prod message public_key) eph_key)),
      (forall (res_225:(option session_id)),
       ((findelse_g_abs m'_229 str_228 skey'_227 seed'_226) = res_225 ->
        (~res_225 = (@None session_id) ->
         (eqS_abs str_228 (proj res_225) skey'_227 seed'_226) = true /\
         (in_dom_map (proj res_225) m'_229) = true))))))).
Admitted.
Dp_hint findelse_g_abs_some.

(*Why axiom*) Lemma findelse_g_update_1 :
  (forall (m_241:(map session_id session_key)),
   (forall (str_240:session_string),
    (forall (skey_239:(map public_key secret_key)),
     (forall (seed_238:(map (prod message public_key) eph_key)),
      (forall (sid_237:session_id),
       (forall (sesskey_236:session_key),
        ((gen_session_string_sid sid_237 skey_239 seed_238) = str_240 ->
         ~(findelse_g_abs
           (upd_map m_241 sid_237 sesskey_236) str_240 skey_239 seed_238) =
          (@None session_id)))))))).
Admitted.
Dp_hint findelse_g_update_1.

(*Why axiom*) Lemma findelse_sid_g :
  (forall (m_251:(map session_id session_key)),
   (forall (sid_250:session_id),
    (forall (str_249:session_string),
     (forall (skey_248:(map public_key secret_key)),
      (forall (seed_247:(map (prod message public_key) eph_key)),
       ((gen_session_string_sid sid_250 skey_248 seed_247) = str_249 ->
        (findelse_sid_abs m_251 sid_250 skey_248 seed_247) =
        (findelse_g_abs m_251 str_249 skey_248 seed_247))))))).
Admitted.
Dp_hint findelse_sid_g.

(*Why axiom*) Lemma findelse_sid_g2 :
  (forall (m_269:(map session_id session_key)),
   (forall (sid_268:session_id),
    (forall (sid'_267:session_id),
     (forall (opsid_266:(option session_id)),
      (forall (fer_sid_265:(option session_id)),
       (forall (h_264:session_key),
        (forall (str_263:session_string),
         (forall (skey_262:(map public_key secret_key)),
          (forall (seed_261:(map (prod message public_key) eph_key)),
           ((findelse_g_abs
             (upd_map (upd_map m_269 sid_268 h_264) sid'_267 h_264) str_263 skey_262 seed_261) =
            opsid_266 ->
            ((findelse_sid_abs m_269 sid_268 skey_262 seed_261) = fer_sid_265 ->
             (~opsid_266 = fer_sid_265 ->
              (findelse_g_abs m_269 str_263 skey_262 seed_261) = opsid_266 /\
              (get_map
               (upd_map (upd_map m_269 sid_268 h_264) sid'_267 h_264) (
               proj opsid_266)) =
              (get_map m_269 (proj opsid_266)))))))))))))).
Admitted.
Dp_hint findelse_sid_g2.

(*Why axiom*) Lemma findelse_h_abs_none_1 :
  (forall (m'_279:(map session_string session_key)),
   (forall (sid_278:session_id),
    (forall (skey'_277:(map public_key secret_key)),
     (forall (seed'_276:(map (prod message public_key) eph_key)),
      ((findelse_h_abs m'_279 sid_278 skey'_277 seed'_276) =
       (@None session_string) ->
       (forall (str_275:session_string),
        ((in_dom_map str_275 m'_279) = true ->
         ~(eqS_abs str_275 sid_278 skey'_277 seed'_276) = true))))))).
Admitted.
Dp_hint findelse_h_abs_none_1.

(*Why axiom*) Lemma findelse_h_abs_none_2 :
  (forall (m'_289:(map session_string session_key)),
   (forall (sid_288:session_id),
    (forall (skey'_287:(map public_key secret_key)),
     (forall (seed'_286:(map (prod message public_key) eph_key)),
      ((forall (str_285:session_string),
        ((in_dom_map str_285 m'_289) = true ->
         ~(eqS_abs str_285 sid_288 skey'_287 seed'_286) = true)) ->
       (findelse_h_abs m'_289 sid_288 skey'_287 seed'_286) =
       (@None session_string)))))).
Admitted.
Dp_hint findelse_h_abs_none_2.

(*Why axiom*) Lemma findelse_h_abs_some :
  (forall (m'_299:(map session_string session_key)),
   (forall (sid_298:session_id),
    (forall (skey'_297:(map public_key secret_key)),
     (forall (seed'_296:(map (prod message public_key) eph_key)),
      (forall (str_295:(option session_string)),
       ((findelse_h_abs m'_299 sid_298 skey'_297 seed'_296) = str_295 ->
        (~str_295 = (@None session_string) ->
         (eqS_abs (proj str_295) sid_298 skey'_297 seed'_296) = true /\
         (in_dom_map (proj str_295) m'_299) = true))))))).
Admitted.
Dp_hint findelse_h_abs_some.

(*Why axiom*) Lemma findelse_h_eqS :
  (forall (m_309:(map session_string session_key)),
   (forall (sid_308:session_id),
    (forall (skey_307:(map public_key secret_key)),
     (forall (seed_306:(map (prod message public_key) eph_key)),
      (forall (str_305:(option session_string)),
       ((findelse_h_abs m_309 sid_308 skey_307 seed_306) = str_305 ->
        (~str_305 = (@None session_string) ->
         (gen_session_string_sid sid_308 skey_307 seed_306) = (proj str_305) /\
         (in_dom_map (proj str_305) m_309) = true))))))).
Admitted.
Dp_hint findelse_h_eqS.

(*Why axiom*) Lemma isSome_id_ax :
  (forall (x_311:session_id), (isSome_id (Some x_311)) = true).
Admitted.
Dp_hint isSome_id_ax.

(*Why axiom*) Lemma isSome_string_ax :
  (forall (x_313:session_string), (isSome_string (Some x_313)) = true).
Admitted.
Dp_hint isSome_string_ax.

(*Why axiom*) Lemma findelse_g_update_2 :
  (forall (m_325:(map session_id session_key)),
   (forall (str_324:session_string),
    (forall (skey_323:(map public_key secret_key)),
     (forall (seed_322:(map (prod message public_key) eph_key)),
      (forall (sid_321:session_id),
       (forall (sesskey_320:session_key),
        (~str_324 = (gen_session_string_sid sid_321 skey_323 seed_322) ->
         (findelse_g_abs
          (upd_map m_325 sid_321 sesskey_320) str_324 skey_323 seed_322) =
         (findelse_g_abs m_325 str_324 skey_323 seed_322)))))))).
Admitted.
Dp_hint findelse_g_update_2.

(*Why axiom*) Lemma findelse_h_update_2 :
  (forall (m_337:(map session_string session_key)),
   (forall (sid_336:session_id),
    (forall (skey_335:(map public_key secret_key)),
     (forall (seed_334:(map (prod message public_key) eph_key)),
      (forall (sesskey_333:session_key),
       (forall (str_332:session_string),
        (~str_332 = (gen_session_string_sid sid_336 skey_335 seed_334) ->
         (findelse_h_abs
          (upd_map m_337 str_332 sesskey_333) sid_336 skey_335 seed_334) =
         (findelse_h_abs m_337 sid_336 skey_335 seed_334)))))))).
Admitted.
Dp_hint findelse_h_update_2.

(* Why obligation from file "easycryptbc85dc.why", line 758, characters 0-1471: *)
(*Why goal*) Lemma implies_goal9 : 
  (forall (skey_414_689:(map public_key secret_key)),
   (forall (skey_343_688:(map public_key secret_key)),
    (forall (seed_416_687:(map (prod message public_key) eph_key)),
     (forall (seed_345_686:(map (prod message public_key) eph_key)),
      (forall (lam_424_685:session_string),
       (forall (lam_353_684:session_string),
        (forall (complete_sessions_410_683:(map (prod public_key message) session_descr)),
         (forall (complete_sessions_339_682:(map (prod public_key message) session_descr)),
          (forall (LH_415_681:(map session_string session_key)),
           (forall (LH_344_680:(map session_string session_key)),
            (forall (G_418_679:(map session_id session_key)),
             ((invariant1 LH_344_680 LH_415_681) ->
              ((invariant2 G_418_679 LH_344_680 skey_414_689 seed_416_687) ->
               ((invariant3
                 G_418_679 LH_344_680 LH_415_681 skey_414_689 seed_416_687) ->
                (skey_343_688 = skey_414_689 ->
                 (seed_345_686 = seed_416_687 ->
                  (complete_sessions_339_682 = complete_sessions_410_683 ->
                   (lam_353_684 = lam_424_685 ->
                    (forall (h_0_524:session_key),
                     (~(in_dom_map lam_424_685 LH_415_681) = true ->
                      (~(isSome_id
                         (findelse_g_abs
                          G_418_679 lam_424_685 skey_414_689 seed_416_687)) =
                        true ->
                       (~(in_dom_map lam_353_684 LH_344_680) = true ->
                        (invariant2
                         G_418_679 (upd_map LH_344_680 lam_353_684 h_0_524) skey_414_689 seed_416_687))))))))))))))))))))))).
Proof.
 Notation "P [ x ]" := (get_map P x) (at level 50).
 Notation "P [ x := y ]" := (upd_map P x y) (at level 50).
 Notation "( x , y )" := (pair x y).

 intros; intuition; subst; subst. 
 repeat match goal with | H:?x = ?x |- _ => clear H end.
intros.
unfold invariant2;intros.
destruct (H0 _ _ H2).
destruct (session_string_eq_dec str_502 lam_424_685).
destruct H8;rewrite <- H5;auto.

rewrite upd_map_dom_diff,get_upd_map_diff;auto.
Save.

