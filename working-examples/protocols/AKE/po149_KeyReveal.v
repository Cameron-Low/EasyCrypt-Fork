(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Print bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Print bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Print bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Print bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Print ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Print ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Print lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Print le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Print gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Print ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Print eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Print neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Print abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Print abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Print int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Print int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Print int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Print int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Print math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Print math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Print computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Print computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Print computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Print computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Print computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Print computer_rounds_toward_zero.

(*Why logic*) Require Export Reals. Definition lt_real  : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Print truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Print truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Print lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Print le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Print gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Print ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Print eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Print neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Print real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Print real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Print real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Print real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Print sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Print sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Print sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Print abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Print abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Print log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Print exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Print prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Print abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Print poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Print poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Print not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Print bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Print not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Print surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Print fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Print snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Print pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Print None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Print Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Print Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Print Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Print Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Print Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Print Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Print in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Print in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Print in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Print length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Print length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Print length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Print head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Print tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Print Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Print Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Print get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Print get_upd_map_diff.

(*Why axiom*) Lemma get_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (a = a' /\ b = b' \/ ~(a = a') /\ (get_map m a') = b' ->
        (get_map (upd_map m a b) a') = b')))))).
Admitted.
Print get_upd_map.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Print upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Print upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Print upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Print upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true <-> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Print in_dom_upd_map.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Print in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Print upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Print upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Print in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Print in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Print in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Print inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A1 A2)) = false).
Admitted.
Print empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A2 A1)) = false).
Admitted.
Print empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Print triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Print div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Print real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Print real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Print rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Print rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Print rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Print rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Print rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Print rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Print rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Print real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Print real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Print real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Print real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Print real_of_int_12.

(*Why type*) Definition session: Set.
Admitted.

(*Why type*) Definition secret_key: Set.
Admitted.

(*Why type*) Definition public_key: Set.
Admitted.

(*Why type*) Definition message: Set.
Admitted.

(*Why type*) Definition session_string: Set.
Admitted.

(*Why type*) Definition session_key: Set.
Admitted.

(*Why type*) Definition session_id: Set.
Admitted.

(*Why type*) Definition eph_key: Set.
Admitted.

(*Why type*) Definition session_descr: Set.
Admitted.

(*Why logic*) Definition gen_secret_key : Z -> secret_key.
Admitted.

(*Why logic*) Definition gpk : secret_key -> public_key.
Admitted.

(*Why logic*) Definition gen_session_key : Z -> session_key.
Admitted.

(*Why logic*) Definition mk_sid :
  public_key -> public_key -> message -> message -> session_id.
Admitted.

(*Why logic*) Definition fstpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition sndpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition fstmsg : session_id -> message.
Admitted.

(*Why logic*) Definition sndmsg : session_id -> message.
Admitted.

(*Why logic*) Definition isSome_id : (option session_id) -> bool.
Admitted.

(*Why logic*) Definition isSome_string : (option session_string) -> bool.
Admitted.

(*Why logic*) Definition gen_eph_key : Z -> eph_key.
Admitted.

(*Why logic*) Definition inp : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition out_noclash : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition gen_session_string :
  secret_key -> eph_key -> public_key -> message -> session_string.
Admitted.

(*Why logic*) Definition gen_session_string_sid :
  session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> session_string.
Admitted.

(*Why logic*) Definition mk_session_descr :
  public_key -> message -> bool -> bool -> bool -> session_descr.
Admitted.

(*Why logic*) Definition session_part : session_descr -> public_key.
Admitted.

(*Why logic*) Definition session_msg : session_descr -> message.
Admitted.

(*Why logic*) Definition session_eph_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_key_reveal_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_test_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition same_session_string_abs :
  session_id -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition eqS_abs :
  session_string -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition findelse_sid_abs :
  (map session_id session_key) -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_g_abs :
  (map session_id session_key) -> session_string
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_h_abs :
  (map session_string session_key) -> session_id
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_string).
Admitted.

(*Why logic*) Definition dummy : secret_key.
Admitted.

(*Why logic*) Definition dummy_session_key : session_key.
Admitted.

(*Why logic*) Definition dummy_session_string : session_string.
Admitted.

(*Why logic*) Definition dummy_session_id : session_id.
Admitted.

(*Why logic*) Definition dummy_part : public_key.
Admitted.

(*Why logic*) Definition dummy_msg : message.
Admitted.

(*Why logic*) Definition dummy_string : session_string.
Admitted.

(*Why logic*) Definition dummy_sid : session_id.
Admitted.

(*Why predicate*) Definition invariant1  (LH1_503:(map session_string session_key)) (LH2_504:(map session_string session_key))
  := (forall (str_506:session_string),
      ((in_dom_map str_506 LH2_504) = true ->
       (in_dom_map str_506 LH1_503) = true /\
       (get_map LH1_503 str_506) = (get_map LH2_504 str_506))).

(*Why predicate*) Definition invariant2  (G2_507:(map session_id session_key)) (LH1_508:(map session_string session_key)) (skey2_509:(map public_key secret_key)) (seed2_510:(map (prod message public_key) eph_key))
  := (forall (str_514:session_string),
      (forall (fer_sid_513:session_id),
       ((findelse_g_abs G2_507 str_514 skey2_509 seed2_510) =
        (Some fer_sid_513) -> (in_dom_map str_514 LH1_508) = true /\
        (get_map LH1_508 str_514) = (get_map G2_507 fer_sid_513)))).

(*Why predicate*) Definition invariant3  (G2_515:(map session_id session_key)) (LH1_516:(map session_string session_key)) (LH2_517:(map session_string session_key)) (skey2_518:(map public_key secret_key)) (seed2_519:(map (prod message public_key) eph_key))
  := (forall (str_521:session_string),
      ((in_dom_map str_521 LH1_516) = true ->
       (in_dom_map str_521 LH2_517) = true \/
       ~(findelse_g_abs G2_515 str_521 skey2_518 seed2_519) =
        (@None session_id))).

(*Why predicate*) Definition invariant4  (G2_522:(map session_id session_key)) (LH1_523:(map session_string session_key)) (LH2_524:(map session_string session_key)) (skey2_525:(map public_key secret_key)) (seed2_526:(map (prod message public_key) eph_key))
  := (forall (str_528:session_string),
      ((in_dom_map str_528 LH2_524) = true \/
       ~(findelse_g_abs G2_522 str_528 skey2_525 seed2_526) =
        (@None session_id) ->
       (in_dom_map str_528 LH1_523) = true)).

(*Why axiom*) Lemma session_string_eq_dec :
  (forall (str1_5:session_string),
   (forall (str2_4:session_string), str1_5 = str2_4 \/ ~str1_5 = str2_4)).
Admitted.
Print session_string_eq_dec.

(*Why axiom*) Lemma session_neq_sym :
  (forall (str1_9:session_string),
   (forall (str2_8:session_string), (~str1_9 = str2_8 -> ~str2_8 = str1_9))).
Admitted.
Print session_neq_sym.

(*Why axiom*) Lemma session_id_eq_dec :
  (forall (sid1_13:session_id),
   (forall (sid2_12:session_id), sid1_13 = sid2_12 \/ ~sid1_13 = sid2_12)).
Admitted.
Print session_id_eq_dec.

(*Why axiom*) Lemma session_id_neq_sym :
  (forall (sid1_17:session_id),
   (forall (sid2_16:session_id), (~sid1_17 = sid2_16 -> ~sid2_16 = sid1_17))).
Admitted.
Print session_id_neq_sym.

(*Why axiom*) Lemma isSome_id_def :
  (forall (x_19:(option session_id)),
   ((isSome_id x_19) = true <-> ~x_19 = (@None session_id))).
Admitted.
Print isSome_id_def.

(*Why axiom*) Lemma isSome_id_def1 :
  (forall (x_21:session_id), (isSome_id (Some x_21)) = true).
Admitted.
Print isSome_id_def1.

(*Why axiom*) Lemma isSome_none : (isSome_id (@None session_id)) = false.
Admitted.
Print isSome_none.

(*Why axiom*) Lemma isSome_some :
  (forall (x_25:(option session_id)),
   ((isSome_id x_25) = true -> (exists y_24:session_id, x_25 = (Some y_24)))).
Admitted.
Print isSome_some.

(*Why axiom*) Lemma isSome_string_def :
  (forall (x_27:(option session_string)),
   ((isSome_string x_27) = true <-> ~x_27 = (@None session_string))).
Admitted.
Print isSome_string_def.

(*Why axiom*) Lemma isSome_string_some :
  (forall (x_31:(option session_string)),
   ((isSome_string x_31) = true ->
    (exists y_30:session_string, x_31 = (Some y_30)))).
Admitted.
Print isSome_string_some.

(*Why axiom*) Lemma isSome_string_none :
  (isSome_string (@None session_string)) = false.
Admitted.
Print isSome_string_none.

(*Why axiom*) Lemma session_id_proj :
  (forall (s_33:session_id),
   (mk_sid (fstpart s_33) (sndpart s_33) (fstmsg s_33) (sndmsg s_33)) = s_33).
Admitted.
Print session_id_proj.

(*Why axiom*) Lemma session_id_proj_fstpart :
  (forall (A_41:public_key),
   (forall (B_40:public_key),
    (forall (X_39:message),
     (forall (Y_38:message), (fstpart (mk_sid A_41 B_40 X_39 Y_38)) = A_41)))).
Admitted.
Print session_id_proj_fstpart.

(*Why axiom*) Lemma session_id_proj_sndpart :
  (forall (A_49:public_key),
   (forall (B_48:public_key),
    (forall (X_47:message),
     (forall (Y_46:message), (sndpart (mk_sid A_49 B_48 X_47 Y_46)) = B_48)))).
Admitted.
Print session_id_proj_sndpart.

(*Why axiom*) Lemma session_id_proj_fstmsg :
  (forall (A_57:public_key),
   (forall (B_56:public_key),
    (forall (X_55:message),
     (forall (Y_54:message), (fstmsg (mk_sid A_57 B_56 X_55 Y_54)) = X_55)))).
Admitted.
Print session_id_proj_fstmsg.

(*Why axiom*) Lemma session_id_proj_sndmsg :
  (forall (A_65:public_key),
   (forall (B_64:public_key),
    (forall (X_63:message),
     (forall (Y_62:message), (sndmsg (mk_sid A_65 B_64 X_63 Y_62)) = Y_62)))).
Admitted.
Print session_id_proj_sndmsg.

(*Why axiom*) Lemma session_id_eq :
  (forall (s_69:session_id),
   (forall (s'_68:session_id),
    (poly_eq s_69 s'_68) =
    (bool_and
     (bool_and
      (bool_and
       (poly_eq (fstpart s_69) (fstpart s'_68)) (poly_eq
                                                 (sndpart s_69) (sndpart
                                                                 s'_68))) (
      poly_eq (fstmsg s_69) (fstmsg s'_68))) (poly_eq
                                              (sndmsg s_69) (sndmsg s'_68))))).
Admitted.
Print session_id_eq.

(*Why axiom*) Lemma G_eq :
  (forall (m_79:(map session_id session_key)),
   (forall (a_78:session_id),
    (forall (b_77:session_key),
     (forall (sid_76:session_id),
      (forall (k_75:session_key),
       ((get_map (upd_map m_79 a_78 b_77) sid_76) = k_75 <-> sid_76 = a_78 /\
        b_77 = k_75 \/ ~sid_76 = a_78 /\ (get_map m_79 sid_76) = k_75)))))).
Admitted.
Print G_eq.

(*Why axiom*) Lemma gen_session_string_sid_abs :
  (forall (sid_85:session_id),
   (forall (skey_84:(map public_key secret_key)),
    (forall (seed_83:(map (prod message public_key) eph_key)),
     (gen_session_string_sid sid_85 skey_84 seed_83) =
     (gen_session_string
      (get_map skey_84 (fstpart sid_85)) (get_map
                                          seed_83 (pair
                                                   (fstmsg sid_85) (fstpart
                                                                    sid_85))) (
      sndpart sid_85) (sndmsg sid_85))))).
Admitted.
Print gen_session_string_sid_abs.

(*Why axiom*) Lemma session_descr_proj :
  (forall (s_87:session_descr),
   (mk_session_descr
    (session_part s_87) (session_msg s_87) (session_eph_flag s_87) (session_key_reveal_flag
                                                                    s_87) (
    session_test_flag s_87)) =
   s_87).
Admitted.
Print session_descr_proj.

(*Why axiom*) Lemma session_descr_part :
  (forall (A_97:public_key),
   (forall (X_96:message),
    (forall (ef_95:bool),
     (forall (krf_94:bool),
      (forall (tf_93:bool),
       (session_part (mk_session_descr A_97 X_96 ef_95 krf_94 tf_93)) = A_97))))).
Admitted.
Print session_descr_part.

(*Why axiom*) Lemma session_descr_msg :
  (forall (A_107:public_key),
   (forall (X_106:message),
    (forall (ef_105:bool),
     (forall (krf_104:bool),
      (forall (tf_103:bool),
       (session_msg (mk_session_descr A_107 X_106 ef_105 krf_104 tf_103)) =
       X_106))))).
Admitted.
Print session_descr_msg.

(*Why axiom*) Lemma session_descr_eph :
  (forall (A_117:public_key),
   (forall (X_116:message),
    (forall (ef_115:bool),
     (forall (krf_114:bool),
      (forall (tf_113:bool),
       (session_eph_flag (mk_session_descr A_117 X_116 ef_115 krf_114 tf_113)) =
       ef_115))))).
Admitted.
Print session_descr_eph.

(*Why axiom*) Lemma session_descr_key_reveal_flag :
  (forall (A_127:public_key),
   (forall (X_126:message),
    (forall (ef_125:bool),
     (forall (krf_124:bool),
      (forall (tf_123:bool),
       (session_key_reveal_flag
        (mk_session_descr A_127 X_126 ef_125 krf_124 tf_123)) =
       krf_124))))).
Admitted.
Print session_descr_key_reveal_flag.

(*Why axiom*) Lemma session_descr_test_flag :
  (forall (A_137:public_key),
   (forall (X_136:message),
    (forall (ef_135:bool),
     (forall (krf_134:bool),
      (forall (tf_133:bool),
       (session_test_flag
        (mk_session_descr A_137 X_136 ef_135 krf_134 tf_133)) =
       tf_133))))).
Admitted.
Print session_descr_test_flag.

(*Why axiom*) Lemma session_descr_eq :
  (forall (s_141:session_descr),
   (forall (s'_140:session_descr),
    (poly_eq s_141 s'_140) =
    (bool_and
     (bool_and
      (bool_and
       (bool_and
        (poly_eq (session_part s_141) (session_part s'_140)) (poly_eq
                                                              (session_msg
                                                               s_141) (
                                                              session_msg
                                                              s'_140))) (
       poly_eq (session_eph_flag s_141) (session_eph_flag s'_140))) (
      poly_eq
      (session_key_reveal_flag s_141) (session_key_reveal_flag s'_140))) (
     poly_eq (session_test_flag s_141) (session_test_flag s'_140))))).
Admitted.
Print session_descr_eq.

(*Why axiom*) Lemma same_string_def1 :
  (forall (sid_149:session_id),
   (forall (sid'_148:session_id),
    (forall (skey_147:(map public_key secret_key)),
     (forall (seed_146:(map (prod message public_key) eph_key)),
      ((same_session_string_abs sid_149 sid'_148 skey_147 seed_146) = true ->
       (gen_session_string_sid sid_149 skey_147 seed_146) =
       (gen_session_string_sid sid'_148 skey_147 seed_146)))))).
Admitted.
Print same_string_def1.

(*Why axiom*) Lemma same_string_def2 :
  (forall (sid_157:session_id),
   (forall (sid'_156:session_id),
    (forall (skey_155:(map public_key secret_key)),
     (forall (seed_154:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_157 skey_155 seed_154) =
       (gen_session_string_sid sid'_156 skey_155 seed_154) ->
       (same_session_string_abs sid_157 sid'_156 skey_155 seed_154) = true))))).
Admitted.
Print same_string_def2.

(*Why axiom*) Lemma eqS_def1 :
  (forall (str_165:session_string),
   (forall (sid_164:session_id),
    (forall (skey_163:(map public_key secret_key)),
     (forall (seed_162:(map (prod message public_key) eph_key)),
      ((eqS_abs str_165 sid_164 skey_163 seed_162) = true ->
       (gen_session_string_sid sid_164 skey_163 seed_162) = str_165))))).
Admitted.
Print eqS_def1.

(*Why axiom*) Lemma eqS_def2 :
  (forall (str_173:session_string),
   (forall (sid_172:session_id),
    (forall (skey_171:(map public_key secret_key)),
     (forall (seed_170:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_172 skey_171 seed_170) = str_173 ->
       (eqS_abs str_173 sid_172 skey_171 seed_170) = true))))).
Admitted.
Print eqS_def2.

(*Why axiom*) Lemma findelse_sid_abs_none1 :
  (forall (m'_183:(map session_id session_key)),
   (forall (s'_182:session_id),
    (forall (skey'_181:(map public_key secret_key)),
     (forall (seed'_180:(map (prod message public_key) eph_key)),
      ((findelse_sid_abs m'_183 s'_182 skey'_181 seed'_180) =
       (@None session_id) ->
       (forall (x_179:session_id),
        ((in_dom_map x_179 m'_183) = true ->
         ~(same_session_string_abs x_179 s'_182 skey'_181 seed'_180) = true))))))).
Admitted.
Print findelse_sid_abs_none1.

(*Why axiom*) Lemma findelse_sid_abs_none2 :
  (forall (m'_193:(map session_id session_key)),
   (forall (s'_192:session_id),
    (forall (skey'_191:(map public_key secret_key)),
     (forall (seed'_190:(map (prod message public_key) eph_key)),
      ((forall (x_189:session_id),
        ((in_dom_map x_189 m'_193) = true ->
         ~(same_session_string_abs x_189 s'_192 skey'_191 seed'_190) = true)) ->
       (findelse_sid_abs m'_193 s'_192 skey'_191 seed'_190) =
       (@None session_id)))))).
Admitted.
Print findelse_sid_abs_none2.

(*Why axiom*) Lemma findelse_sid_abs_some :
  (forall (m'_203:(map session_id session_key)),
   (forall (s'_202:session_id),
    (forall (skey'_201:(map public_key secret_key)),
     (forall (seed'_200:(map (prod message public_key) eph_key)),
      (forall (opres_199:(option session_id)),
       ((findelse_sid_abs m'_203 s'_202 skey'_201 seed'_200) = opres_199 ->
        (~opres_199 = (@None session_id) ->
         (same_session_string_abs (proj opres_199) s'_202 skey'_201 seed'_200) =
         true /\ (in_dom_map (proj opres_199) m'_203) = true))))))).
Admitted.
Print findelse_sid_abs_some.

(*Why axiom*) Lemma findelse_sid_abs_ident :
  (forall (m'_211:(map session_id session_key)),
   (forall (s'_210:session_id),
    (forall (skey'_209:(map public_key secret_key)),
     (forall (seed'_208:(map (prod message public_key) eph_key)),
      (~(findelse_sid_abs m'_211 s'_210 skey'_209 seed'_208) =
        (@None session_id) ->
       (upd_map
        m'_211 s'_210 (get_map
                       m'_211 (proj
                               (findelse_sid_abs
                                m'_211 s'_210 skey'_209 seed'_208)))) =
       m'_211))))).
Admitted.
Print findelse_sid_abs_ident.

(*Why axiom*) Lemma findelse_g_abs_none_1 :
  (forall (m'_221:(map session_id session_key)),
   (forall (str_220:session_string),
    (forall (skey'_219:(map public_key secret_key)),
     (forall (seed'_218:(map (prod message public_key) eph_key)),
      ((forall (sid_217:session_id),
        ((in_dom_map sid_217 m'_221) = true ->
         ~(eqS_abs str_220 sid_217 skey'_219 seed'_218) = true)) ->
       (findelse_g_abs m'_221 str_220 skey'_219 seed'_218) =
       (@None session_id)))))).
Admitted.
Print findelse_g_abs_none_1.

(*Why axiom*) Lemma findelse_g_abs_none_2 :
  (forall (m'_231:(map session_id session_key)),
   (forall (str_230:session_string),
    (forall (skey'_229:(map public_key secret_key)),
     (forall (seed'_228:(map (prod message public_key) eph_key)),
      ((findelse_g_abs m'_231 str_230 skey'_229 seed'_228) =
       (@None session_id) ->
       (forall (sid_227:session_id),
        ((in_dom_map sid_227 m'_231) = true ->
         ~(eqS_abs str_230 sid_227 skey'_229 seed'_228) = true))))))).
Admitted.
Print findelse_g_abs_none_2.

(*Why axiom*) Lemma findelse_g_abs_some :
  (forall (m'_241:(map session_id session_key)),
   (forall (str_240:session_string),
    (forall (skey'_239:(map public_key secret_key)),
     (forall (seed'_238:(map (prod message public_key) eph_key)),
      (forall (res_237:(option session_id)),
       ((findelse_g_abs m'_241 str_240 skey'_239 seed'_238) = res_237 ->
        (~res_237 = (@None session_id) ->
         (eqS_abs str_240 (proj res_237) skey'_239 seed'_238) = true /\
         (in_dom_map (proj res_237) m'_241) = true))))))).
Admitted.
Print findelse_g_abs_some.

(*Why axiom*) Lemma findelse_g_update_1 :
  (forall (m_253:(map session_id session_key)),
   (forall (str_252:session_string),
    (forall (skey_251:(map public_key secret_key)),
     (forall (seed_250:(map (prod message public_key) eph_key)),
      (forall (sid_249:session_id),
       (forall (sesskey_248:session_key),
        ((gen_session_string_sid sid_249 skey_251 seed_250) = str_252 ->
         ~(findelse_g_abs
           (upd_map m_253 sid_249 sesskey_248) str_252 skey_251 seed_250) =
          (@None session_id)))))))).
Admitted.
Print findelse_g_update_1.

(*Why axiom*) Lemma findelse_sid_g :
  (forall (m_263:(map session_id session_key)),
   (forall (sid_262:session_id),
    (forall (str_261:session_string),
     (forall (skey_260:(map public_key secret_key)),
      (forall (seed_259:(map (prod message public_key) eph_key)),
       ((gen_session_string_sid sid_262 skey_260 seed_259) = str_261 ->
        (findelse_sid_abs m_263 sid_262 skey_260 seed_259) =
        (findelse_g_abs m_263 str_261 skey_260 seed_259))))))).
Admitted.
Print findelse_sid_g.

(*Why axiom*) Lemma findelse_sid_g2 :
  (forall (m_281:(map session_id session_key)),
   (forall (sid_280:session_id),
    (forall (sid'_279:session_id),
     (forall (opsid_278:(option session_id)),
      (forall (fer_sid_277:(option session_id)),
       (forall (h_276:session_key),
        (forall (str_275:session_string),
         (forall (skey_274:(map public_key secret_key)),
          (forall (seed_273:(map (prod message public_key) eph_key)),
           ((findelse_g_abs
             (upd_map (upd_map m_281 sid_280 h_276) sid'_279 h_276) str_275 skey_274 seed_273) =
            opsid_278 ->
            ((findelse_sid_abs m_281 sid_280 skey_274 seed_273) = fer_sid_277 ->
             (~opsid_278 = fer_sid_277 ->
              (findelse_g_abs m_281 str_275 skey_274 seed_273) = opsid_278 /\
              (get_map
               (upd_map (upd_map m_281 sid_280 h_276) sid'_279 h_276) (
               proj opsid_278)) =
              (get_map m_281 (proj opsid_278)))))))))))))).
Admitted.
Print findelse_sid_g2.

(*Why axiom*) Lemma findelse_h_abs_none_1 :
  (forall (m'_291:(map session_string session_key)),
   (forall (sid_290:session_id),
    (forall (skey'_289:(map public_key secret_key)),
     (forall (seed'_288:(map (prod message public_key) eph_key)),
      ((findelse_h_abs m'_291 sid_290 skey'_289 seed'_288) =
       (@None session_string) ->
       (forall (str_287:session_string),
        ((in_dom_map str_287 m'_291) = true ->
         ~(eqS_abs str_287 sid_290 skey'_289 seed'_288) = true))))))).
Admitted.
Print findelse_h_abs_none_1.

(*Why axiom*) Lemma findelse_h_abs_none_2 :
  (forall (m'_301:(map session_string session_key)),
   (forall (sid_300:session_id),
    (forall (skey'_299:(map public_key secret_key)),
     (forall (seed'_298:(map (prod message public_key) eph_key)),
      ((forall (str_297:session_string),
        ((in_dom_map str_297 m'_301) = true ->
         ~(eqS_abs str_297 sid_300 skey'_299 seed'_298) = true)) ->
       (findelse_h_abs m'_301 sid_300 skey'_299 seed'_298) =
       (@None session_string)))))).
Admitted.
Print findelse_h_abs_none_2.

(*Why axiom*) Lemma findelse_h_abs_some :
  (forall (m'_311:(map session_string session_key)),
   (forall (sid_310:session_id),
    (forall (skey'_309:(map public_key secret_key)),
     (forall (seed'_308:(map (prod message public_key) eph_key)),
      (forall (str_307:(option session_string)),
       ((findelse_h_abs m'_311 sid_310 skey'_309 seed'_308) = str_307 ->
        (~str_307 = (@None session_string) ->
         (eqS_abs (proj str_307) sid_310 skey'_309 seed'_308) = true /\
         (in_dom_map (proj str_307) m'_311) = true))))))).
Admitted.
Print findelse_h_abs_some.

(*Why axiom*) Lemma findelse_h_eqS :
  (forall (m_321:(map session_string session_key)),
   (forall (sid_320:session_id),
    (forall (skey_319:(map public_key secret_key)),
     (forall (seed_318:(map (prod message public_key) eph_key)),
      (forall (str_317:(option session_string)),
       ((findelse_h_abs m_321 sid_320 skey_319 seed_318) = str_317 ->
        (~str_317 = (@None session_string) ->
         (gen_session_string_sid sid_320 skey_319 seed_318) = (proj str_317) /\
         (in_dom_map (proj str_317) m_321) = true))))))).
Admitted.
Print findelse_h_eqS.

(*Why axiom*) Lemma isSome_id_ax :
  (forall (x_323:session_id), (isSome_id (Some x_323)) = true).
Admitted.
Print isSome_id_ax.

(*Why axiom*) Lemma isSome_string_ax :
  (forall (x_325:session_string), (isSome_string (Some x_325)) = true).
Admitted.
Print isSome_string_ax.

(*Why axiom*) Lemma findelse_g_update_2 :
  (forall (m_337:(map session_id session_key)),
   (forall (str_336:session_string),
    (forall (skey_335:(map public_key secret_key)),
     (forall (seed_334:(map (prod message public_key) eph_key)),
      (forall (sid_333:session_id),
       (forall (sesskey_332:session_key),
        (~str_336 = (gen_session_string_sid sid_333 skey_335 seed_334) ->
         (findelse_g_abs
          (upd_map m_337 sid_333 sesskey_332) str_336 skey_335 seed_334) =
         (findelse_g_abs m_337 str_336 skey_335 seed_334)))))))).
Admitted.
Print findelse_g_update_2.

(*Why axiom*) Lemma findelse_h_update_2 :
  (forall (m_349:(map session_string session_key)),
   (forall (sid_348:session_id),
    (forall (skey_347:(map public_key secret_key)),
     (forall (seed_346:(map (prod message public_key) eph_key)),
      (forall (sesskey_345:session_key),
       (forall (str_344:session_string),
        (~str_344 = (gen_session_string_sid sid_348 skey_347 seed_346) ->
         (findelse_h_abs
          (upd_map m_349 str_344 sesskey_345) sid_348 skey_347 seed_346) =
         (findelse_h_abs m_349 sid_348 skey_347 seed_346)))))))).
Admitted.
Print findelse_h_update_2.

(* Why obligation from file "easycryptf94ea7.why", line 772, characters 0-5768: *)
(*Why goal*) Lemma implies_goal149 : 
  (forall (skey_426_2646:(map public_key secret_key)),
   (forall (skey_355_2645:(map public_key secret_key)),
    (forall (seed_428_2644:(map (prod message public_key) eph_key)),
     (forall (seed_357_2643:(map (prod message public_key) eph_key)),
      (forall (s_474_2642:session_id),
       (forall (s_397_2641:session_id),
        (forall (complete_sessions_422_2640:(map (prod public_key message) session_descr)),
         (forall (complete_sessions_351_2639:(map (prod public_key message) session_descr)),
          (forall (LH_427_2638:(map session_string session_key)),
           (forall (LH_356_2637:(map session_string session_key)),
            (forall (G_430_2636:(map session_id session_key)),
             ((invariant1 LH_356_2637 LH_427_2638) ->
              ((invariant2 G_430_2636 LH_356_2637 skey_426_2646 seed_428_2644) ->
               ((invariant3
                 G_430_2636 LH_356_2637 LH_427_2638 skey_426_2646 seed_428_2644) ->
                (skey_355_2645 = skey_426_2646 ->
                 (seed_357_2643 = seed_428_2644 ->
                  (complete_sessions_351_2639 = complete_sessions_422_2640 ->
                   (s_397_2641 = s_474_2642 ->
                    (forall (h_3_622:session_key),
                     let A_475_621 := (fstpart s_474_2642) in
                     let B_476_620 := (sndpart s_474_2642) in
                     let X_477_619 := (fstmsg s_474_2642) in
                     let Y_478_618 := (sndmsg s_474_2642) in
                     ((in_dom_map
                       (pair A_475_621 X_477_619) complete_sessions_422_2640) =
                      true ->
                      let B'_480_617 :=
                        (session_part
                         (get_map
                          complete_sessions_422_2640 (pair
                                                      A_475_621 X_477_619))) in
                      let Y'_481_616 :=
                        (session_msg
                         (get_map
                          complete_sessions_422_2640 (pair
                                                      A_475_621 X_477_619))) in
                      let sidA_494_615 :=
                        (mk_sid A_475_621 B'_480_617 X_477_619 Y'_481_616) in
                      (B_476_620 = B'_480_617 ->
                       (Y_478_618 = Y'_481_616 ->
                        ((in_dom_map
                          (pair B_476_620 Y_478_618) complete_sessions_422_2640) =
                         true ->
                         let sidB_495_600 :=
                           (mk_sid
                            B_476_620 (session_part
                                       (get_map
                                        complete_sessions_422_2640 (pair
                                                                    B_476_620 Y_478_618))) Y_478_618 (
                            session_msg
                            (get_map
                             complete_sessions_422_2640 (pair
                                                         B_476_620 Y_478_618)))) in
                         (sidA_494_615 =
                          (mk_sid
                           (sndpart sidB_495_600) (fstpart sidB_495_600) (
                           sndmsg sidB_495_600) (fstmsg sidB_495_600)) ->
                          (~((session_test_flag
                              (get_map
                               complete_sessions_422_2640 (pair
                                                           A_475_621 X_477_619))) =
                             true \/
                           (session_test_flag
                            (get_map
                             complete_sessions_422_2640 (pair
                                                         B_476_620 Y_478_618))) =
                           true) ->
                           (~(isSome_id
                              (findelse_sid_abs
                               G_430_2636 sidA_494_615 skey_426_2646 seed_428_2644)) =
                             true ->
                            (~(isSome_string
                               (findelse_h_abs
                                LH_427_2638 sidA_494_615 skey_426_2646 seed_428_2644)) =
                              true ->
                             let A_398_575 := (fstpart s_397_2641) in
                             let B_399_574 := (sndpart s_397_2641) in
                             let X_400_573 := (fstmsg s_397_2641) in
                             let Y_401_572 := (sndmsg s_397_2641) in
                             ((in_dom_map
                               (pair A_398_575 X_400_573) complete_sessions_351_2639) =
                              true ->
                              let B'_403_571 :=
                                (session_part
                                 (get_map
                                  complete_sessions_351_2639 (pair
                                                              A_398_575 X_400_573))) in
                              let Y'_404_570 :=
                                (session_msg
                                 (get_map
                                  complete_sessions_351_2639 (pair
                                                              A_398_575 X_400_573))) in
                              (B_399_574 = B'_403_571 ->
                               (Y_401_572 = Y'_404_570 ->
                                ((in_dom_map
                                  (pair B_399_574 Y_401_572) complete_sessions_351_2639) =
                                 true ->
                                 let s'_530_566 :=
                                   (mk_sid
                                    B_399_574 (session_part
                                               (get_map
                                                complete_sessions_351_2639 (
                                                pair B_399_574 Y_401_572))) Y_401_572 (
                                    session_msg
                                    (get_map
                                     complete_sessions_351_2639 (pair
                                                                 B_399_574 Y_401_572)))) in
                                 ((mk_sid
                                   A_398_575 B'_403_571 X_400_573 Y'_404_570) =
                                  (mk_sid
                                   (sndpart s'_530_566) (fstpart s'_530_566) (
                                   sndmsg s'_530_566) (fstmsg s'_530_566)) ->
                                  (~(session_test_flag
                                     (get_map
                                      complete_sessions_351_2639 (pair
                                                                  A_398_575 X_400_573))) =
                                    true ->
                                   (~(session_test_flag
                                      (get_map
                                       complete_sessions_351_2639 (pair
                                                                   B_399_574 Y_401_572))) =
                                     true ->
                                    let sstr_411_563 :=
                                      (gen_session_string_sid
                                       (mk_sid
                                        A_398_575 B'_403_571 X_400_573 Y'_404_570) skey_355_2645 seed_357_2643) in
                                    (~(in_dom_map sstr_411_563 LH_356_2637) =
                                      true ->
                                     (invariant2
                                      (upd_map
                                       (upd_map
                                        G_430_2636 sidA_494_615 h_3_622) sidB_495_600 h_3_622) (
                                      upd_map
                                      LH_356_2637 sstr_411_563 h_3_622) skey_426_2646 seed_428_2644)))))))))))))))))))))))))))))))))))).
Proof.

 Notation "P [ x ]" := (get_map P x) (at level 50).
 Notation "P [ x := y ]" := (upd_map P x y) (at level 50).
 Notation "( x , y )" := (pair x y).
 intros.
 unfold invariant2.
 intros.
 destruct (findelse_g_abs_some _ _ _ _ _ H22).
apply not_eq_sym.
apply None_neq_Some.
assert (sstr_411_563 = gen_session_string_sid
                    sidA_494_615 skey_355_2645 seed_357_2643).
unfold sidA_494_615, sstr_411_563.
rewrite <- H7, <- H8, <- H15, <- H16.
unfold B_399_574, Y_401_572, A_398_575, X_400_573.
unfold B_476_620, Y_478_618, A_475_621, X_477_619.
rewrite H5, H2, H3.
reflexivity.

cut (gen_session_string_sid sidA_494_615 skey_355_2645 seed_357_2643 =
    gen_session_string_sid sidB_495_600 skey_426_2646 seed_428_2644).
intro H30.
cut (sidA_494_615 <> sidB_495_600).
intro H31.
rewrite Proj_Some in *.
assert (str_514 = gen_session_string_sid (fer_sid_513) skey_426_2646 seed_428_2644) 
  by (rewrite (eqS_def1 _ _ _ _  H23);auto).

destruct ((proj1 (in_dom_upd_map _ _ _ _ _ _) H24)).

assert (sstr_411_563 = str_514) by
(rewrite H25, H26, <- H27;auto).

rewrite H27, H28.
rewrite upd_map_dom_same, !get_upd_map_same;split;auto.

destruct ((proj1 (in_dom_upd_map _ _ _ _ _ _) H27)).

assert (sstr_411_563 = str_514) by 
  (rewrite  H25, H26, H28, H2, H3;auto).


rewrite H28, H29,upd_map_dom_same, !get_upd_map_same, get_upd_map_diff, get_upd_map_same.
split;auto.
apply not_eq_sym;rewrite <- H28;auto.

destruct (session_id_eq_dec sidB_495_600 fer_sid_513).
assert (sstr_411_563 = str_514) by (rewrite  H25, H26, <- H29;auto).
rewrite H29, H32, upd_map_dom_same, !get_upd_map_same;split;auto.

destruct (session_id_eq_dec sidA_494_615 fer_sid_513).
assert (sstr_411_563 = str_514)
by (rewrite  H25, H26, H32, H2, H3;auto).

rewrite H32, H33,upd_map_dom_same, !get_upd_map_same, get_upd_map_diff, get_upd_map_same.
split;auto.
rewrite <- H32;apply not_eq_sym;auto.

destruct (session_string_eq_dec sstr_411_563 str_514).

destruct (Some_or_None _ (findelse_sid_abs G_430_2636 sidA_494_615 skey_426_2646
             seed_428_2644));
[idtac|destruct H34;rewrite H34,isSome_id_def1 in H12;elim H12;auto].

destruct (findelse_sid_abs_none1 _ _ _ _ H34   _ H28).

apply same_string_def2.
rewrite <- H26,<- H2, <- H3, <- H25;auto.

rewrite upd_map_dom_diff,!get_upd_map_diff;auto.
apply H0.
rewrite  !(findelse_g_update_2 _ _ _ _ ) in H22;auto.

rewrite <- H2, <- H3,<- H25.
apply not_eq_sym;auto.

rewrite <- H30.
rewrite  <- H25.
apply not_eq_sym;auto.
admit.
admit.
Save.

