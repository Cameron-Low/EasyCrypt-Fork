(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Print bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Print bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Print bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Print bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Print ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Print ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Print lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Print le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Print gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Print ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Print eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Print neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Print abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Print abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Print int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Print int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Print int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Print int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Print math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Print math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Print computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Print computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Print computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Print computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Print computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Print computer_rounds_toward_zero.

(*Why logic*) Require Export Reals. Definition lt_real  : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Print truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Print truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Print lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Print le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Print gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Print ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Print eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Print neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Print real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Print real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Print real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Print real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Print sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Print sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Print sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Print abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Print abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Print log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Print exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Print prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Print abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Print poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Print poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Print not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Print bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Print not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Print surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Print fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Print snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Print pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Print None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Print Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Print Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Print Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Print Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Print Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Print Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Print in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Print in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Print in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Print length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Print length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Print length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Print head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Print tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Print Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Print Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Print get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Print get_upd_map_diff.

(*Why axiom*) Lemma get_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (a = a' /\ b = b' \/ ~(a = a') /\ (get_map m a') = b' ->
        (get_map (upd_map m a b) a') = b')))))).
Admitted.
Print get_upd_map.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Print upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Print upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Print upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Print upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true <-> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Print in_dom_upd_map.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Print in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Print upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Print upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Print in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Print in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Print in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Print inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A1 A2)) = false).
Admitted.
Print empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A2 A1)) = false).
Admitted.
Print empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Print triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Print div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Print real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Print real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Print rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Print rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Print rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Print rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Print rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Print rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Print rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Print real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Print real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Print real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Print real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Print real_of_int_12.

(*Why type*) Definition session: Set.
Admitted.

(*Why type*) Definition secret_key: Set.
Admitted.

(*Why type*) Definition public_key: Set.
Admitted.

(*Why type*) Definition message: Set.
Admitted.

(*Why type*) Definition session_string: Set.
Admitted.

(*Why type*) Definition session_key: Set.
Admitted.

(*Why type*) Definition session_id: Set.
Admitted.

(*Why type*) Definition eph_key: Set.
Admitted.

(*Why type*) Definition session_descr: Set.
Admitted.

(*Why logic*) Definition gen_secret_key : Z -> secret_key.
Admitted.

(*Why logic*) Definition gpk : secret_key -> public_key.
Admitted.

(*Why logic*) Definition gen_session_key : Z -> session_key.
Admitted.

(*Why logic*) Definition mk_sid :
  public_key -> public_key -> message -> message -> session_id.
Admitted.

(*Why logic*) Definition fstpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition sndpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition fstmsg : session_id -> message.
Admitted.

(*Why logic*) Definition sndmsg : session_id -> message.
Admitted.

(*Why logic*) Definition isSome_id : (option session_id) -> bool.
Admitted.

(*Why logic*) Definition isSome_string : (option session_string) -> bool.
Admitted.

(*Why logic*) Definition gen_eph_key : Z -> eph_key.
Admitted.

(*Why logic*) Definition inp : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition out_noclash : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition gen_session_string :
  secret_key -> eph_key -> public_key -> message -> session_string.
Admitted.

(*Why logic*) Definition gen_session_string_sid :
  session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> session_string.
Admitted.

(*Why logic*) Definition mk_session_descr :
  public_key -> message -> bool -> bool -> bool -> session_descr.
Admitted.

(*Why logic*) Definition session_part : session_descr -> public_key.
Admitted.

(*Why logic*) Definition session_msg : session_descr -> message.
Admitted.

(*Why logic*) Definition session_eph_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_key_reveal_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_test_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition same_session_string_abs :
  session_id -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition eqS_abs :
  session_string -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition findelse_sid_abs :
  (map session_id session_key) -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_g_abs :
  (map session_id session_key) -> session_string
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_h_abs :
  (map session_string session_key) -> session_id
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_string).
Admitted.

(*Why logic*) Definition dummy : secret_key.
Admitted.

(*Why logic*) Definition dummy_session_key : session_key.
Admitted.

(*Why logic*) Definition dummy_session_string : session_string.
Admitted.

(*Why logic*) Definition dummy_session_id : session_id.
Admitted.

(*Why logic*) Definition dummy_part : public_key.
Admitted.

(*Why logic*) Definition dummy_msg : message.
Admitted.

(*Why logic*) Definition dummy_string : session_string.
Admitted.

(*Why logic*) Definition dummy_sid : session_id.
Admitted.

(*Why predicate*) Definition invariant1  (LH1_465:(map session_string session_key)) (LH2_466:(map session_string session_key))
  := (forall (str_468:session_string),
      ((in_dom_map str_468 LH2_466) = true ->
       (in_dom_map str_468 LH1_465) = true /\
       (get_map LH1_465 str_468) = (get_map LH2_466 str_468))).

(*Why predicate*) Definition invariant2  (G2_469:(map session_id session_key)) (LH1_470:(map session_string session_key)) (skey2_471:(map public_key secret_key)) (seed2_472:(map (prod message public_key) eph_key))
  := (forall (str_476:session_string),
      (forall (opsid_475:(option session_id)),
       ((findelse_g_abs G2_469 str_476 skey2_471 seed2_472) = opsid_475 ->
        (~opsid_475 = (@None session_id) ->
         (in_dom_map str_476 LH1_470) = true /\
         (get_map LH1_470 str_476) = (get_map G2_469 (proj opsid_475)))))).

(*Why predicate*) Definition invariant3  (G2_477:(map session_id session_key)) (LH1_478:(map session_string session_key)) (LH2_479:(map session_string session_key)) (skey2_480:(map public_key secret_key)) (seed2_481:(map (prod message public_key) eph_key))
  := (forall (str_483:session_string),
      ((in_dom_map str_483 LH1_478) = true ->
       (in_dom_map str_483 LH2_479) = true \/
       ~(findelse_g_abs G2_477 str_483 skey2_480 seed2_481) =
        (@None session_id))).

(*Why predicate*) Definition invariant4  (G2_484:(map session_id session_key)) (LH1_485:(map session_string session_key)) (LH2_486:(map session_string session_key)) (skey2_487:(map public_key secret_key)) (seed2_488:(map (prod message public_key) eph_key))
  := (forall (str_490:session_string),
      ((in_dom_map str_490 LH2_486) = true \/
       ~(findelse_g_abs G2_484 str_490 skey2_487 seed2_488) =
        (@None session_id) ->
       (in_dom_map str_490 LH1_485) = true)).

(*Why axiom*) Lemma session_string_eq_dec :
  (forall (str1_5:session_string),
   (forall (str2_4:session_string), str1_5 = str2_4 \/ ~str1_5 = str2_4)).
Admitted.
Print session_string_eq_dec.

(*Why axiom*) Lemma session_neq_sym :
  (forall (str1_9:session_string),
   (forall (str2_8:session_string), (~str1_9 = str2_8 -> ~str2_8 = str1_9))).
Admitted.
Print session_neq_sym.

(*Why axiom*) Lemma session_id_eq_dec :
  (forall (sid1_13:session_id),
   (forall (sid2_12:session_id), sid1_13 = sid2_12 \/ ~sid1_13 = sid2_12)).
Admitted.
Print session_id_eq_dec.

(*Why axiom*) Lemma session_id_neq_sym :
  (forall (sid1_17:session_id),
   (forall (sid2_16:session_id), (~sid1_17 = sid2_16 -> ~sid2_16 = sid1_17))).
Admitted.
Print session_id_neq_sym.

(*Why axiom*) Lemma isSome_id_def :
  (forall (x_19:(option session_id)),
   ((isSome_id x_19) = true <-> ~x_19 = (@None session_id))).
Admitted.
Print isSome_id_def.

(*Why axiom*) Lemma isSome_none : (isSome_id (@None session_id)) = false.
Admitted.
Print isSome_none.

(*Why axiom*) Lemma isSome_some :
  (forall (x_23:(option session_id)),
   ((isSome_id x_23) = true -> (exists y_22:session_id, x_23 = (Some y_22)))).
Admitted.
Print isSome_some.

(*Why axiom*) Lemma isSome_string_def :
  (forall (x_25:(option session_string)),
   ((isSome_string x_25) = true <-> ~x_25 = (@None session_string))).
Admitted.
Print isSome_string_def.

(*Why axiom*) Lemma isSome_string_some :
  (forall (x_29:(option session_string)),
   ((isSome_string x_29) = true ->
    (exists y_28:session_string, x_29 = (Some y_28)))).
Admitted.
Print isSome_string_some.

(*Why axiom*) Lemma isSome_string_none :
  (isSome_string (@None session_string)) = false.
Admitted.
Print isSome_string_none.

(*Why axiom*) Lemma session_id_proj :
  (forall (s_31:session_id),
   (mk_sid (fstpart s_31) (sndpart s_31) (fstmsg s_31) (sndmsg s_31)) = s_31).
Admitted.
Print session_id_proj.

(*Why axiom*) Lemma session_id_proj_fstpart :
  (forall (A_39:public_key),
   (forall (B_38:public_key),
    (forall (X_37:message),
     (forall (Y_36:message), (fstpart (mk_sid A_39 B_38 X_37 Y_36)) = A_39)))).
Admitted.
Print session_id_proj_fstpart.

(*Why axiom*) Lemma session_id_proj_sndpart :
  (forall (A_47:public_key),
   (forall (B_46:public_key),
    (forall (X_45:message),
     (forall (Y_44:message), (sndpart (mk_sid A_47 B_46 X_45 Y_44)) = B_46)))).
Admitted.
Print session_id_proj_sndpart.

(*Why axiom*) Lemma session_id_proj_fstmsg :
  (forall (A_55:public_key),
   (forall (B_54:public_key),
    (forall (X_53:message),
     (forall (Y_52:message), (fstmsg (mk_sid A_55 B_54 X_53 Y_52)) = X_53)))).
Admitted.
Print session_id_proj_fstmsg.

(*Why axiom*) Lemma session_id_proj_sndmsg :
  (forall (A_63:public_key),
   (forall (B_62:public_key),
    (forall (X_61:message),
     (forall (Y_60:message), (sndmsg (mk_sid A_63 B_62 X_61 Y_60)) = Y_60)))).
Admitted.
Print session_id_proj_sndmsg.

(*Why axiom*) Lemma session_id_eq :
  (forall (s_67:session_id),
   (forall (s'_66:session_id),
    (poly_eq s_67 s'_66) =
    (bool_and
     (bool_and
      (bool_and
       (poly_eq (fstpart s_67) (fstpart s'_66)) (poly_eq
                                                 (sndpart s_67) (sndpart
                                                                 s'_66))) (
      poly_eq (fstmsg s_67) (fstmsg s'_66))) (poly_eq
                                              (sndmsg s_67) (sndmsg s'_66))))).
Admitted.
Print session_id_eq.

(*Why axiom*) Lemma gen_session_string_sid_abs :
  (forall (sid_73:session_id),
   (forall (skey_72:(map public_key secret_key)),
    (forall (seed_71:(map (prod message public_key) eph_key)),
     (gen_session_string_sid sid_73 skey_72 seed_71) =
     (gen_session_string
      (get_map skey_72 (fstpart sid_73)) (get_map
                                          seed_71 (pair
                                                   (fstmsg sid_73) (fstpart
                                                                    sid_73))) (
      sndpart sid_73) (sndmsg sid_73))))).
Admitted.
Print gen_session_string_sid_abs.

(*Why axiom*) Lemma session_descr_proj :
  (forall (s_75:session_descr),
   (mk_session_descr
    (session_part s_75) (session_msg s_75) (session_eph_flag s_75) (session_key_reveal_flag
                                                                    s_75) (
    session_test_flag s_75)) =
   s_75).
Admitted.
Print session_descr_proj.

(*Why axiom*) Lemma session_descr_part :
  (forall (A_85:public_key),
   (forall (X_84:message),
    (forall (ef_83:bool),
     (forall (krf_82:bool),
      (forall (tf_81:bool),
       (session_part (mk_session_descr A_85 X_84 ef_83 krf_82 tf_81)) = A_85))))).
Admitted.
Print session_descr_part.

(*Why axiom*) Lemma session_descr_msg :
  (forall (A_95:public_key),
   (forall (X_94:message),
    (forall (ef_93:bool),
     (forall (krf_92:bool),
      (forall (tf_91:bool),
       (session_msg (mk_session_descr A_95 X_94 ef_93 krf_92 tf_91)) = X_94))))).
Admitted.
Print session_descr_msg.

(*Why axiom*) Lemma session_descr_eph :
  (forall (A_105:public_key),
   (forall (X_104:message),
    (forall (ef_103:bool),
     (forall (krf_102:bool),
      (forall (tf_101:bool),
       (session_eph_flag (mk_session_descr A_105 X_104 ef_103 krf_102 tf_101)) =
       ef_103))))).
Admitted.
Print session_descr_eph.

(*Why axiom*) Lemma session_descr_key_reveal_flag :
  (forall (A_115:public_key),
   (forall (X_114:message),
    (forall (ef_113:bool),
     (forall (krf_112:bool),
      (forall (tf_111:bool),
       (session_key_reveal_flag
        (mk_session_descr A_115 X_114 ef_113 krf_112 tf_111)) =
       krf_112))))).
Admitted.
Print session_descr_key_reveal_flag.

(*Why axiom*) Lemma session_descr_test_flag :
  (forall (A_125:public_key),
   (forall (X_124:message),
    (forall (ef_123:bool),
     (forall (krf_122:bool),
      (forall (tf_121:bool),
       (session_test_flag
        (mk_session_descr A_125 X_124 ef_123 krf_122 tf_121)) =
       tf_121))))).
Admitted.
Print session_descr_test_flag.

(*Why axiom*) Lemma session_descr_eq :
  (forall (s_129:session_descr),
   (forall (s'_128:session_descr),
    (poly_eq s_129 s'_128) =
    (bool_and
     (bool_and
      (bool_and
       (bool_and
        (poly_eq (session_part s_129) (session_part s'_128)) (poly_eq
                                                              (session_msg
                                                               s_129) (
                                                              session_msg
                                                              s'_128))) (
       poly_eq (session_eph_flag s_129) (session_eph_flag s'_128))) (
      poly_eq
      (session_key_reveal_flag s_129) (session_key_reveal_flag s'_128))) (
     poly_eq (session_test_flag s_129) (session_test_flag s'_128))))).
Admitted.
Print session_descr_eq.

(*Why axiom*) Lemma same_string_def1 :
  (forall (sid_137:session_id),
   (forall (sid'_136:session_id),
    (forall (skey_135:(map public_key secret_key)),
     (forall (seed_134:(map (prod message public_key) eph_key)),
      ((same_session_string_abs sid_137 sid'_136 skey_135 seed_134) = true ->
       (gen_session_string_sid sid_137 skey_135 seed_134) =
       (gen_session_string_sid sid'_136 skey_135 seed_134)))))).
Admitted.
Print same_string_def1.

(*Why axiom*) Lemma same_string_def2 :
  (forall (sid_145:session_id),
   (forall (sid'_144:session_id),
    (forall (skey_143:(map public_key secret_key)),
     (forall (seed_142:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_145 skey_143 seed_142) =
       (gen_session_string_sid sid'_144 skey_143 seed_142) ->
       (same_session_string_abs sid_145 sid'_144 skey_143 seed_142) = true))))).
Admitted.
Print same_string_def2.

(*Why axiom*) Lemma eqS_def1 :
  (forall (str_153:session_string),
   (forall (sid_152:session_id),
    (forall (skey_151:(map public_key secret_key)),
     (forall (seed_150:(map (prod message public_key) eph_key)),
      ((eqS_abs str_153 sid_152 skey_151 seed_150) = true ->
       (gen_session_string_sid sid_152 skey_151 seed_150) = str_153))))).
Admitted.
Print eqS_def1.

(*Why axiom*) Lemma eqS_def2 :
  (forall (str_161:session_string),
   (forall (sid_160:session_id),
    (forall (skey_159:(map public_key secret_key)),
     (forall (seed_158:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_160 skey_159 seed_158) = str_161 ->
       (eqS_abs str_161 sid_160 skey_159 seed_158) = true))))).
Admitted.
Print eqS_def2.

(*Why axiom*) Lemma findelse_sid_abs_none1 :
  (forall (m'_171:(map session_id session_key)),
   (forall (s'_170:session_id),
    (forall (skey'_169:(map public_key secret_key)),
     (forall (seed'_168:(map (prod message public_key) eph_key)),
      ((findelse_sid_abs m'_171 s'_170 skey'_169 seed'_168) =
       (@None session_id) ->
       (forall (x_167:session_id),
        ((in_dom_map x_167 m'_171) = true ->
         ~(same_session_string_abs x_167 s'_170 skey'_169 seed'_168) = true))))))).
Admitted.
Print findelse_sid_abs_none1.

(*Why axiom*) Lemma findelse_sid_abs_none2 :
  (forall (m'_181:(map session_id session_key)),
   (forall (s'_180:session_id),
    (forall (skey'_179:(map public_key secret_key)),
     (forall (seed'_178:(map (prod message public_key) eph_key)),
      ((forall (x_177:session_id),
        ((in_dom_map x_177 m'_181) = true ->
         ~(same_session_string_abs x_177 s'_180 skey'_179 seed'_178) = true)) ->
       (findelse_sid_abs m'_181 s'_180 skey'_179 seed'_178) =
       (@None session_id)))))).
Admitted.
Print findelse_sid_abs_none2.

(*Why axiom*) Lemma findelse_sid_abs_some :
  (forall (m'_191:(map session_id session_key)),
   (forall (s'_190:session_id),
    (forall (skey'_189:(map public_key secret_key)),
     (forall (seed'_188:(map (prod message public_key) eph_key)),
      (forall (opres_187:(option session_id)),
       ((findelse_sid_abs m'_191 s'_190 skey'_189 seed'_188) = opres_187 ->
        (~opres_187 = (@None session_id) ->
         (same_session_string_abs (proj opres_187) s'_190 skey'_189 seed'_188) =
         true /\ (in_dom_map (proj opres_187) m'_191) = true))))))).
Admitted.
Print findelse_sid_abs_some.

(*Why axiom*) Lemma findelse_g_abs_none_1 :
  (forall (m'_201:(map session_id session_key)),
   (forall (str_200:session_string),
    (forall (skey'_199:(map public_key secret_key)),
     (forall (seed'_198:(map (prod message public_key) eph_key)),
      ((forall (sid_197:session_id),
        ((in_dom_map sid_197 m'_201) = true ->
         ~(eqS_abs str_200 sid_197 skey'_199 seed'_198) = true)) ->
       (findelse_g_abs m'_201 str_200 skey'_199 seed'_198) =
       (@None session_id)))))).
Admitted.
Print findelse_g_abs_none_1.

(*Why axiom*) Lemma findelse_g_abs_none_2 :
  (forall (m'_211:(map session_id session_key)),
   (forall (str_210:session_string),
    (forall (skey'_209:(map public_key secret_key)),
     (forall (seed'_208:(map (prod message public_key) eph_key)),
      ((findelse_g_abs m'_211 str_210 skey'_209 seed'_208) =
       (@None session_id) ->
       (forall (sid_207:session_id),
        ((in_dom_map sid_207 m'_211) = true ->
         ~(eqS_abs str_210 sid_207 skey'_209 seed'_208) = true))))))).
Admitted.
Print findelse_g_abs_none_2.

(*Why axiom*) Lemma findelse_g_abs_some :
  (forall (m'_221:(map session_id session_key)),
   (forall (str_220:session_string),
    (forall (skey'_219:(map public_key secret_key)),
     (forall (seed'_218:(map (prod message public_key) eph_key)),
      (forall (res_217:(option session_id)),
       ((findelse_g_abs m'_221 str_220 skey'_219 seed'_218) = res_217 ->
        (~res_217 = (@None session_id) ->
         (eqS_abs str_220 (proj res_217) skey'_219 seed'_218) = true /\
         (in_dom_map (proj res_217) m'_221) = true))))))).
Admitted.
Print findelse_g_abs_some.

(*Why axiom*) Lemma findelse_g_update_1 :
  (forall (m_233:(map session_id session_key)),
   (forall (str_232:session_string),
    (forall (skey_231:(map public_key secret_key)),
     (forall (seed_230:(map (prod message public_key) eph_key)),
      (forall (sid_229:session_id),
       (forall (sesskey_228:session_key),
        ((gen_session_string_sid sid_229 skey_231 seed_230) = str_232 ->
         ~(findelse_g_abs
           (upd_map m_233 sid_229 sesskey_228) str_232 skey_231 seed_230) =
          (@None session_id)))))))).
Admitted.
Print findelse_g_update_1.

(*Why axiom*) Lemma findelse_sid_g :
  (forall (m_243:(map session_id session_key)),
   (forall (sid_242:session_id),
    (forall (str_241:session_string),
     (forall (skey_240:(map public_key secret_key)),
      (forall (seed_239:(map (prod message public_key) eph_key)),
       ((gen_session_string_sid sid_242 skey_240 seed_239) = str_241 ->
        (findelse_sid_abs m_243 sid_242 skey_240 seed_239) =
        (findelse_g_abs m_243 str_241 skey_240 seed_239))))))).
Admitted.
Print findelse_sid_g.

(*Why axiom*) Lemma findelse_h_abs_none_1 :
  (forall (m'_253:(map session_string session_key)),
   (forall (sid_252:session_id),
    (forall (skey'_251:(map public_key secret_key)),
     (forall (seed'_250:(map (prod message public_key) eph_key)),
      ((findelse_h_abs m'_253 sid_252 skey'_251 seed'_250) =
       (@None session_string) ->
       (forall (str_249:session_string),
        ((in_dom_map str_249 m'_253) = true ->
         ~(eqS_abs str_249 sid_252 skey'_251 seed'_250) = true))))))).
Admitted.
Print findelse_h_abs_none_1.

(*Why axiom*) Lemma findelse_h_abs_none_2 :
  (forall (m'_263:(map session_string session_key)),
   (forall (sid_262:session_id),
    (forall (skey'_261:(map public_key secret_key)),
     (forall (seed'_260:(map (prod message public_key) eph_key)),
      ((forall (str_259:session_string),
        ((in_dom_map str_259 m'_263) = true ->
         ~(eqS_abs str_259 sid_262 skey'_261 seed'_260) = true)) ->
       (findelse_h_abs m'_263 sid_262 skey'_261 seed'_260) =
       (@None session_string)))))).
Admitted.
Print findelse_h_abs_none_2.

(*Why axiom*) Lemma findelse_h_abs_some :
  (forall (m'_273:(map session_string session_key)),
   (forall (sid_272:session_id),
    (forall (skey'_271:(map public_key secret_key)),
     (forall (seed'_270:(map (prod message public_key) eph_key)),
      (forall (str_269:(option session_string)),
       ((findelse_h_abs m'_273 sid_272 skey'_271 seed'_270) = str_269 ->
        (~str_269 = (@None session_string) ->
         (eqS_abs (proj str_269) sid_272 skey'_271 seed'_270) = true /\
         (in_dom_map (proj str_269) m'_273) = true))))))).
Admitted.
Print findelse_h_abs_some.

(*Why axiom*) Lemma findelse_h_eqS :
  (forall (m_283:(map session_string session_key)),
   (forall (sid_282:session_id),
    (forall (skey_281:(map public_key secret_key)),
     (forall (seed_280:(map (prod message public_key) eph_key)),
      (forall (str_279:(option session_string)),
       ((findelse_h_abs m_283 sid_282 skey_281 seed_280) = str_279 ->
        (~str_279 = (@None session_string) ->
         (gen_session_string_sid sid_282 skey_281 seed_280) = (proj str_279) /\
         (in_dom_map (proj str_279) m_283) = true))))))).
Admitted.
Print findelse_h_eqS.

(*Why axiom*) Lemma isSome_id_ax :
  (forall (x_285:session_id), (isSome_id (Some x_285)) = true).
Admitted.
Print isSome_id_ax.

(*Why axiom*) Lemma isSome_string_ax :
  (forall (x_287:session_string), (isSome_string (Some x_287)) = true).
Admitted.
Print isSome_string_ax.

(*Why axiom*) Lemma findelse_g_update_2 :
  (forall (m_299:(map session_id session_key)),
   (forall (str_298:session_string),
    (forall (skey_297:(map public_key secret_key)),
     (forall (seed_296:(map (prod message public_key) eph_key)),
      (forall (sid_295:session_id),
       (forall (sesskey_294:session_key),
        (~str_298 = (gen_session_string_sid sid_295 skey_297 seed_296) ->
         (findelse_g_abs
          (upd_map m_299 sid_295 sesskey_294) str_298 skey_297 seed_296) =
         (findelse_g_abs m_299 str_298 skey_297 seed_296)))))))).
Admitted.
Print findelse_g_update_2.

(*Why axiom*) Lemma findelse_h_update_2 :
  (forall (m_311:(map session_string session_key)),
   (forall (sid_310:session_id),
    (forall (skey_309:(map public_key secret_key)),
     (forall (seed_308:(map (prod message public_key) eph_key)),
      (forall (sesskey_307:session_key),
       (forall (str_306:session_string),
        (~str_306 = (gen_session_string_sid sid_310 skey_309 seed_308) ->
         (findelse_h_abs
          (upd_map m_311 str_306 sesskey_307) sid_310 skey_309 seed_308) =
         (findelse_h_abs m_311 sid_310 skey_309 seed_308)))))))).
Admitted.
Print findelse_h_update_2.

(*Why axiom*) Lemma inv4 :
  (forall (G2_500:(map session_id session_key)),
   (forall (LH1_499:(map session_string session_key)),
    (forall (LH2_498:(map session_string session_key)),
     (forall (skey2_497:(map public_key secret_key)),
      (forall (seed2_496:(map (prod message public_key) eph_key)),
       ((invariant1 LH1_499 LH2_498) ->
        ((invariant2 G2_500 LH1_499 skey2_497 seed2_496) ->
         ((invariant3 G2_500 LH1_499 LH2_498 skey2_497 seed2_496) ->
          (invariant4 G2_500 LH1_499 LH2_498 skey2_497 seed2_496))))))))).
Admitted.
Print inv4.

(* Why obligation from file "easycryptc5a6da.why", line 740, characters 0-4210: *)
(*Why goal*) Lemma implies_goal55 : 
  (forall (skey_388_1607:(map public_key secret_key)),
   (forall (skey_317_1606:(map public_key secret_key)),
    (forall (seed_390_1605:(map (prod message public_key) eph_key)),
     (forall (seed_319_1604:(map (prod message public_key) eph_key)),
      (forall (s_436_1603:session_id),
       (forall (s_359_1602:session_id),
        (forall (complete_sessions_384_1601:(map (prod public_key message) session_descr)),
         (forall (complete_sessions_313_1600:(map (prod public_key message) session_descr)),
          (forall (LH_389_1599:(map session_string session_key)),
           (forall (LH_318_1598:(map session_string session_key)),
            (forall (G_392_1597:(map session_id session_key)),
             ((invariant1 LH_318_1598 LH_389_1599) ->
              ((invariant2 G_392_1597 LH_318_1598 skey_388_1607 seed_390_1605) ->
               ((invariant3
                 G_392_1597 LH_318_1598 LH_389_1599 skey_388_1607 seed_390_1605) ->
                (skey_317_1606 = skey_388_1607 ->
                 (seed_319_1604 = seed_390_1605 ->
                  (complete_sessions_313_1600 = complete_sessions_384_1601 ->
                   (s_359_1602 = s_436_1603 ->
                    (forall (h_3_848:session_key),
                     let A_437_847 := (fstpart s_436_1603) in
                     let B_438_846 := (sndpart s_436_1603) in
                     let X_439_845 := (fstmsg s_436_1603) in
                     let Y_440_844 := (sndmsg s_436_1603) in
                     ((in_dom_map
                       (pair A_437_847 X_439_845) complete_sessions_384_1601) =
                      true ->
                      let B'_442_843 :=
                        (session_part
                         (get_map
                          complete_sessions_384_1601 (pair
                                                      A_437_847 X_439_845))) in
                      let Y'_443_842 :=
                        (session_msg
                         (get_map
                          complete_sessions_384_1601 (pair
                                                      A_437_847 X_439_845))) in
                      let sidA_456_841 :=
                        (mk_sid A_437_847 B'_442_843 X_439_845 Y'_443_842) in
                      (B_438_846 = B'_442_843 ->
                       (Y_440_844 = Y'_443_842 ->
                        (~(in_dom_map
                           (pair B_438_846 Y_440_844) complete_sessions_384_1601) =
                          true ->
                         (~(session_test_flag
                            (get_map
                             complete_sessions_384_1601 (pair
                                                         A_437_847 X_439_845))) =
                           true ->
                          (~(isSome_id
                             (findelse_sid_abs
                              G_392_1597 sidA_456_841 skey_388_1607 seed_390_1605)) =
                            true ->
                           (~(isSome_string
                              (findelse_h_abs
                               LH_389_1599 sidA_456_841 skey_388_1607 seed_390_1605)) =
                             true ->
                            let A_360_800 := (fstpart s_359_1602) in
                            let B_361_799 := (sndpart s_359_1602) in
                            let X_362_798 := (fstmsg s_359_1602) in
                            let Y_363_797 := (sndmsg s_359_1602) in
                            ((in_dom_map
                              (pair A_360_800 X_362_798) complete_sessions_313_1600) =
                             true ->
                             let B'_365_796 :=
                               (session_part
                                (get_map
                                 complete_sessions_313_1600 (pair
                                                             A_360_800 X_362_798))) in
                             let Y'_366_795 :=
                               (session_msg
                                (get_map
                                 complete_sessions_313_1600 (pair
                                                             A_360_800 X_362_798))) in
                             (B_361_799 = B'_365_796 ->
                              (Y_363_797 = Y'_366_795 ->
                               (~(in_dom_map
                                  (pair B_361_799 Y_363_797) complete_sessions_313_1600) =
                                 true ->
                                (~(session_test_flag
                                   (get_map
                                    complete_sessions_313_1600 (pair
                                                                A_360_800 X_362_798))) =
                                  true ->
                                 let sstr_373_782 :=
                                   (gen_session_string_sid
                                    (mk_sid
                                     A_360_800 B'_365_796 X_362_798 Y'_366_795) skey_317_1606 seed_319_1604) in
                                 (~(in_dom_map sstr_373_782 LH_318_1598) =
                                   true ->
                                  (invariant2
                                   (upd_map G_392_1597 sidA_456_841 h_3_848) (
                                   upd_map LH_318_1598 sstr_373_782 h_3_848) skey_388_1607 seed_390_1605))))))))))))))))))))))))))))))))).
Proof.
intros.
unfold invariant2.
intros.
destruct (findelse_g_abs_some _ _ _ _ _ H19 H20).
destruct ((proj1 (in_dom_upd_map _ _ _ _ _ _) H22)).
destruct (Some_or_None _ opsid_475).
elim H20;auto.
destruct H24.
rewrite H24, Proj_Some in *.
assert (sstr_373_782 = str_476).
unfold sstr_373_782.
rewrite <- (eqS_def1 _ _ _ _ H21), <- H23, H2, H3.
unfold sidA_456_841.
rewrite <- H7, <- H8, <- H14, <- H15.
unfold B_361_799, Y_363_797, A_360_800, X_362_798.
unfold B_438_846, Y_440_844, A_437_847, X_439_845.
rewrite H5.
reflexivity.

split;rewrite H25.
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ )).
left; auto.

rewrite H23, !get_upd_map_same;auto.

destruct (Some_or_None _ opsid_475).
elim H20;auto.
elim H24;intros sid Hsid;clear H24.
rewrite Hsid, Proj_Some in *.



destruct (session_id_eq_dec sid sidA_456_841).
assert (str_476 = sstr_373_782).
rewrite <- (eqS_def1 _ _ _ _  H21), H24.
unfold sstr_373_782.
unfold sidA_456_841.
rewrite H2, H3, <- H7, <- H8, <- H14, <- H15.
unfold B_361_799, Y_363_797, A_360_800, X_362_798.
unfold B_438_846, Y_440_844, A_437_847, X_439_845.
rewrite H5.
reflexivity.

rewrite H24, H25, !get_upd_map_same;split;auto.

apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));left;auto.

destruct (session_string_eq_dec str_476 sstr_373_782).
elim H18.
elim ((proj1 (in_dom_upd_map _ _ _ _ _ _) H22));intros.
elim H24;rewrite H26;auto.

assert (findelse_g_abs (upd_map G_392_1597 sidA_456_841 h_3_848) str_476
          skey_317_1606 seed_319_1604 = findelse_g_abs G_392_1597 str_476
          skey_317_1606 seed_319_1604).
apply findelse_g_update_2.



unfold invariant2 in H0.
apply (proj1 (H0 _ _ _ _ _)).

assert (in_dom_map  str_476 LH_318_1598 = true).
apply H.



(*Last Step
assert (findelse_g_abs (upd_map G_392_1597 sidA_456_841 h_3_848) str_476
          skey_317_1606 seed_319_1604 = findelse_g_abs G_392_1597 str_476
          skey_317_1606 seed_319_1604).
apply findelse_g_update_2.
intro H30.
apply H25.
rewrite H30;unfold sstr_373_782.
unfold sidA_456_841.
rewrite <- H7, <- H8, <- H14, <- H15.
unfold B_361_799, Y_363_797, A_360_800, X_362_798.
unfold B_438_846, Y_440_844, A_437_847, X_439_845.
rewrite H5.
reflexivity.
rewrite <- H2, <- H3, H26 in H19.
unfold invariant2 in H0.
rewrite  H2, H3 in H19.
destruct (H0 _ _ H19 H20).

split.
apply upd_map_dom_mon;auto.
rewrite Proj_Some in H28.
rewrite !get_upd_map_diff;auto.
*)


destruct (session_id_eq sid sidA_416_801).
rewrite <- H28, get_upd_map_same.
assert (sstr_333_742 = str_436).
unfold sstr_333_742.
rewrite <- (eqS_def1 _ _ _ _ H21), H28, H2, H3.
unfold sidA_416_801.
rewrite <- H7, <- H8, <- H14, <- H15.
unfold B_321_759, Y_323_757, A_320_760, X_322_758.
unfold B_398_806, Y_400_804, A_397_807, X_399_805.
rewrite H5.
reflexivity.

rewrite H29;split.
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));left;auto.
rewrite get_upd_map_same;auto.

unfold invariant2 in H1.
split.

apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));right;auto.
assert (str_436 <> sstr_333_742).
intro H29;apply H18;rewrite <- H29;auto.

rewrite !get_upd_map_diff;auto.

Save.

