(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import ZArith.
Require Import Rbase.
Require Import Rtrigo_def.
Require Import Rpower.
Require Import R_sqrt.
Require Import Rpower.
Require Import Rbasic_fun.
Inductive option (a:Type) :=
  | None : option a
  | Some : a -> option a.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.
Implicit Arguments Some.

Inductive list (a:Type) :=
  | Nil : list a
  | Cons : a -> (list a) -> list a.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.
Implicit Arguments Cons.

Set Implicit Arguments.
Fixpoint infix_plpl (a:Type)(l1:(list a)) (l2:(list a)) {struct l1}: (list
  a) :=
  match l1 with
  | Nil => l2
  | (Cons x1 r1) => (Cons x1 (infix_plpl r1 l2))
  end.
Unset Implicit Arguments.

Axiom Append_assoc : forall (a:Type), forall (l1:(list a)) (l2:(list a))
  (l3:(list a)), ((infix_plpl l1 (infix_plpl l2
  l3)) = (infix_plpl (infix_plpl l1 l2) l3)).

Axiom Append_l_nil : forall (a:Type), forall (l:(list a)), ((infix_plpl l
  (Nil:(list a))) = l).

Set Implicit Arguments.
Fixpoint length (a:Type)(l:(list a)) {struct l}: Z :=
  match l with
  | Nil => 0%Z
  | (Cons _ r) => (1%Z + (length r))%Z
  end.
Unset Implicit Arguments.

Axiom Length_nonnegative : forall (a:Type), forall (l:(list a)),
  (0%Z <= (length l))%Z.

Axiom Length_nil : forall (a:Type), forall (l:(list a)),
  ((length l) = 0%Z) <-> (l = (Nil:(list a))).

Axiom Append_length : forall (a:Type), forall (l1:(list a)) (l2:(list a)),
  ((length (infix_plpl l1 l2)) = ((length l1) + (length l2))%Z).

Set Implicit Arguments.
Fixpoint mem (a:Type)(x:a) (l:(list a)) {struct l}: Prop :=
  match l with
  | Nil => False
  | (Cons y r) => (x = y) \/ (mem x r)
  end.
Unset Implicit Arguments.

Axiom mem_append : forall (a:Type), forall (x:a) (l1:(list a)) (l2:(list a)),
  (mem x (infix_plpl l1 l2)) <-> ((mem x l1) \/ (mem x l2)).

Axiom mem_decomp : forall (a:Type), forall (x:a) (l:(list a)), (mem x l) ->
  exists l1:(list a), exists l2:(list a), (l = (infix_plpl l1 (Cons x l2))).

Definition log2(x:R): R := (Rdiv (ln x) (ln 2%R))%R.

Definition log10(x:R): R := (Rdiv (ln x) (ln 10%R))%R.

Parameter pow: R -> R -> R.


Axiom Pow_zero_y : forall (y:R), (~ (y = 0%R)) -> ((pow 0%R y) = 0%R).

Axiom Pow_x_zero : forall (x:R), (~ (x = 0%R)) -> ((pow x 0%R) = 1%R).

Axiom Pow_x_one : forall (x:R), ((pow x 1%R) = x).

Axiom Pow_one_y : forall (y:R), ((pow 1%R y) = 1%R).

Axiom Pow_x_two : forall (x:R), ((pow x 2%R) = (Rsqr x)).

Axiom Pow_half : forall (x:R), (0%R <= x)%R -> ((pow x
  (05 / 10)%R) = (sqrt x)).

Axiom Pow_exp_log : forall (x:R) (y:R), (0%R <  x)%R -> ((pow x
  y) = (exp (y * (ln x))%R)).

Axiom Abs_le : forall (x:Z) (y:Z), ((Zabs x) <= y)%Z <-> (((-y)%Z <= x)%Z /\
  (x <= y)%Z).

Parameter power: Z -> Z -> Z.


Axiom Power_0 : forall (x:Z), ((power x 0%Z) = 1%Z).

Axiom Power_s : forall (x:Z) (n:Z), (0%Z <= n)%Z -> ((power x
  (n + 1%Z)%Z) = (x * (power x n))%Z).

Axiom Power_1 : forall (x:Z), ((power x 1%Z) = x).

Axiom Power_sum : forall (x:Z) (n:Z) (m:Z), ((0%Z <= n)%Z /\ (0%Z <= m)%Z) ->
  ((power x (n + m)%Z) = ((power x n) * (power x m))%Z).

Axiom Power_mult : forall (x:Z) (n:Z) (m:Z), (0%Z <= n)%Z -> ((0%Z <= m)%Z ->
  ((power x (n * m)%Z) = (power (power x n) m))).

Parameter div: Z -> Z -> Z.


Parameter mod1: Z -> Z -> Z.


Axiom Div_mod : forall (x:Z) (y:Z), (~ (y = 0%Z)) -> (x = ((y * (div x
  y))%Z + (mod1 x y))%Z).

Axiom Div_bound : forall (x:Z) (y:Z), ((0%Z <= x)%Z /\ (0%Z <  y)%Z) ->
  ((0%Z <= (div x y))%Z /\ ((div x y) <= x)%Z).

Axiom Mod_bound : forall (x:Z) (y:Z), (~ (y = 0%Z)) -> ((0%Z <= (mod1 x
  y))%Z /\ ((mod1 x y) <  (Zabs y))%Z).

Axiom Mod_1 : forall (x:Z), ((mod1 x 1%Z) = 0%Z).

Axiom Div_1 : forall (x:Z), ((div x 1%Z) = x).

Parameter map : forall (qta:Type) (qtb:Type), Type.

Parameter real_of_bool: bool -> R.


Parameter upd_map: forall (qta:Type) (qtb:Type), (map qta qtb) -> qta
  -> qtb -> (map qta qtb).

Implicit Arguments upd_map.

Parameter get_map: forall (qta:Type) (qtb:Type), (map qta qtb) -> qta -> qtb.

Implicit Arguments get_map.

Parameter in_dom_map: forall (qta:Type) (qtb:Type), qta -> (map qta qtb) ->
  Prop.

Implicit Arguments in_dom_map.

Parameter in_rng_map: forall (qta:Type) (qtb:Type), qtb -> (map qta qtb) ->
  Prop.

Implicit Arguments in_rng_map.

Definition fst (qta:Type) (qtb:Type)(p:(qta* qtb)%type): qta :=
  match p with
  | (a, b) => a
  end.
Implicit Arguments fst.

Definition snd (qta:Type) (qtb:Type)(p:(qta* qtb)%type): qtb :=
  match p with
  | (a, b) => b
  end.
Implicit Arguments snd.

Parameter proj: forall (qta:Type), (option qta) -> qta.

Implicit Arguments proj.

Parameter hd: forall (qta:Type), (list qta) -> qta.

Implicit Arguments hd.

Parameter tl: forall (qta:Type), (list qta) -> (list qta).

Implicit Arguments tl.

Parameter empty_map: forall (qta:Type) (qtb:Type), (map qta qtb).

Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

Parameter message : Type.

Parameter secret_key : Type.

Parameter public_key : Type.

Definition part  := public_key.

Definition key  := (secret_key* public_key)%type.

Parameter session : Type.

Parameter eph_key : Type.

Parameter session_string : Type.

Parameter session_key : Type.

Definition session_id  := (public_key* public_key* message* message)%type.

Parameter dummy: secret_key.


Parameter bsshould_not_be_usedslsl_gen_secret_key: secret_key -> R.


Parameter gen_public_key: secret_key -> public_key.


Parameter dummy_session_key: session_key.


Parameter dummy_session_string: session_string.


Parameter dummy_message: message.


Parameter dummy_eph_key: eph_key.


Parameter msg_seed : Type.

Parameter bsshould_not_be_usedslsl_gen_msg_seed: msg_seed -> R.


Parameter bsshould_not_be_usedslsl_gen_session_key: session_key -> R.


Parameter dummy_session_id: (public_key* public_key* message* message)%type.


Parameter dom: forall (qta:Type) (qtb:Type), (map qta qtb) -> (list qta).

Implicit Arguments dom.

Definition get_matching_session(s:(public_key* public_key* message*
  message)%type): (public_key* public_key* message* message)%type :=
  match s with
  | (A, B, X, Y) => (B, A, Y, X)
  end.

Definition fstpart(x:(public_key* public_key* message*
  message)%type): public_key := match x with
  | (a, b, c, d) => a
  end.

Definition sndpart(x:(public_key* public_key* message*
  message)%type): public_key := match x with
  | (a, b, c, d) => b
  end.

Definition fstmsg(x:(public_key* public_key* message*
  message)%type): message := match x with
  | (a, b, c, d) => c
  end.

Definition sndmsg(x:(public_key* public_key* message*
  message)%type): message := match x with
  | (a, b, c, d) => d
  end.

Parameter bsshould_not_be_usedslsl_gen_eph_key: eph_key -> R.


Parameter inp: secret_key -> eph_key -> msg_seed -> message.


Parameter out: secret_key -> eph_key -> msg_seed -> message.


Parameter gen_session_string_sid: (public_key* public_key* message*
  message)%type -> (map public_key secret_key) -> (map (public_key*
  message)%type eph_key) -> session_string.


Definition incomplete_session_with_status  := (map (public_key* message)%type
  (public_key* bool)%type).

Definition session_descr  := (public_key* message* bool)%type.

Definition session_part(x:(public_key* message* bool)%type): public_key :=
  match x with
  | (a, b, c) => a
  end.

Definition session_msg(x:(public_key* message* bool)%type): message :=
  match x with
  | (a, b, c) => b
  end.

Definition session_eph_flag(x:(public_key* message* bool)%type): Prop :=
  match x with
  | (a, b, c) => (c = true)
  end.

Definition same_session_string_abs(s:(public_key* public_key* message*
  message)%type) (sqt:(public_key* public_key* message* message)%type)
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)): Prop := ((gen_session_string_sid s skey
  seed) = (gen_session_string_sid sqt skey seed)).

Parameter eqS_abs: session_string -> (public_key* public_key* message*
  message)%type -> (map public_key secret_key) -> (map (public_key*
  message)%type eph_key) -> Prop.


Parameter findelse_sid_abs: (map (public_key* public_key* message*
  message)%type session_key) -> (public_key* public_key* message*
  message)%type -> (map public_key secret_key) -> (map (public_key*
  message)%type eph_key) -> (option (public_key* public_key* message*
  message)%type).


Parameter findelse_g_abs: (map (public_key* public_key* message*
  message)%type session_key) -> session_string -> (map public_key secret_key)
  -> (map (public_key* message)%type eph_key) -> (option (public_key*
  public_key* message* message)%type).


Parameter findelse_h_abs: (map session_string session_key) -> (public_key*
  public_key* message* message)%type -> (map public_key secret_key) -> (map
  (public_key* message)%type eph_key) -> (option session_string).


Definition complete_session_with_status  := (map (public_key* message)%type
  (public_key* message* bool)%type).

Parameter dummy_part: public_key.


Parameter dummy_msg: message.


Parameter dummy_string: session_string.


Parameter dummy_sid: (public_key* public_key* message* message)%type.


Definition session_match(s:(public_key* public_key* message* message)%type)
  (sqt:(public_key* public_key* message* message)%type): Prop := (s = (
  (sndpart sqt), (fstpart sqt), (sndmsg sqt), (fstmsg sqt))).

Definition completed(sid:(public_key* public_key* message* message)%type)
  (complete_session:(map (public_key* message)%type (public_key* message*
  bool)%type)): Prop :=
  match sid with
  | (A, B, X, Y) => (in_dom_map (A, X) complete_session) /\
      match (get_map complete_session (A,
      X)) with
      | (Bqt, Yqt, flag1) => (B = Bqt) /\ (Y = Yqt)
      end
  end.

Definition fresh_sid1(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)) (complete_session:(map (public_key*
  message)%type (public_key* message* bool)%type)) (incomplete_session:(map
  (public_key* message)%type (public_key* bool)%type)): Prop :=
  match sid with
  | (A, B, X, Y) => (~ ((get_map corrupt B) = true)) /\ (((get_map corrupt
      A) = true) /\ ((in_dom_map (A, X) complete_session) /\
      ~ (session_eph_flag (get_map complete_session (A, X)))))
  end.

Definition fresh_sid11(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)) (complete_session:(map (public_key*
  message)%type (public_key* message* bool)%type)) (incomplete_session:(map
  (public_key* message)%type (public_key* bool)%type)): Prop :=
  match sid with
  | (A, B, X, Y) => ((get_map corrupt B) = true) /\ ((~ ((get_map corrupt
      A) = true)) /\ (((in_dom_map (B, Y) complete_session) /\
      ~ (session_eph_flag (get_map complete_session (B, Y)))) \/
      ((in_dom_map (B, Y) incomplete_session) /\
      ~ ((snd (get_map incomplete_session (B, Y))) = true))))
  end.

Definition fresh_sid2(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)): Prop :=
  match sid with
  | (A, B, X, Y) => (~ ((get_map corrupt A) = true)) /\ ~ ((get_map corrupt
      B) = true)
  end.

Definition fresh_sid3(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)) (complete_session:(map (public_key*
  message)%type (public_key* message* bool)%type)) (incomplete_session:(map
  (public_key* message)%type (public_key* bool)%type)): Prop :=
  match sid with
  | (A, B, X, Y) => ((get_map corrupt A) = true) /\ (((get_map corrupt
      B) = true) /\ (((in_dom_map (A, X) complete_session) /\
      ~ (session_eph_flag (get_map complete_session (A, X)))) /\
      (((in_dom_map (B, Y) complete_session) /\
      ~ (session_eph_flag (get_map complete_session (B, Y)))) \/
      ((in_dom_map (B, Y) incomplete_session) /\
      ~ ((snd (get_map incomplete_session (B, Y))) = true)))))
  end.

Definition fresh_sid(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)) (complete_session:(map (public_key*
  message)%type (public_key* message* bool)%type)) (incomplete_session:(map
  (public_key* message)%type (public_key* bool)%type)): Prop :=
  ((fresh_sid1 sid corrupt complete_session incomplete_session) \/
  ((fresh_sid11 sid corrupt complete_session incomplete_session) \/
  ((fresh_sid2 sid corrupt) \/ (fresh_sid3 sid corrupt complete_session
  incomplete_session)))) /\ (completed sid complete_session).

Parameter fresh_sid_op: (public_key* public_key* message* message)%type
  -> (map public_key bool) -> (map (public_key* message)%type (public_key*
  message* bool)%type) -> (map (public_key* message)%type (public_key*
  bool)%type) -> Prop.


Definition fresh(tested_sessions:(map (public_key* public_key* message*
  message)%type session_key)) (corrupt:(map public_key bool))
  (complete_session:(map (public_key* message)%type (public_key* message*
  bool)%type)) (incomplete_session:(map (public_key* message)%type
  (public_key* bool)%type)): Prop := forall (sid:(public_key* public_key*
  message* message)%type), (in_dom_map sid tested_sessions) ->
  ((fresh_sid sid corrupt complete_session incomplete_session) /\
  (fresh_sid (get_matching_session sid) corrupt complete_session
  incomplete_session)).

Definition fresh_sidqt(sid:(public_key* public_key* message* message)%type)
  (corrupt:(map public_key bool)) (complete_session:(map (public_key*
  message)%type (public_key* message* bool)%type)) (incomplete_session:(map
  (public_key* message)%type (public_key* bool)%type)): Prop :=
  (completed sid complete_session) /\
  match sid with
  | (A, B, X, Y) => (((get_map corrupt A) = true) -> ((in_dom_map (A, X)
      complete_session) /\ ~ (session_eph_flag (get_map complete_session (A,
      X))))) /\ (((get_map corrupt B) = true) -> (((in_dom_map (B, Y)
      complete_session) /\ ~ (session_eph_flag (get_map complete_session (B,
      Y)))) \/ ((in_dom_map (B, Y) incomplete_session) /\
      ~ ((snd (get_map incomplete_session (B, Y))) = true))))
  end.

Parameter fresh_sid3_op: (public_key* public_key* message* message)%type
  -> (map public_key bool) -> (map (public_key* message)%type (public_key*
  message* bool)%type) -> (map (public_key* message)%type (public_key*
  bool)%type) -> Prop.


Parameter fresh_sid2_op: (public_key* public_key* message* message)%type
  -> (map public_key bool) -> Prop.


Parameter fresh_sid1_op: (public_key* public_key* message* message)%type
  -> (map public_key bool) -> (map (public_key* message)%type (public_key*
  message* bool)%type) -> (map (public_key* message)%type (public_key*
  bool)%type) -> Prop.


Parameter fresh_sid11_op: (public_key* public_key* message* message)%type
  -> (map public_key bool) -> (map (public_key* message)%type (public_key*
  message* bool)%type) -> (map (public_key* message)%type (public_key*
  bool)%type) -> Prop.


Parameter fresh_op: (map (public_key* public_key* message* message)%type
  session_key) -> (map public_key bool) -> (map (public_key* message)%type
  (public_key* message* bool)%type) -> (map (public_key* message)%type
  (public_key* bool)%type) -> Prop.


Definition completed1(s:(public_key* public_key* message* message)%type)
  (cs:(map (public_key* message)%type (public_key* message*
  bool)%type)): Prop :=
  match s with
  | (A, B, X, Y) => (in_dom_map (A, X) cs) /\ (in_dom_map (B, Y) cs)
  end.

Parameter qPart: Z.


Parameter qSess: Z.


Parameter coll_session_id: (list (public_key* public_key* message*
  message)%type) -> (map public_key secret_key) -> (map (public_key*
  message)%type eph_key) -> Prop.


Definition matching_session_id(s1:(public_key* public_key* message*
  message)%type) (s2:(public_key* public_key* message*
  message)%type): Prop := (s1 = s2) \/ (s1 = (get_matching_session s2)).

Parameter eqS_oracle: session_string -> (public_key* public_key* message*
  message)%type -> Prop.


Parameter same_session_string_oracle: (public_key* public_key* message*
  message)%type -> (public_key* public_key* message* message)%type -> Prop.


Parameter wingame13: (public_key* public_key* message* message)%type
  -> session_string -> (map public_key secret_key) -> (map (public_key*
  message)%type eph_key) -> (map public_key bool) -> (map (public_key*
  message)%type (public_key* message* bool)%type) -> (map (public_key*
  message)%type (public_key* bool)%type) -> Prop.


Definition string_coll(m1:(list session_string)) (m2:(list
  session_string)): Prop := exists x:session_string, (mem x m1) /\ (mem x
  m2).

Parameter string_coll_op: (list session_string) -> (list session_string) ->
  Prop.


Definition inv(LH:(map session_string session_key)) (LHT:(map session_string
  session_key)) (argLH:(list session_string)) (argLHT:(list session_string))
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)): Prop := (forall (x:session_string), (in_dom_map x LHT) -> (mem x
  argLHT)) /\ forall (x:session_string), (in_dom_map x LH) -> (mem x argLH).

Parameter guess_session_string: (map (public_key* public_key* message*
  message)%type session_key) -> (list session_string) -> (map public_key
  secret_key) -> (map (public_key* message)%type eph_key) -> Prop.


Axiom Some_inj : forall (qta:Type), forall (x:qta) (y:qta),
  ((Some x) = (Some y)) -> (x = y).

Axiom Proj_Some : forall (qta:Type), forall (x:qta), ((proj (Some x)) = x).

Axiom Proj_eq : forall (qta:Type), forall (o1:(option qta)) (o2:(option
  qta)), (~ (o1 = (None:(option qta)))) -> ((~ (o2 = (None:(option qta)))) ->
  (((proj o1) = (proj o2)) -> (o1 = o2))).

Axiom Some_or_None : forall (qta:Type), forall (o:(option qta)),
  (o = (None:(option qta))) \/ exists x:qta, (o = (Some x)).

Axiom head_def : forall (qta:Type), forall (a:qta) (l:(list qta)),
  ((hd (Cons a l)) = a).

Axiom tail_def : forall (qta:Type), forall (a:qta) (l:(list qta)),
  ((tl (Cons a l)) = l).

Axiom get_upd_map_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a1:qta) (a2:qta) (b:qtb), (a1 = a2) -> ((get_map (upd_map m a1 b)
  a2) = b).

Axiom get_upd_map_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a1:qta) (a2:qta) (b:qtb), (~ (a1 = a2)) -> ((get_map (upd_map m a1
  b) a2) = (get_map m a2)).

Axiom upd_map_comm : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (a:qta) (aqt:qta) (b:qtb) (bqt:qtb), (~ (a = aqt)) -> ((upd_map (upd_map m
  a b) aqt bqt) = (upd_map (upd_map m aqt bqt) a b)).

Axiom upd_in_dom_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (aqt:qta) (b:qtb), (a = aqt) -> (in_dom_map aqt (upd_map m a
  b)).

Axiom upd_in_dom_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (aqt:qta) (b:qtb), (~ (a = aqt)) -> ((in_dom_map aqt
  (upd_map m a b)) <-> (in_dom_map aqt m)).

Axiom upd_in_rng_same : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (b:qtb) (bqt:qtb), (b = bqt) -> (in_rng_map bqt (upd_map m a
  b)).

Axiom upd_in_rng_diff : forall (qtb:Type) (qta:Type), forall (m:(map qta
  qtb)) (a:qta) (b:qtb) (bqt:qtb), (~ (b = bqt)) -> ((in_rng_map bqt
  (upd_map m a b)) <-> (in_rng_map bqt m)).

Axiom in_dom_in_rng : forall (qta:Type) (qtb:Type), forall (m:(map qta qtb))
  (a:qta), (in_dom_map a m) -> (in_rng_map (get_map m a) m).

Axiom in_rng_in_dom : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (b:qtb), (in_rng_map b m) -> exists a:qta, (in_dom_map a m) /\ ((get_map m
  a) = b).

Axiom empty_in_dom : forall (qta:Type) (qtb:Type) (qtb1:Type),
  forall (a:qta), ~ (in_dom_map a (empty_map:(map qta qtb1))).

Axiom empty_in_rng : forall (qtb:Type) (qta:Type) (qta1:Type),
  forall (b:qtb), ~ (in_rng_map b (empty_map:(map qta1 qtb))).

Axiom real_of_bool_true : ((real_of_bool true) = (IZR 1%Z)).

Axiom real_of_bool_false : ((real_of_bool false) = (IZR 0%Z)).

Axiom real_of_int_le_compat : forall (x:Z) (y:Z), (x <= y)%Z ->
  ((IZR x) <= (IZR y))%R.

Axiom real_of_int_lt_compat : forall (x:Z) (y:Z), (x <  y)%Z ->
  ((IZR x) <  (IZR y))%R.

Axiom rmult_le_compat_l : forall (x:R) (y:R) (z:R), ((IZR 0%Z) <= x)%R ->
  ((y <= z)%R -> ((x * y)%R <= (x * z)%R)%R).

Axiom rmult_le_compat_r : forall (x:R) (y:R) (z:R), ((IZR 0%Z) <= z)%R ->
  ((x <= y)%R -> ((x * z)%R <= (y * z)%R)%R).

Axiom rmul_plus_distr_r : forall (x:R) (y:R) (z:R),
  (((x + y)%R * z)%R = ((x * z)%R + (y * z)%R)%R).

Axiom rdiv_le_compat : forall (x1:R) (x2:R) (y1:R) (y2:R),
  ((IZR 0%Z) <  y2)%R -> ((y2 <= y1)%R -> (((IZR 0%Z) <= x1)%R ->
  ((x1 <= x2)%R -> ((Rdiv x1 y1)%R <= (Rdiv x2 y2)%R)%R))).

Axiom rdiv_0_le : forall (x:R) (y:R), ((IZR 0%Z) <  y)%R ->
  (((IZR 0%Z) <= x)%R -> ((IZR 0%Z) <= (Rdiv x y)%R)%R).

Axiom pow2_pos : forall (n:Z), (0%Z <= n)%Z -> (0%Z <  (power 2%Z n))%Z.

Axiom gpk_iny : forall (x1:secret_key) (x2:secret_key),
  ((gen_public_key x1) = (gen_public_key x2)) -> (x1 = x2).

Axiom dom_def : forall (qta:Type) (qtb:Type), forall (m:(map qta qtb))
  (x:qta), (in_dom_map x m) <-> (mem x (dom m)).

Axiom gen_session_string_upd_skey : forall (sid:(public_key* public_key*
  message* message)%type) (skey:(map public_key secret_key)) (seed:(map
  (public_key* message)%type eph_key)) (p:public_key) (sk:secret_key),
  (~ (in_dom_map p skey)) -> ((gen_session_string_sid sid (upd_map skey p sk)
  seed) = (gen_session_string_sid sid skey seed)).

Axiom gen_session_string_upd_seed : forall (sid:(public_key* public_key*
  message* message)%type) (skey:(map public_key secret_key)) (seed:(map
  (public_key* message)%type eph_key)) (p:(public_key* message)%type)
  (ek:eph_key), (~ (in_dom_map p seed)) -> ((gen_session_string_sid sid skey
  (upd_map seed p ek)) = (gen_session_string_sid sid skey seed)).

Axiom eqS_def1 : forall (str:session_string) (sid:(public_key* public_key*
  message* message)%type) (skey:(map public_key secret_key)) (seed:(map
  (public_key* message)%type eph_key)), (eqS_abs str sid skey seed) ->
  ((gen_session_string_sid sid skey seed) = str).

Axiom eqS_def2 : forall (sid:(public_key* public_key* message* message)%type)
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)), (eqS_abs (gen_session_string_sid sid skey seed) sid skey seed).

Axiom findelse_sid_abs_none1 : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (sqt:(public_key* public_key* message*
  message)%type) (skeyqt:(map public_key secret_key)) (seedqt:(map
  (public_key* message)%type eph_key)), ((findelse_sid_abs mqt sqt skeyqt
  seedqt) = (None:(option (public_key* public_key* message*
  message)%type))) -> forall (x:(public_key* public_key* message*
  message)%type), (in_dom_map x mqt) -> ~ (same_session_string_abs x sqt
  skeyqt seedqt).

Axiom findelse_sid_abs_none2 : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (sqt:(public_key* public_key* message*
  message)%type) (skeyqt:(map public_key secret_key)) (seedqt:(map
  (public_key* message)%type eph_key)), (forall (x:(public_key* public_key*
  message* message)%type), (in_dom_map x mqt) -> ~ (same_session_string_abs x
  sqt skeyqt seedqt)) -> ((findelse_sid_abs mqt sqt skeyqt
  seedqt) = (None:(option (public_key* public_key* message* message)%type))).

Axiom findelse_sid_abs_some : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (sqt:(public_key* public_key* message*
  message)%type) (skeyqt:(map public_key secret_key)) (seedqt:(map
  (public_key* message)%type eph_key)), (~ ((findelse_sid_abs mqt sqt skeyqt
  seedqt) = (None:(option (public_key* public_key* message*
  message)%type)))) -> ((same_session_string_abs (proj (findelse_sid_abs mqt
  sqt skeyqt seedqt)) sqt skeyqt seedqt) /\
  (in_dom_map (proj (findelse_sid_abs mqt sqt skeyqt seedqt)) mqt)).

Axiom findelse_sid_abs_ident : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (sqt:(public_key* public_key* message*
  message)%type) (skeyqt:(map public_key secret_key)) (seedqt:(map
  (public_key* message)%type eph_key)), (~ ((findelse_sid_abs mqt sqt skeyqt
  seedqt) = (None:(option (public_key* public_key* message*
  message)%type)))) -> ((upd_map mqt sqt (get_map mqt
  (proj (findelse_sid_abs mqt sqt skeyqt seedqt)))) = mqt).

Axiom findelse_sid_skey_update : forall (m:(map (public_key* public_key*
  message* message)%type session_key)) (sid:(public_key* public_key* message*
  message)%type) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)) (p:public_key) (sk:secret_key), (~ (in_dom_map p
  skey)) -> ((findelse_sid_abs m sid skey seed) = (findelse_sid_abs m sid
  (upd_map skey p sk) seed)).

Axiom findelse_sid_seed_update : forall (m:(map (public_key* public_key*
  message* message)%type session_key)) (sid:(public_key* public_key* message*
  message)%type) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)) (p:(public_key* message)%type) (ek:eph_key),
  (~ (in_dom_map p seed)) -> ((findelse_sid_abs m sid skey
  seed) = (findelse_sid_abs m sid skey (upd_map seed p ek))).

Axiom findelse_g_abs_none_1 : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (str:session_string) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  (forall (sid:(public_key* public_key* message* message)%type),
  (in_dom_map sid mqt) -> ~ (eqS_abs str sid skeyqt seedqt)) ->
  ((findelse_g_abs mqt str skeyqt seedqt) = (None:(option (public_key*
  public_key* message* message)%type))).

Axiom findelse_g_abs_none_2 : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (str:session_string) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  ((findelse_g_abs mqt str skeyqt seedqt) = (None:(option (public_key*
  public_key* message* message)%type))) -> forall (sid:(public_key*
  public_key* message* message)%type), (in_dom_map sid mqt) -> ~ (eqS_abs str
  sid skeyqt seedqt).

Axiom findelse_g_abs_some : forall (mqt:(map (public_key* public_key*
  message* message)%type session_key)) (str:session_string) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  (~ ((findelse_g_abs mqt str skeyqt seedqt) = (None:(option (public_key*
  public_key* message* message)%type)))) -> ((eqS_abs str
  (proj (findelse_g_abs mqt str skeyqt seedqt)) skeyqt seedqt) /\
  (in_dom_map (proj (findelse_g_abs mqt str skeyqt seedqt)) mqt)).

Axiom findelse_g_update_1 : forall (m:(map (public_key* public_key* message*
  message)%type session_key)) (skey:(map public_key secret_key)) (seed:(map
  (public_key* message)%type eph_key)) (sid:(public_key* public_key* message*
  message)%type) (sesskey:session_key), ~ ((findelse_g_abs (upd_map m sid
  sesskey) (gen_session_string_sid sid skey seed) skey seed) = (None:(option
  (public_key* public_key* message* message)%type))).

Axiom findelse_g_update_2 : forall (m:(map (public_key* public_key* message*
  message)%type session_key)) (str:session_string) (skey:(map public_key
  secret_key)) (seed:(map (public_key* message)%type eph_key))
  (sid:(public_key* public_key* message* message)%type)
  (sesskey:session_key), (~ ((gen_session_string_sid sid skey
  seed) = str)) -> ((~ ((findelse_g_abs m str skey seed) = (None:(option
  (public_key* public_key* message* message)%type)))) ->
  ~ ((findelse_g_abs (upd_map m sid sesskey) str skey seed) = (None:(option
  (public_key* public_key* message* message)%type)))).

Axiom findelse_sid_g_skey_update : forall (m:(map (public_key* public_key*
  message* message)%type session_key)) (str:session_string) (skey:(map
  public_key secret_key)) (seed:(map (public_key* message)%type eph_key))
  (p:public_key) (sk:secret_key), (~ (in_dom_map p skey)) ->
  ((findelse_g_abs m str skey seed) = (findelse_g_abs m str (upd_map skey p
  sk) seed)).

Axiom findelse_sid_g_seed_update : forall (m:(map (public_key* public_key*
  message* message)%type session_key)) (str:session_string) (skey:(map
  public_key secret_key)) (seed:(map (public_key* message)%type eph_key))
  (p:public_key) (X:message) (e:eph_key), (~ (in_dom_map (p, X) seed)) ->
  ((findelse_g_abs m str skey seed) = (findelse_g_abs m str skey
  (upd_map seed (p, X) e))).

Axiom findelse_sid_g : forall (m:(map (public_key* public_key* message*
  message)%type session_key)) (sid:(public_key* public_key* message*
  message)%type) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)), ((findelse_sid_abs m sid skey
  seed) = (findelse_g_abs m (gen_session_string_sid sid skey seed) skey
  seed)).

Axiom findelse_sid_g2 : forall (m:(map (public_key* public_key* message*
  message)%type session_key)) (sid:(public_key* public_key* message*
  message)%type) (sidqt:(public_key* public_key* message* message)%type)
  (h:session_key) (str:session_string) (skey:(map public_key secret_key))
  (seed:(map (public_key* message)%type eph_key)),
  (~ ((findelse_g_abs (upd_map (upd_map m sid h) sidqt h) str skey
  seed) = (findelse_sid_abs m sid skey seed))) -> (((findelse_g_abs m str
  skey seed) = (findelse_g_abs (upd_map (upd_map m sid h) sidqt h) str skey
  seed)) /\ ((get_map (upd_map (upd_map m sid h) sidqt h)
  (proj (findelse_g_abs (upd_map (upd_map m sid h) sidqt h) str skey
  seed))) = (get_map m (proj (findelse_g_abs (upd_map (upd_map m sid h) sidqt
  h) str skey seed))))).

Axiom findelse_h_abs_None_1 : forall (mqt:(map session_string session_key))
  (sid:(public_key* public_key* message* message)%type) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  ((findelse_h_abs mqt sid skeyqt seedqt) = (None:(option
  session_string))) -> forall (str:session_string), (in_dom_map str mqt) ->
  ~ (eqS_abs str sid skeyqt seedqt).

Axiom findelse_h_abs_None_2 : forall (mqt:(map session_string session_key))
  (sid:(public_key* public_key* message* message)%type) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  (forall (str:session_string), (in_dom_map str mqt) -> ~ (eqS_abs str sid
  skeyqt seedqt)) -> ((findelse_h_abs mqt sid skeyqt seedqt) = (None:(option
  session_string))).

Axiom findelse_h_abs_some : forall (mqt:(map session_string session_key))
  (sid:(public_key* public_key* message* message)%type) (skeyqt:(map
  public_key secret_key)) (seedqt:(map (public_key* message)%type eph_key)),
  (~ ((findelse_h_abs mqt sid skeyqt seedqt) = (None:(option
  session_string)))) -> ((eqS_abs (proj (findelse_h_abs mqt sid skeyqt
  seedqt)) sid skeyqt seedqt) /\ (in_dom_map (proj (findelse_h_abs mqt sid
  skeyqt seedqt)) mqt)).

Axiom findelse_sid_h_skey_update : forall (m:(map session_string
  session_key)) (sid:(public_key* public_key* message* message)%type)
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)) (p:public_key) (sk:secret_key), (~ (in_dom_map p skey)) ->
  ((findelse_h_abs m sid skey seed) = (findelse_h_abs m sid (upd_map skey p
  sk) seed)).

Axiom findelse_sid_h_seed_update : forall (m:(map session_string
  session_key)) (sid:(public_key* public_key* message* message)%type)
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)) (p:public_key) (X:message) (e:eph_key), (~ (in_dom_map (p, X)
  seed)) -> ((findelse_h_abs m sid skey seed) = (findelse_h_abs m sid skey
  (upd_map seed (p, X) e))).

Axiom findelse_h_eqS : forall (m:(map session_string session_key))
  (sid:(public_key* public_key* message* message)%type) (skey:(map public_key
  secret_key)) (seed:(map (public_key* message)%type eph_key)),
  (~ ((findelse_h_abs m sid skey seed) = (None:(option session_string)))) ->
  (((gen_session_string_sid sid skey seed) = (proj (findelse_h_abs m sid skey
  seed))) /\ (in_dom_map (proj (findelse_h_abs m sid skey seed)) m)).

Axiom findelse_g_update3 : forall (m:(map (public_key* public_key* message*
  message)%type session_key)) (str:session_string) (skey:(map public_key
  secret_key)) (seed:(map (public_key* message)%type eph_key))
  (sid:(public_key* public_key* message* message)%type)
  (sesskey:session_key), (~ (str = (gen_session_string_sid sid skey
  seed))) -> ((findelse_g_abs (upd_map m sid sesskey) str skey
  seed) = (findelse_g_abs m str skey seed)).

Axiom findelse_h_update_2 : forall (m:(map session_string session_key))
  (sid:(public_key* public_key* message* message)%type) (skey:(map public_key
  secret_key)) (seed:(map (public_key* message)%type eph_key))
  (sesskey:session_key) (str:session_string),
  (~ (str = (gen_session_string_sid sid skey seed))) ->
  ((findelse_h_abs (upd_map m str sesskey) sid skey seed) = (findelse_h_abs m
  sid skey seed)).

Axiom match_string_eq : forall (sqt:(public_key* public_key* message*
  message)%type) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)), ((gen_session_string_sid ((sndpart sqt),
  (fstpart sqt), (sndmsg sqt), (fstmsg sqt)) skey
  seed) = (gen_session_string_sid sqt skey seed)).

Axiom get_upd_map_jm : forall (qtb:Type) (qta:Type), forall (m:(map qta qtb))
  (a1:qta) (a2:qta) (b:qtb) (c:qtb), ((a1 = a2) -> (b = c)) ->
  (((~ (a1 = a2)) -> ((get_map m a2) = c)) -> ((get_map (upd_map m a1 b)
  a2) = c)).

Axiom fresh_sid_def : forall (sid:(public_key* public_key* message*
  message)%type) (corrupt:(map public_key bool)) (complete_session:(map
  (public_key* message)%type (public_key* message* bool)%type))
  (incomplete_session:(map (public_key* message)%type (public_key*
  bool)%type)), (fresh_sid_op sid corrupt complete_session
  incomplete_session) <-> (fresh_sid sid corrupt complete_session
  incomplete_session).

Axiom fresh3_def : forall (sid:(public_key* public_key* message*
  message)%type) (corrupt:(map public_key bool)) (complete_session:(map
  (public_key* message)%type (public_key* message* bool)%type))
  (incomplete_session:(map (public_key* message)%type (public_key*
  bool)%type)), (fresh_sid3_op sid corrupt complete_session
  incomplete_session) <-> (fresh_sid3 sid corrupt complete_session
  incomplete_session).

Axiom fresh2_def : forall (sid:(public_key* public_key* message*
  message)%type) (corrupt:(map public_key bool)), (fresh_sid2_op sid
  corrupt) <-> (fresh_sid2 sid corrupt).

Axiom fresh1_def : forall (sid:(public_key* public_key* message*
  message)%type) (corrupt:(map public_key bool)) (complete_session:(map
  (public_key* message)%type (public_key* message* bool)%type))
  (incomplete_session:(map (public_key* message)%type (public_key*
  bool)%type)), (fresh_sid1_op sid corrupt complete_session
  incomplete_session) <-> (fresh_sid1 sid corrupt complete_session
  incomplete_session).

Axiom fresh11_def : forall (sid:(public_key* public_key* message*
  message)%type) (corrupt:(map public_key bool)) (complete_session:(map
  (public_key* message)%type (public_key* message* bool)%type))
  (incomplete_session:(map (public_key* message)%type (public_key*
  bool)%type)), (fresh_sid11_op sid corrupt complete_session
  incomplete_session) <-> (fresh_sid11 sid corrupt complete_session
  incomplete_session).

Axiom fresh_def : forall (tested_sessions:(map (public_key* public_key*
  message* message)%type session_key)) (corrupt:(map public_key bool))
  (complete_session:(map (public_key* message)%type (public_key* message*
  bool)%type)) (incomplete_session:(map (public_key* message)%type
  (public_key* bool)%type)), (fresh tested_sessions corrupt complete_session
  incomplete_session) <-> (fresh_op tested_sessions corrupt complete_session
  incomplete_session).

Axiom qPart_range : (1%Z <  qPart)%Z.

Axiom qSess_range : (0%Z <  qSess)%Z.

Axiom coll_session_id_def : forall (SIDL:(list (public_key* public_key*
  message* message)%type)) (skey:(map public_key secret_key)) (seed:(map
  (public_key* message)%type eph_key)), (coll_session_id SIDL skey seed) <->
  exists x:(public_key* public_key* message* message)%type,
  exists xqt:(public_key* public_key* message* message)%type, (mem x SIDL) /\
  ((mem xqt SIDL) /\ (((gen_session_string_sid x skey
  seed) = (gen_session_string_sid xqt skey seed)) /\ ~ (matching_session_id x
  xqt))).

Axiom eqS_abs_oracle : forall (str:session_string) (sid:(public_key*
  public_key* message* message)%type) (skey:(map public_key secret_key))
  (seed:(map (public_key* message)%type eph_key)), ((eqS_abs str sid skey
  seed) -> ((~ (eqS_oracle str sid)) -> (true = false))) /\ ((~ (eqS_abs str
  sid skey seed)) -> ((eqS_oracle str sid) -> (false = true))).

Axiom same_session_string_abs_oracle : forall (sid:(public_key* public_key*
  message* message)%type) (sidqt:(public_key* public_key* message*
  message)%type) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)), ((same_session_string_abs sid sidqt skey seed) ->
  ((~ (same_session_string_oracle sid sidqt)) -> (true = false))) /\
  ((~ (same_session_string_abs sid sidqt skey seed)) ->
  ((same_session_string_oracle sid sidqt) -> (false = true))).

Axiom same_session_string_sym : forall (sid:(public_key* public_key* message*
  message)%type) (sidqt:(public_key* public_key* message* message)%type),
  ((same_session_string_oracle sid sidqt) ->
  ((~ (same_session_string_oracle sidqt sid)) -> (true = false))) /\
  ((~ (same_session_string_oracle sid sidqt)) ->
  ((same_session_string_oracle sidqt sid) -> (false = true))).

Axiom wingame13_def : forall (sid:(public_key* public_key* message*
  message)%type) (str:session_string) (skey:(map public_key secret_key))
  (seed:(map (public_key* message)%type eph_key)) (crpt:(map public_key
  bool)) (cs:(map (public_key* message)%type (public_key* message*
  bool)%type)) (ics:(map (public_key* message)%type (public_key*
  bool)%type)), (wingame13 sid str skey seed crpt cs ics) <->
  (((gen_session_string_sid sid skey seed) = str) /\ ((fresh_sid sid crpt cs
  ics) /\ ((in_dom_map (fstpart sid) skey) /\ (in_dom_map (sndpart sid)
  skey)))).

Axiom string_coll_op_def : forall (m1:(list session_string)) (m2:(list
  session_string)), (string_coll_op m1 m2) <-> (string_coll m1 m2).

Axiom asd : forall (s:(public_key* public_key* message* message)%type)
  (sidl:(list (public_key* public_key* message* message)%type)) (skey:(map
  public_key secret_key)) (seed:(map (public_key* message)%type eph_key)),
  (~ (coll_session_id (Cons s sidl) skey seed)) -> ((~ (coll_session_id sidl
  skey seed)) /\ forall (sqt:(public_key* public_key* message*
  message)%type), (mem sqt sidl) -> ((~ ((gen_session_string_sid sqt skey
  seed) = (gen_session_string_sid s skey seed))) \/ (matching_session_id s
  sqt))).

Axiom guess_session_string_def : forall (ts:(map (public_key* public_key*
  message* message)%type session_key)) (argLH:(list session_string))
  (skey:(map public_key secret_key)) (seed:(map (public_key* message)%type
  eph_key)), (guess_session_string ts argLH skey seed) <->
  exists s:(public_key* public_key* message* message)%type, (in_dom_map s
  ts) /\ (mem (gen_session_string_sid s skey seed) argLH).

Axiom coll_guess : forall (ts:(map (public_key* public_key* message*
  message)%type session_key)) (argLH:(list session_string)) (argLHT:(list
  session_string)) (skey:(map public_key secret_key)) (seed:(map (public_key*
  message)%type eph_key)), (forall (str:session_string), (mem str argLHT) ->
  exists s:(public_key* public_key* message* message)%type, (in_dom_map s
  ts) /\ ((gen_session_string_sid s skey seed) = str)) ->
  ((string_coll_op argLH argLHT) -> (guess_session_string ts argLH skey
  seed)).

Axiom in_dom_upd_elim : forall (qta:Type) (qtb:Type), forall (m:(map qta
  qtb)) (x:qta) (y:qtb) (z:qta), (in_dom_map x (upd_map m z y)) ->
  ((x = z) \/ (in_dom_map x m)).

(* YOU MAY EDIT THE CONTEXT BELOW *)

(* DO NOT EDIT BELOW *)

Theorem collisions : forall (sid_queries2:(list (public_key* public_key*
  message* message)%type)) (skey2:(map public_key secret_key)) (seed2:(map
  (public_key* message)%type eph_key)) (tested_session2:(map (public_key*
  public_key* message* message)%type session_key)) (argLH1:(list
  session_string)) (argLH2:(list session_string)) (keys_revealed2:(map
  (public_key* public_key* message* message)%type bool)),
  (forall (sid:(public_key* public_key* message* message)%type),
  (in_dom_map sid tested_session2) -> (mem sid sid_queries2)) ->
  ((forall (str:session_string), (mem str argLH1) -> ((mem str argLH2) \/
  exists sid:(public_key* public_key* message* message)%type, (mem sid
  sid_queries2) /\ ((in_dom_map sid keys_revealed2) /\
  (((get_map keys_revealed2 sid) = true) /\ ((gen_session_string_sid sid
  skey2 seed2) = str))))) -> ((forall (sid:(public_key* public_key* message*
  message)%type), (in_dom_map sid tested_session2) ->
  ((~ ((get_map keys_revealed2 sid) = true)) /\ ~ ((get_map keys_revealed2
  (get_matching_session sid)) = true))) ->
  ((guess_session_string tested_session2 argLH1 skey2 seed2) ->
  ((guess_session_string tested_session2 argLH2 skey2 seed2) \/
  (coll_session_id sid_queries2 skey2 seed2))))).
(* YOU MAY EDIT THE PROOF BELOW *)
Proof.
 intros.
 rewrite guess_session_string_def in H2.
 destruct H2 as [sid [H2 H3]].
 destruct (H0 _ H3) as [ H4 |[sid' [H5 [H6 [H7 H8]]]]].
 left;rewrite guess_session_string_def;exists sid;split;auto.
 right.
 rewrite coll_session_id_def.
 exists sid;exists sid'.
 repeat split;auto.
 intros H9.
 destruct (H1 _ H2) as [H10 H11]. 
 unfold matching_session_id in H9.
 destruct H9.
 rewrite H4 in H10.
 apply H10;auto.
 rewrite H4 in H11.
 apply H11;auto.
 destruct sid'.
 destruct p.
 destruct p.
 simpl.
 auto.
Qed.
(* DO NOT EDIT BELOW *)


