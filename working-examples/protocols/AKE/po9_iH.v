(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Reals Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Dp_hint bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Dp_hint bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Dp_hint bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Dp_hint bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Dp_hint ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Dp_hint ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Dp_hint lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Dp_hint le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Dp_hint gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Dp_hint ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Dp_hint eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Dp_hint neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Dp_hint abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Dp_hint abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Dp_hint int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Dp_hint int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Dp_hint int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Dp_hint int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Dp_hint math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Dp_hint math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Dp_hint computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Dp_hint computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Dp_hint computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Dp_hint computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Dp_hint computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Dp_hint computer_rounds_toward_zero.

(*Why logic*) Definition lt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Dp_hint truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Dp_hint truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Dp_hint lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Dp_hint le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Dp_hint gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Dp_hint ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Dp_hint eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Dp_hint neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Dp_hint real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Dp_hint real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Dp_hint real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Dp_hint real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Dp_hint sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Dp_hint sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Dp_hint sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Dp_hint abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Dp_hint abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Dp_hint log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Dp_hint exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Dp_hint prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Dp_hint abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Dp_hint poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Dp_hint poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Dp_hint not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Dp_hint bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Dp_hint not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Dp_hint surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Dp_hint fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Dp_hint snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Dp_hint pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Dp_hint None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Dp_hint Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Dp_hint Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Dp_hint Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Dp_hint Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Dp_hint Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Dp_hint Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Dp_hint in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Dp_hint in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Dp_hint in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Dp_hint length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Dp_hint length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Dp_hint length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Dp_hint head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Dp_hint tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Dp_hint Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Dp_hint Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Dp_hint get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Dp_hint get_upd_map_diff.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Dp_hint upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Dp_hint upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Dp_hint upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true <-> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Dp_hint in_dom_upd_map.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Dp_hint in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Dp_hint upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Dp_hint upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Dp_hint in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Dp_hint in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Dp_hint in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Dp_hint inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A1 A2)) = false).
Admitted.
Dp_hint empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A2 A1)) = false).
Admitted.
Dp_hint empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Dp_hint triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Dp_hint div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Dp_hint real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Dp_hint real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Dp_hint rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Dp_hint rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Dp_hint rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Dp_hint rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Dp_hint rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Dp_hint rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Dp_hint rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Dp_hint real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Dp_hint real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Dp_hint real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Dp_hint real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Dp_hint real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Dp_hint real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Dp_hint real_of_int_12.

(*Why type*) Definition session: Set.
Admitted.

(*Why type*) Definition secret_key: Set.
Admitted.

(*Why type*) Definition public_key: Set.
Admitted.

(*Why type*) Definition message: Set.
Admitted.

(*Why type*) Definition session_string: Set.
Admitted.

(*Why type*) Definition session_key: Set.
Admitted.

(*Why type*) Definition session_id: Set.
Admitted.

(*Why type*) Definition eph_key: Set.
Admitted.

(*Why type*) Definition session_descr: Set.
Admitted.

(*Why logic*) Definition gen_secret_key : Z -> secret_key.
Admitted.

(*Why logic*) Definition gpk : secret_key -> public_key.
Admitted.

(*Why logic*) Definition gen_session_key : Z -> session_key.
Admitted.

(*Why logic*) Definition mk_sid :
  public_key -> public_key -> message -> message -> session_id.
Admitted.

(*Why logic*) Definition fstpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition sndpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition fstmsg : session_id -> message.
Admitted.

(*Why logic*) Definition sndmsg : session_id -> message.
Admitted.

(*Why logic*) Definition isSome_id : (option session_id) -> bool.
Admitted.

(*Why logic*) Definition isSome_string : (option session_string) -> bool.
Admitted.

(*Why logic*) Definition gen_eph_key : Z -> eph_key.
Admitted.

(*Why logic*) Definition inp : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition out_noclash : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition gen_session_string :
  secret_key -> eph_key -> public_key -> message -> session_string.
Admitted.

(*Why logic*) Definition gen_session_string_sid :
  session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> session_string.
Admitted.

(*Why logic*) Definition mk_session_descr :
  public_key -> message -> bool -> bool -> bool -> session_descr.
Admitted.

(*Why logic*) Definition session_part : session_descr -> public_key.
Admitted.

(*Why logic*) Definition session_msg : session_descr -> message.
Admitted.

(*Why logic*) Definition session_eph_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_key_reveal_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_test_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition same_session_string_abs :
  session_id -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition eqS_abs :
  session_string -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition findelse_sid_abs :
  (map session_id session_key) -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_g_abs :
  (map session_id session_key) -> session_string
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_h_abs :
  (map session_string session_key) -> session_id
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_string).
Admitted.

(*Why logic*) Definition dummy : secret_key.
Admitted.

(*Why logic*) Definition dummy_session_key : session_key.
Admitted.

(*Why logic*) Definition dummy_session_string : session_string.
Admitted.

(*Why logic*) Definition dummy_session_id : session_id.
Admitted.

(*Why logic*) Definition dummy_part : public_key.
Admitted.

(*Why logic*) Definition dummy_msg : message.
Admitted.

(*Why logic*) Definition dummy_string : session_string.
Admitted.

(*Why logic*) Definition dummy_sid : session_id.
Admitted.

(*Why predicate*) Definition invariant1  (LH1_513:(map session_string session_key)) (LH2_514:(map session_string session_key))
  := (forall (str_516:session_string),
      ((in_dom_map str_516 LH2_514) = true ->
       (in_dom_map str_516 LH1_513) = true /\
       (get_map LH1_513 str_516) = (get_map LH2_514 str_516))).

(*Why predicate*) Definition invariant2  (G2_517:(map session_id session_key)) (LH1_518:(map session_string session_key)) (skey2_519:(map public_key secret_key)) (seed2_520:(map (prod message public_key) eph_key))
  := (forall (str_524:session_string),
      (forall (fer_sid_523:session_id),
       ((findelse_g_abs G2_517 str_524 skey2_519 seed2_520) =
        (Some fer_sid_523) -> (in_dom_map str_524 LH1_518) = true /\
        (get_map LH1_518 str_524) = (get_map G2_517 fer_sid_523)))).

(*Why predicate*) Definition invariant3  (G2_525:(map session_id session_key)) (LH1_526:(map session_string session_key)) (LH2_527:(map session_string session_key)) (skey2_528:(map public_key secret_key)) (seed2_529:(map (prod message public_key) eph_key))
  := (forall (str_531:session_string),
      ((in_dom_map str_531 LH1_526) = true ->
       (in_dom_map str_531 LH2_527) = true \/
       ~(findelse_g_abs G2_525 str_531 skey2_528 seed2_529) =
        (@None session_id))).

(*Why predicate*) Definition invariant4  (G2_532:(map session_id session_key)) (LH1_533:(map session_string session_key)) (LH2_534:(map session_string session_key)) (skey2_535:(map public_key secret_key)) (seed2_536:(map (prod message public_key) eph_key))
  := (forall (str_538:session_string),
      ((in_dom_map str_538 LH2_534) = true \/
       ~(findelse_g_abs G2_532 str_538 skey2_535 seed2_536) =
        (@None session_id) ->
       (in_dom_map str_538 LH1_533) = true)).

(*Why axiom*) Lemma session_string_eq_dec :
  (forall (str1_5:session_string),
   (forall (str2_4:session_string), str1_5 = str2_4 \/ ~str1_5 = str2_4)).
Admitted.
Dp_hint session_string_eq_dec.

(*Why axiom*) Lemma session_neq_sym :
  (forall (str1_9:session_string),
   (forall (str2_8:session_string), (~str1_9 = str2_8 -> ~str2_8 = str1_9))).
Admitted.
Dp_hint session_neq_sym.

(*Why axiom*) Lemma session_id_eq_dec :
  (forall (sid1_13:session_id),
   (forall (sid2_12:session_id), sid1_13 = sid2_12 \/ ~sid1_13 = sid2_12)).
Admitted.
Dp_hint session_id_eq_dec.

(*Why axiom*) Lemma session_id_neq_sym :
  (forall (sid1_17:session_id),
   (forall (sid2_16:session_id), (~sid1_17 = sid2_16 -> ~sid2_16 = sid1_17))).
Admitted.
Dp_hint session_id_neq_sym.

(*Why axiom*) Lemma isSome_id_def :
  (forall (x_19:(option session_id)),
   ((isSome_id x_19) = true <-> ~x_19 = (@None session_id))).
Admitted.
Dp_hint isSome_id_def.

(*Why axiom*) Lemma isSome_id_def1 :
  (forall (x_21:session_id), (isSome_id (Some x_21)) = true).
Admitted.
Dp_hint isSome_id_def1.

(*Why axiom*) Lemma isSome_none : (isSome_id (@None session_id)) = false.
Admitted.
Dp_hint isSome_none.

(*Why axiom*) Lemma isSome_some :
  (forall (x_25:(option session_id)),
   ((isSome_id x_25) = true -> (exists y_24:session_id, x_25 = (Some y_24)))).
Admitted.
Dp_hint isSome_some.

(*Why axiom*) Lemma isSome_string_def :
  (forall (x_27:(option session_string)),
   ((isSome_string x_27) = true <-> ~x_27 = (@None session_string))).
Admitted.
Dp_hint isSome_string_def.

(*Why axiom*) Lemma isSome_string_some :
  (forall (x_31:(option session_string)),
   ((isSome_string x_31) = true ->
    (exists y_30:session_string, x_31 = (Some y_30)))).
Admitted.
Dp_hint isSome_string_some.

(*Why axiom*) Lemma isSome_string_none :
  (isSome_string (@None session_string)) = false.
Admitted.
Dp_hint isSome_string_none.

(*Why axiom*) Lemma session_id_proj :
  (forall (s_33:session_id),
   (mk_sid (fstpart s_33) (sndpart s_33) (fstmsg s_33) (sndmsg s_33)) = s_33).
Admitted.
Dp_hint session_id_proj.

(*Why axiom*) Lemma session_id_proj_fstpart :
  (forall (A_41:public_key),
   (forall (B_40:public_key),
    (forall (X_39:message),
     (forall (Y_38:message), (fstpart (mk_sid A_41 B_40 X_39 Y_38)) = A_41)))).
Admitted.
Dp_hint session_id_proj_fstpart.

(*Why axiom*) Lemma session_id_proj_sndpart :
  (forall (A_49:public_key),
   (forall (B_48:public_key),
    (forall (X_47:message),
     (forall (Y_46:message), (sndpart (mk_sid A_49 B_48 X_47 Y_46)) = B_48)))).
Admitted.
Dp_hint session_id_proj_sndpart.

(*Why axiom*) Lemma session_id_proj_fstmsg :
  (forall (A_57:public_key),
   (forall (B_56:public_key),
    (forall (X_55:message),
     (forall (Y_54:message), (fstmsg (mk_sid A_57 B_56 X_55 Y_54)) = X_55)))).
Admitted.
Dp_hint session_id_proj_fstmsg.

(*Why axiom*) Lemma session_id_proj_sndmsg :
  (forall (A_65:public_key),
   (forall (B_64:public_key),
    (forall (X_63:message),
     (forall (Y_62:message), (sndmsg (mk_sid A_65 B_64 X_63 Y_62)) = Y_62)))).
Admitted.
Dp_hint session_id_proj_sndmsg.

(*Why axiom*) Lemma session_id_eq :
  (forall (s_69:session_id),
   (forall (s'_68:session_id),
    (poly_eq s_69 s'_68) =
    (bool_and
     (bool_and
      (bool_and
       (poly_eq (fstpart s_69) (fstpart s'_68)) (poly_eq
                                                 (sndpart s_69) (sndpart
                                                                 s'_68))) (
      poly_eq (fstmsg s_69) (fstmsg s'_68))) (poly_eq
                                              (sndmsg s_69) (sndmsg s'_68))))).
Admitted.
Dp_hint session_id_eq.

(*Why axiom*) Lemma G_eq :
  (forall (m_79:(map session_id session_key)),
   (forall (a_78:session_id),
    (forall (b_77:session_key),
     (forall (sid_76:session_id),
      (forall (k_75:session_key),
       ((in_dom_map sid_76 (upd_map m_79 a_78 b_77)) = true /\
        (get_map (upd_map m_79 a_78 b_77) sid_76) = k_75 <-> sid_76 = a_78 /\
        b_77 = k_75 \/ (~sid_76 = a_78 /\ (in_dom_map sid_76 m_79) = true) /\
        (get_map m_79 sid_76) = k_75)))))).
Admitted.
Dp_hint G_eq.

(*Why axiom*) Lemma H_eq :
  (forall (m_89:(map session_string session_key)),
   (forall (a_88:session_string),
    (forall (b_87:session_key),
     (forall (sstr_86:session_string),
      (forall (k_85:session_key),
       ((in_dom_map sstr_86 (upd_map m_89 a_88 b_87)) = true /\
        (get_map (upd_map m_89 a_88 b_87) sstr_86) = k_85 <->
        sstr_86 = a_88 /\ b_87 = k_85 \/ (~sstr_86 = a_88 /\
        (in_dom_map sstr_86 m_89) = true) /\ (get_map m_89 sstr_86) = k_85)))))).
Admitted.
Dp_hint H_eq.

(*Why axiom*) Lemma gen_session_string_sid_abs :
  (forall (sid_95:session_id),
   (forall (skey_94:(map public_key secret_key)),
    (forall (seed_93:(map (prod message public_key) eph_key)),
     (gen_session_string_sid sid_95 skey_94 seed_93) =
     (gen_session_string
      (get_map skey_94 (fstpart sid_95)) (get_map
                                          seed_93 (pair
                                                   (fstmsg sid_95) (fstpart
                                                                    sid_95))) (
      sndpart sid_95) (sndmsg sid_95))))).
Admitted.
Dp_hint gen_session_string_sid_abs.

(*Why axiom*) Lemma session_descr_proj :
  (forall (s_97:session_descr),
   (mk_session_descr
    (session_part s_97) (session_msg s_97) (session_eph_flag s_97) (session_key_reveal_flag
                                                                    s_97) (
    session_test_flag s_97)) =
   s_97).
Admitted.
Dp_hint session_descr_proj.

(*Why axiom*) Lemma session_descr_part :
  (forall (A_107:public_key),
   (forall (X_106:message),
    (forall (ef_105:bool),
     (forall (krf_104:bool),
      (forall (tf_103:bool),
       (session_part (mk_session_descr A_107 X_106 ef_105 krf_104 tf_103)) =
       A_107))))).
Admitted.
Dp_hint session_descr_part.

(*Why axiom*) Lemma session_descr_msg :
  (forall (A_117:public_key),
   (forall (X_116:message),
    (forall (ef_115:bool),
     (forall (krf_114:bool),
      (forall (tf_113:bool),
       (session_msg (mk_session_descr A_117 X_116 ef_115 krf_114 tf_113)) =
       X_116))))).
Admitted.
Dp_hint session_descr_msg.

(*Why axiom*) Lemma session_descr_eph :
  (forall (A_127:public_key),
   (forall (X_126:message),
    (forall (ef_125:bool),
     (forall (krf_124:bool),
      (forall (tf_123:bool),
       (session_eph_flag (mk_session_descr A_127 X_126 ef_125 krf_124 tf_123)) =
       ef_125))))).
Admitted.
Dp_hint session_descr_eph.

(*Why axiom*) Lemma session_descr_key_reveal_flag :
  (forall (A_137:public_key),
   (forall (X_136:message),
    (forall (ef_135:bool),
     (forall (krf_134:bool),
      (forall (tf_133:bool),
       (session_key_reveal_flag
        (mk_session_descr A_137 X_136 ef_135 krf_134 tf_133)) =
       krf_134))))).
Admitted.
Dp_hint session_descr_key_reveal_flag.

(*Why axiom*) Lemma session_descr_test_flag :
  (forall (A_147:public_key),
   (forall (X_146:message),
    (forall (ef_145:bool),
     (forall (krf_144:bool),
      (forall (tf_143:bool),
       (session_test_flag
        (mk_session_descr A_147 X_146 ef_145 krf_144 tf_143)) =
       tf_143))))).
Admitted.
Dp_hint session_descr_test_flag.

(*Why axiom*) Lemma session_descr_eq :
  (forall (s_151:session_descr),
   (forall (s'_150:session_descr),
    (poly_eq s_151 s'_150) =
    (bool_and
     (bool_and
      (bool_and
       (bool_and
        (poly_eq (session_part s_151) (session_part s'_150)) (poly_eq
                                                              (session_msg
                                                               s_151) (
                                                              session_msg
                                                              s'_150))) (
       poly_eq (session_eph_flag s_151) (session_eph_flag s'_150))) (
      poly_eq
      (session_key_reveal_flag s_151) (session_key_reveal_flag s'_150))) (
     poly_eq (session_test_flag s_151) (session_test_flag s'_150))))).
Admitted.
Dp_hint session_descr_eq.

(*Why axiom*) Lemma same_string_def1 :
  (forall (sid_159:session_id),
   (forall (sid'_158:session_id),
    (forall (skey_157:(map public_key secret_key)),
     (forall (seed_156:(map (prod message public_key) eph_key)),
      ((same_session_string_abs sid_159 sid'_158 skey_157 seed_156) = true ->
       (gen_session_string_sid sid_159 skey_157 seed_156) =
       (gen_session_string_sid sid'_158 skey_157 seed_156)))))).
Admitted.
Dp_hint same_string_def1.

(*Why axiom*) Lemma same_string_def2 :
  (forall (sid_167:session_id),
   (forall (sid'_166:session_id),
    (forall (skey_165:(map public_key secret_key)),
     (forall (seed_164:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_167 skey_165 seed_164) =
       (gen_session_string_sid sid'_166 skey_165 seed_164) ->
       (same_session_string_abs sid_167 sid'_166 skey_165 seed_164) = true))))).
Admitted.
Dp_hint same_string_def2.

(*Why axiom*) Lemma eqS_def1 :
  (forall (str_175:session_string),
   (forall (sid_174:session_id),
    (forall (skey_173:(map public_key secret_key)),
     (forall (seed_172:(map (prod message public_key) eph_key)),
      ((eqS_abs str_175 sid_174 skey_173 seed_172) = true ->
       (gen_session_string_sid sid_174 skey_173 seed_172) = str_175))))).
Admitted.
Dp_hint eqS_def1.

(*Why axiom*) Lemma eqS_def2 :
  (forall (str_183:session_string),
   (forall (sid_182:session_id),
    (forall (skey_181:(map public_key secret_key)),
     (forall (seed_180:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_182 skey_181 seed_180) = str_183 ->
       (eqS_abs str_183 sid_182 skey_181 seed_180) = true))))).
Admitted.
Dp_hint eqS_def2.

(*Why axiom*) Lemma findelse_sid_abs_none1 :
  (forall (m'_193:(map session_id session_key)),
   (forall (s'_192:session_id),
    (forall (skey'_191:(map public_key secret_key)),
     (forall (seed'_190:(map (prod message public_key) eph_key)),
      ((findelse_sid_abs m'_193 s'_192 skey'_191 seed'_190) =
       (@None session_id) ->
       (forall (x_189:session_id),
        ((in_dom_map x_189 m'_193) = true ->
         ~(same_session_string_abs x_189 s'_192 skey'_191 seed'_190) = true))))))).
Admitted.
Dp_hint findelse_sid_abs_none1.

(*Why axiom*) Lemma findelse_sid_abs_none2 :
  (forall (m'_203:(map session_id session_key)),
   (forall (s'_202:session_id),
    (forall (skey'_201:(map public_key secret_key)),
     (forall (seed'_200:(map (prod message public_key) eph_key)),
      ((forall (x_199:session_id),
        ((in_dom_map x_199 m'_203) = true ->
         ~(same_session_string_abs x_199 s'_202 skey'_201 seed'_200) = true)) ->
       (findelse_sid_abs m'_203 s'_202 skey'_201 seed'_200) =
       (@None session_id)))))).
Admitted.
Dp_hint findelse_sid_abs_none2.

(*Why axiom*) Lemma findelse_sid_abs_some :
  (forall (m'_213:(map session_id session_key)),
   (forall (s'_212:session_id),
    (forall (skey'_211:(map public_key secret_key)),
     (forall (seed'_210:(map (prod message public_key) eph_key)),
      (forall (opres_209:(option session_id)),
       ((findelse_sid_abs m'_213 s'_212 skey'_211 seed'_210) = opres_209 ->
        (~opres_209 = (@None session_id) ->
         (same_session_string_abs (proj opres_209) s'_212 skey'_211 seed'_210) =
         true /\ (in_dom_map (proj opres_209) m'_213) = true))))))).
Admitted.
Dp_hint findelse_sid_abs_some.

(*Why axiom*) Lemma findelse_sid_abs_ident :
  (forall (m'_221:(map session_id session_key)),
   (forall (s'_220:session_id),
    (forall (skey'_219:(map public_key secret_key)),
     (forall (seed'_218:(map (prod message public_key) eph_key)),
      (~(findelse_sid_abs m'_221 s'_220 skey'_219 seed'_218) =
        (@None session_id) ->
       (upd_map
        m'_221 s'_220 (get_map
                       m'_221 (proj
                               (findelse_sid_abs
                                m'_221 s'_220 skey'_219 seed'_218)))) =
       m'_221))))).
Admitted.
Dp_hint findelse_sid_abs_ident.

(*Why axiom*) Lemma findelse_g_abs_none_1 :
  (forall (m'_231:(map session_id session_key)),
   (forall (str_230:session_string),
    (forall (skey'_229:(map public_key secret_key)),
     (forall (seed'_228:(map (prod message public_key) eph_key)),
      ((forall (sid_227:session_id),
        ((in_dom_map sid_227 m'_231) = true ->
         ~(eqS_abs str_230 sid_227 skey'_229 seed'_228) = true)) ->
       (findelse_g_abs m'_231 str_230 skey'_229 seed'_228) =
       (@None session_id)))))).
Admitted.
Dp_hint findelse_g_abs_none_1.

(*Why axiom*) Lemma findelse_g_abs_none_2 :
  (forall (m'_241:(map session_id session_key)),
   (forall (str_240:session_string),
    (forall (skey'_239:(map public_key secret_key)),
     (forall (seed'_238:(map (prod message public_key) eph_key)),
      ((findelse_g_abs m'_241 str_240 skey'_239 seed'_238) =
       (@None session_id) ->
       (forall (sid_237:session_id),
        ((in_dom_map sid_237 m'_241) = true ->
         ~(eqS_abs str_240 sid_237 skey'_239 seed'_238) = true))))))).
Admitted.
Dp_hint findelse_g_abs_none_2.

(*Why axiom*) Lemma findelse_g_abs_some :
  (forall (m'_251:(map session_id session_key)),
   (forall (str_250:session_string),
    (forall (skey'_249:(map public_key secret_key)),
     (forall (seed'_248:(map (prod message public_key) eph_key)),
      (forall (res_247:(option session_id)),
       ((findelse_g_abs m'_251 str_250 skey'_249 seed'_248) = res_247 ->
        (~res_247 = (@None session_id) ->
         (eqS_abs str_250 (proj res_247) skey'_249 seed'_248) = true /\
         (in_dom_map (proj res_247) m'_251) = true))))))).
Admitted.
Dp_hint findelse_g_abs_some.

(*Why axiom*) Lemma findelse_g_update_1 :
  (forall (m_263:(map session_id session_key)),
   (forall (str_262:session_string),
    (forall (skey_261:(map public_key secret_key)),
     (forall (seed_260:(map (prod message public_key) eph_key)),
      (forall (sid_259:session_id),
       (forall (sesskey_258:session_key),
        ((gen_session_string_sid sid_259 skey_261 seed_260) = str_262 ->
         ~(findelse_g_abs
           (upd_map m_263 sid_259 sesskey_258) str_262 skey_261 seed_260) =
          (@None session_id)))))))).
Admitted.
Dp_hint findelse_g_update_1.

(*Why axiom*) Lemma findelse_sid_g :
  (forall (m_273:(map session_id session_key)),
   (forall (sid_272:session_id),
    (forall (str_271:session_string),
     (forall (skey_270:(map public_key secret_key)),
      (forall (seed_269:(map (prod message public_key) eph_key)),
       ((gen_session_string_sid sid_272 skey_270 seed_269) = str_271 ->
        (findelse_sid_abs m_273 sid_272 skey_270 seed_269) =
        (findelse_g_abs m_273 str_271 skey_270 seed_269))))))).
Admitted.
Dp_hint findelse_sid_g.

(*Why axiom*) Lemma findelse_sid_g2 :
  (forall (m_291:(map session_id session_key)),
   (forall (sid_290:session_id),
    (forall (sid'_289:session_id),
     (forall (opsid_288:(option session_id)),
      (forall (fer_sid_287:(option session_id)),
       (forall (h_286:session_key),
        (forall (str_285:session_string),
         (forall (skey_284:(map public_key secret_key)),
          (forall (seed_283:(map (prod message public_key) eph_key)),
           ((findelse_g_abs
             (upd_map (upd_map m_291 sid_290 h_286) sid'_289 h_286) str_285 skey_284 seed_283) =
            opsid_288 ->
            ((findelse_sid_abs m_291 sid_290 skey_284 seed_283) = fer_sid_287 ->
             (~opsid_288 = fer_sid_287 ->
              (findelse_g_abs m_291 str_285 skey_284 seed_283) = opsid_288 /\
              (get_map
               (upd_map (upd_map m_291 sid_290 h_286) sid'_289 h_286) (
               proj opsid_288)) =
              (get_map m_291 (proj opsid_288)))))))))))))).
Admitted.
Dp_hint findelse_sid_g2.

(*Why axiom*) Lemma findelse_h_abs_none_1 :
  (forall (m'_301:(map session_string session_key)),
   (forall (sid_300:session_id),
    (forall (skey'_299:(map public_key secret_key)),
     (forall (seed'_298:(map (prod message public_key) eph_key)),
      ((findelse_h_abs m'_301 sid_300 skey'_299 seed'_298) =
       (@None session_string) ->
       (forall (str_297:session_string),
        ((in_dom_map str_297 m'_301) = true ->
         ~(eqS_abs str_297 sid_300 skey'_299 seed'_298) = true))))))).
Admitted.
Dp_hint findelse_h_abs_none_1.

(*Why axiom*) Lemma findelse_h_abs_none_2 :
  (forall (m'_311:(map session_string session_key)),
   (forall (sid_310:session_id),
    (forall (skey'_309:(map public_key secret_key)),
     (forall (seed'_308:(map (prod message public_key) eph_key)),
      ((forall (str_307:session_string),
        ((in_dom_map str_307 m'_311) = true ->
         ~(eqS_abs str_307 sid_310 skey'_309 seed'_308) = true)) ->
       (findelse_h_abs m'_311 sid_310 skey'_309 seed'_308) =
       (@None session_string)))))).
Admitted.
Dp_hint findelse_h_abs_none_2.

(*Why axiom*) Lemma findelse_h_abs_some :
  (forall (m'_321:(map session_string session_key)),
   (forall (sid_320:session_id),
    (forall (skey'_319:(map public_key secret_key)),
     (forall (seed'_318:(map (prod message public_key) eph_key)),
      (forall (str_317:(option session_string)),
       ((findelse_h_abs m'_321 sid_320 skey'_319 seed'_318) = str_317 ->
        (~str_317 = (@None session_string) ->
         (eqS_abs (proj str_317) sid_320 skey'_319 seed'_318) = true /\
         (in_dom_map (proj str_317) m'_321) = true))))))).
Admitted.
Dp_hint findelse_h_abs_some.

(*Why axiom*) Lemma findelse_h_eqS :
  (forall (m_331:(map session_string session_key)),
   (forall (sid_330:session_id),
    (forall (skey_329:(map public_key secret_key)),
     (forall (seed_328:(map (prod message public_key) eph_key)),
      (forall (str_327:(option session_string)),
       ((findelse_h_abs m_331 sid_330 skey_329 seed_328) = str_327 ->
        (~str_327 = (@None session_string) ->
         (gen_session_string_sid sid_330 skey_329 seed_328) = (proj str_327) /\
         (in_dom_map (proj str_327) m_331) = true))))))).
Admitted.
Dp_hint findelse_h_eqS.

(*Why axiom*) Lemma isSome_id_ax :
  (forall (x_333:session_id), (isSome_id (Some x_333)) = true).
Admitted.
Dp_hint isSome_id_ax.

(*Why axiom*) Lemma isSome_string_ax :
  (forall (x_335:session_string), (isSome_string (Some x_335)) = true).
Admitted.
Dp_hint isSome_string_ax.

(*Why axiom*) Lemma findelse_g_update_2 :
  (forall (m_347:(map session_id session_key)),
   (forall (str_346:session_string),
    (forall (skey_345:(map public_key secret_key)),
     (forall (seed_344:(map (prod message public_key) eph_key)),
      (forall (sid_343:session_id),
       (forall (sesskey_342:session_key),
        (~str_346 = (gen_session_string_sid sid_343 skey_345 seed_344) ->
         (findelse_g_abs
          (upd_map m_347 sid_343 sesskey_342) str_346 skey_345 seed_344) =
         (findelse_g_abs m_347 str_346 skey_345 seed_344)))))))).
Admitted.
Dp_hint findelse_g_update_2.

(*Why axiom*) Lemma findelse_h_update_2 :
  (forall (m_359:(map session_string session_key)),
   (forall (sid_358:session_id),
    (forall (skey_357:(map public_key secret_key)),
     (forall (seed_356:(map (prod message public_key) eph_key)),
      (forall (sesskey_355:session_key),
       (forall (str_354:session_string),
        (~str_354 = (gen_session_string_sid sid_358 skey_357 seed_356) ->
         (findelse_h_abs
          (upd_map m_359 str_354 sesskey_355) sid_358 skey_357 seed_356) =
         (findelse_h_abs m_359 sid_358 skey_357 seed_356)))))))).
Admitted.
Dp_hint findelse_h_update_2.

(* Why obligation from file "easycrypt51a0bd.why", line 787, characters 0-1471: *)
(*Why goal*) Lemma implies_goal9 : 
  (forall (skey_436_711:(map public_key secret_key)),
   (forall (skey_365_710:(map public_key secret_key)),
    (forall (seed_438_709:(map (prod message public_key) eph_key)),
     (forall (seed_367_708:(map (prod message public_key) eph_key)),
      (forall (lam_446_707:session_string),
       (forall (lam_375_706:session_string),
        (forall (complete_sessions_432_705:(map (prod public_key message) session_descr)),
         (forall (complete_sessions_361_704:(map (prod public_key message) session_descr)),
          (forall (LH_437_703:(map session_string session_key)),
           (forall (LH_366_702:(map session_string session_key)),
            (forall (G_440_701:(map session_id session_key)),
             ((invariant1 LH_366_702 LH_437_703) ->
              ((invariant2 G_440_701 LH_366_702 skey_436_711 seed_438_709) ->
               ((invariant3
                 G_440_701 LH_366_702 LH_437_703 skey_436_711 seed_438_709) ->
                (skey_365_710 = skey_436_711 ->
                 (seed_367_708 = seed_438_709 ->
                  (complete_sessions_361_704 = complete_sessions_432_705 ->
                   (lam_375_706 = lam_446_707 ->
                    (forall (h_0_546:session_key),
                     (~(in_dom_map lam_446_707 LH_437_703) = true ->
                      (~(isSome_id
                         (findelse_g_abs
                          G_440_701 lam_446_707 skey_436_711 seed_438_709)) =
                        true ->
                       (~(in_dom_map lam_375_706 LH_366_702) = true ->
                        (invariant2
                         G_440_701 (upd_map LH_366_702 lam_375_706 h_0_546) skey_436_711 seed_438_709))))))))))))))))))))))).
Proof.
 Notation "P [ x ]" := (get_map P x) (at level 50).
 Notation "P [ x := y ]" := (upd_map P x y) (at level 50).
 Notation "( x , y )" := (pair x y).

 intros; intuition; subst; subst. 
 repeat match goal with | H:?x = ?x |- _ => clear H end.
 unfold invariant2.
 intros.
destruct (H0 _ _ H2).
destruct (session_string_eq_dec str_524 lam_446_707).
destruct H8;rewrite <- H5;auto.

rewrite upd_map_dom_diff,get_upd_map_diff;auto.
Save.

