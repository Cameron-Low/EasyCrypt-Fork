(* This file was originally generated by why.
   It can be modified; only the generated parts will be overwritten. *)
Require Export Why.

(*Why logic*) Definition bool_and : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_or : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_xor : bool -> bool -> bool.
Admitted.

(*Why logic*) Definition bool_not : bool -> bool.
Admitted.

(*Why axiom*) Lemma bool_and_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_and a b) = true <-> a = true /\ b = true))).
Admitted.
Print bool_and_def.

(*Why axiom*) Lemma bool_or_def :
  (forall (a:bool),
   (forall (b:bool), ((bool_or a b) = true <-> a = true \/ b = true))).
Admitted.
Print bool_or_def.

(*Why axiom*) Lemma bool_xor_def :
  (forall (a:bool), (forall (b:bool), ((bool_xor a b) = true <-> ~(a = b)))).
Admitted.
Print bool_xor_def.

(*Why axiom*) Lemma bool_not_def :
  (forall (a:bool), ((bool_not a) = true <-> a = false)).
Admitted.
Print bool_not_def.

(*Why logic*) Definition ite : forall (A1:Set), bool -> A1 -> A1 -> A1.
Admitted.
Implicit Arguments ite.

(*Why axiom*) Lemma ite_true :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else true x y) = x)).
Admitted.
Print ite_true.

(*Why axiom*) Lemma ite_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (if_then_else false x y) = y)).
Admitted.
Print ite_false.

(*Why logic*) Definition lt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition le_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition gt_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition ge_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition eq_int_bool : Z -> Z -> bool.
Admitted.

(*Why logic*) Definition neq_int_bool : Z -> Z -> bool.
Admitted.

(*Why axiom*) Lemma lt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((lt_int_bool x y) = true <-> x < y))).
Admitted.
Print lt_int_bool_axiom.

(*Why axiom*) Lemma le_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((le_int_bool x y) = true <-> x <= y))).
Admitted.
Print le_int_bool_axiom.

(*Why axiom*) Lemma gt_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((gt_int_bool x y) = true <-> x > y))).
Admitted.
Print gt_int_bool_axiom.

(*Why axiom*) Lemma ge_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((ge_int_bool x y) = true <-> x >= y))).
Admitted.
Print ge_int_bool_axiom.

(*Why axiom*) Lemma eq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((eq_int_bool x y) = true <-> x = y))).
Admitted.
Print eq_int_bool_axiom.

(*Why axiom*) Lemma neq_int_bool_axiom :
  (forall (x:Z), (forall (y:Z), ((neq_int_bool x y) = true <-> x <> y))).
Admitted.
Print neq_int_bool_axiom.

(*Why logic*) Definition abs_int : Z -> Z.
Admitted.

(*Why axiom*) Lemma abs_int_pos :
  (forall (x:Z), (x >= 0 -> (abs_int x) = x)).
Admitted.
Print abs_int_pos.

(*Why axiom*) Lemma abs_int_neg :
  (forall (x:Z), (x <= 0 -> (abs_int x) = (Zopp x))).
Admitted.
Print abs_int_neg.

(*Why logic*) Definition int_max : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition int_min : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma int_max_is_ge :
  (forall (x:Z), (forall (y:Z), (int_max x y) >= x /\ (int_max x y) >= y)).
Admitted.
Print int_max_is_ge.

(*Why axiom*) Lemma int_max_is_some :
  (forall (x:Z), (forall (y:Z), (int_max x y) = x \/ (int_max x y) = y)).
Admitted.
Print int_max_is_some.

(*Why axiom*) Lemma int_min_is_le :
  (forall (x:Z), (forall (y:Z), (int_min x y) <= x /\ (int_min x y) <= y)).
Admitted.
Print int_min_is_le.

(*Why axiom*) Lemma int_min_is_some :
  (forall (x:Z), (forall (y:Z), (int_min x y) = x \/ (int_min x y) = y)).
Admitted.
Print int_min_is_some.

(*Why logic*) Definition computer_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition computer_mod : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_div : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition math_mod : Z -> Z -> Z.
Admitted.

(*Why axiom*) Lemma math_div_mod :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> x = (y * (math_div x y) + (math_mod x y))))).
Admitted.
Print math_div_mod.

(*Why axiom*) Lemma math_mod_bound :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> 0 <= (math_mod x y) /\ (math_mod x y) < (abs_int y)))).
Admitted.
Print math_mod_bound.

(*Why axiom*) Lemma computer_div_mod :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> x = (y * (computer_div x y) + (computer_mod x y))))).
Admitted.
Print computer_div_mod.

(*Why axiom*) Lemma computer_div_bound :
  (forall (x:Z),
   (forall (y:Z),
    (x >= 0 /\ y > 0 -> 0 <= (computer_div x y) /\ (computer_div x y) <= x))).
Admitted.
Print computer_div_bound.

(*Why axiom*) Lemma computer_mod_bound :
  (forall (x:Z),
   (forall (y:Z), (y <> 0 -> (abs_int (computer_mod x y)) < (abs_int y)))).
Admitted.
Print computer_mod_bound.

(*Why axiom*) Lemma computer_mod_sign_pos :
  (forall (x:Z),
   (forall (y:Z), (x >= 0 /\ y <> 0 -> (computer_mod x y) >= 0))).
Admitted.
Print computer_mod_sign_pos.

(*Why axiom*) Lemma computer_mod_sign_neg :
  (forall (x:Z),
   (forall (y:Z), (x <= 0 /\ y <> 0 -> (computer_mod x y) <= 0))).
Admitted.
Print computer_mod_sign_neg.

(*Why axiom*) Lemma computer_rounds_toward_zero :
  (forall (x:Z),
   (forall (y:Z),
    (y <> 0 -> (abs_int ((computer_div x y) * y)) <= (abs_int x)))).
Admitted.
Print computer_rounds_toward_zero.

(*Why logic*) Require Export Reals. Definition lt_real  : R -> R -> Prop.
Admitted.

(*Why logic*) Definition le_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition gt_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition ge_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition eq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition neq_real : R -> R -> Prop.
Admitted.

(*Why logic*) Definition add_real : R -> R -> R.
Admitted.

(*Why logic*) Definition sub_real : R -> R -> R.
Admitted.

(*Why logic*) Definition mul_real : R -> R -> R.
Admitted.

(*Why logic*) Definition div_real : R -> R -> R.
Admitted.

(*Why logic*) Definition neg_real : R -> R.
Admitted.

(*Why logic*) Definition real_of_int : Z -> R.
Admitted.

(*Why axiom*) Lemma real_of_int_zero : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_zero.

(*Why axiom*) Lemma real_of_int_one : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_one.

(*Why axiom*) Lemma real_of_int_add :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x + y)) (Rplus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_add.

(*Why axiom*) Lemma real_of_int_sub :
  (forall (x:Z), (forall (y:Z), (eq (IZR (x - y)) (Rminus (IZR x) (IZR y))))).
Admitted.
Print real_of_int_sub.

(*Why logic*) Definition truncate_real_to_int : R -> Z.
Admitted.

(*Why axiom*) Lemma truncate_down_pos :
  (forall (x:R),
   ((Rge x (0)%R) -> (Rle (IZR (truncate_real_to_int x)) x) /\
    (Rlt x (IZR ((truncate_real_to_int x) + 1))))).
Admitted.
Print truncate_down_pos.

(*Why axiom*) Lemma truncate_up_neg :
  (forall (x:R),
   ((Rle x (0)%R) -> (Rlt (IZR ((truncate_real_to_int x) - 1)) x) /\
    (Rle x (IZR (truncate_real_to_int x))))).
Admitted.
Print truncate_up_neg.

(*Why logic*) Definition floor_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition ceil_real_to_int : R -> Z.
Admitted.

(*Why logic*) Definition lt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition le_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition gt_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition ge_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition eq_real_bool : R -> R -> bool.
Admitted.

(*Why logic*) Definition neq_real_bool : R -> R -> bool.
Admitted.

(*Why axiom*) Lemma lt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((lt_real_bool x y) = true <-> (Rlt x y)))).
Admitted.
Print lt_real_bool_axiom.

(*Why axiom*) Lemma le_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((le_real_bool x y) = true <-> (Rle x y)))).
Admitted.
Print le_real_bool_axiom.

(*Why axiom*) Lemma gt_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((gt_real_bool x y) = true <-> (Rgt x y)))).
Admitted.
Print gt_real_bool_axiom.

(*Why axiom*) Lemma ge_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((ge_real_bool x y) = true <-> (Rge x y)))).
Admitted.
Print ge_real_bool_axiom.

(*Why axiom*) Lemma eq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((eq_real_bool x y) = true <-> (eq x y)))).
Admitted.
Print eq_real_bool_axiom.

(*Why axiom*) Lemma neq_real_bool_axiom :
  (forall (x:R), (forall (y:R), ((neq_real_bool x y) = true <-> ~(eq x y)))).
Admitted.
Print neq_real_bool_axiom.

(*Why logic*) Definition real_max : R -> R -> R.
Admitted.

(*Why logic*) Definition real_min : R -> R -> R.
Admitted.

(*Why axiom*) Lemma real_max_is_ge :
  (forall (x:R),
   (forall (y:R), (Rge (real_max x y) x) /\ (Rge (real_max x y) y))).
Admitted.
Print real_max_is_ge.

(*Why axiom*) Lemma real_max_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_max x y) x) \/ (eq (real_max x y) y))).
Admitted.
Print real_max_is_some.

(*Why axiom*) Lemma real_min_is_le :
  (forall (x:R),
   (forall (y:R), (Rle (real_min x y) x) /\ (Rle (real_min x y) y))).
Admitted.
Print real_min_is_le.

(*Why axiom*) Lemma real_min_is_some :
  (forall (x:R),
   (forall (y:R), (eq (real_min x y) x) \/ (eq (real_min x y) y))).
Admitted.
Print real_min_is_some.

(*Why function*) Definition sqr_real  (x:R) := (Rmult x x).

(*Why logic*) Definition sqrt_real : R -> R.
Admitted.

(*Why axiom*) Lemma sqrt_pos :
  (forall (x:R), ((Rge x (0)%R) -> (Rge (sqrt x) (0)%R))).
Admitted.
Print sqrt_pos.

(*Why axiom*) Lemma sqrt_sqr :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqr_real (sqrt x)) x))).
Admitted.
Print sqrt_sqr.

(*Why axiom*) Lemma sqr_sqrt :
  (forall (x:R), ((Rge x (0)%R) -> (eq (sqrt (Rmult x x)) x))).
Admitted.
Print sqr_sqrt.

(*Why logic*) Definition pow_real : R -> R -> R.
Admitted.

(*Why logic*) Definition abs_real : R -> R.
Admitted.

(*Why axiom*) Lemma abs_real_pos :
  (forall (x:R), ((Rge x (0)%R) -> (eq (Rabs x) x))).
Admitted.
Print abs_real_pos.

(*Why axiom*) Lemma abs_real_neg :
  (forall (x:R), ((Rle x (0)%R) -> (eq (Rabs x) (Ropp x)))).
Admitted.
Print abs_real_neg.

(*Why logic*) Definition exp : R -> R.
Admitted.

(*Why logic*) Definition log : R -> R.
Admitted.

(*Why logic*) Definition log10 : R -> R.
Admitted.

(*Why axiom*) Lemma log_exp : (forall (x:R), (eq (log (exp x)) x)).
Admitted.
Print log_exp.

(*Why axiom*) Lemma exp_log :
  (forall (x:R), ((Rgt x (0)%R) -> (eq (exp (log x)) x))).
Admitted.
Print exp_log.

(*Why logic*) Definition cos : R -> R.
Admitted.

(*Why logic*) Definition sin : R -> R.
Admitted.

(*Why logic*) Definition tan : R -> R.
Admitted.

(*Why logic*) Definition pi : R.
Admitted.

(*Why logic*) Definition cosh : R -> R.
Admitted.

(*Why logic*) Definition sinh : R -> R.
Admitted.

(*Why logic*) Definition tanh : R -> R.
Admitted.

(*Why logic*) Definition acos : R -> R.
Admitted.

(*Why logic*) Definition asin : R -> R.
Admitted.

(*Why logic*) Definition atan : R -> R.
Admitted.

(*Why logic*) Definition atan2 : R -> R -> R.
Admitted.

(*Why logic*) Definition hypot : R -> R -> R.
Admitted.

(*Why axiom*) Lemma prod_pos :
  (forall (x:R),
   (forall (y:R),
    (((Rgt x (0)%R) /\ (Rgt y (0)%R) -> (Rgt (Rmult x y) (0)%R))) /\
    (((Rlt x (0)%R) /\ (Rlt y (0)%R) -> (Rgt (Rmult x y) (0)%R))))).
Admitted.
Print prod_pos.

(*Why axiom*) Lemma abs_minus :
  (forall (x:R), (eq (Rabs (Ropp x)) (Rabs x))).
Admitted.
Print abs_minus.

(*Why logic*) Definition pow_int : Z -> Z -> Z.
Admitted.

(*Why logic*) Definition poly_eq : forall (A1:Set), A1 -> A1 -> bool.
Admitted.
Implicit Arguments poly_eq.

(*Why axiom*) Lemma poly_eq_eq :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((poly_eq x y) = true <-> x = y))).
Admitted.
Print poly_eq_eq.

(*Why axiom*) Lemma poly_eq_refl :
  forall (A1:Set), (forall (x:A1), (poly_eq x x) = true).
Admitted.
Print poly_eq_refl.

(*Why axiom*) Lemma not_true_false :
  (forall (b:bool), (~(b = true) -> b = false)).
Admitted.
Print not_true_false.

(*Why axiom*) Lemma bool_not_false : (bool_not false) = true.
Admitted.
Print bool_not_false.

(*Why axiom*) Lemma not_eq_poly_eq_false :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), (~(x = y) -> (poly_eq x y) = false))).
Admitted.
Print not_eq_poly_eq_false.

(*Why type*) Definition prod: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition pair :
  forall (A1:Set), forall (A2:Set), A1 -> A2 -> (prod A1 A2).
Admitted.
Implicit Arguments pair.

(*Why logic*) Definition fst_prod :
  forall (A1:Set), forall (A2:Set), (prod A1 A2) -> A1.
Admitted.
Implicit Arguments fst_prod.

(*Why logic*) Definition snd_prod :
  forall (A1:Set), forall (A2:Set), (prod A2 A1) -> A1.
Admitted.
Implicit Arguments snd_prod.

(*Why axiom*) Lemma surjective_pairing :
  forall (A1:Set), forall (A2:Set),
  (forall (p:(prod A1 A2)), (pair (fst_prod p) (snd_prod p)) = p).
Admitted.
Print surjective_pairing.

(*Why axiom*) Lemma fst_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (fst_prod (pair a b)) = a)).
Admitted.
Print fst_pair.

(*Why axiom*) Lemma snd_pair :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (forall (b:A2), (snd_prod (pair a b)) = b)).
Admitted.
Print snd_pair.

(*Why axiom*) Lemma pair_inj :
  forall (A1:Set), forall (A2:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (b1:A2),
     (forall (b2:A2), ((pair a1 b1) = (pair a2 b2) -> a1 = a2 /\ b1 = b2))))).
Admitted.
Print pair_inj.

(*Why type*) Definition option: Set ->Set.
Admitted.

(*Why logic*) Definition None : forall (A1:Set), (option A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments None.
Unset Contextual Implicit.

(*Why logic*) Definition Some : forall (A1:Set), A1 -> (option A1).
Admitted.
Implicit Arguments Some.

(*Why logic*) Definition proj : forall (A1:Set), (option A1) -> A1.
Admitted.
Implicit Arguments proj.

(*Why axiom*) Lemma None_neq_Some :
  forall (A1:Set), (forall (x:A1), ~((@None A1) = (Some x))).
Admitted.
Print None_neq_Some.

(*Why axiom*) Lemma Some_inj :
  forall (A1:Set),
  (forall (x:A1), (forall (y:A1), ((Some x) = (Some y) -> x = y))).
Admitted.
Print Some_inj.

(*Why axiom*) Lemma Proj_Some :
  forall (A1:Set), (forall (x:A1), (proj (Some x)) = x).
Admitted.
Print Proj_Some.

(*Why axiom*) Lemma Proj_eq :
  forall (A1:Set),
  (forall (o1:(option A1)),
   (forall (o2:(option A1)),
    (~(o1 = (@None A1)) ->
     (~(o2 = (@None A1)) -> ((proj o1) = (proj o2) -> o1 = o2))))).
Admitted.
Print Proj_eq.

(*Why axiom*) Lemma Some_or_None :
  forall (A1:Set),
  (forall (o:(option A1)), o = (@None A1) \/ (exists x:A1, o = (Some x))).
Admitted.
Print Some_or_None.

(*Why type*) Definition list: Set ->Set.
Admitted.

(*Why logic*) Definition Nil : forall (A1:Set), (list A1).
Admitted.
Set Contextual Implicit.
Implicit Arguments Nil.
Unset Contextual Implicit.

(*Why logic*) Definition Cons :
  forall (A1:Set), A1 -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Cons.

(*Why logic*) Definition in_list : forall (A1:Set), A1 -> (list A1) -> bool.
Admitted.
Implicit Arguments in_list.

(*Why logic*) Definition length_list : forall (A1:Set), (list A1) -> Z.
Admitted.
Implicit Arguments length_list.

(*Why logic*) Definition head : forall (A1:Set), (list A1) -> A1.
Admitted.
Implicit Arguments head.

(*Why logic*) Definition tail : forall (A1:Set), (list A1) -> (list A1).
Admitted.
Implicit Arguments tail.

(*Why logic*) Definition Append :
  forall (A1:Set), (list A1) -> (list A1) -> (list A1).
Admitted.
Implicit Arguments Append.

(*Why axiom*) Lemma Nil_neq_Cons :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), ~((@Nil A1) = (Cons a l)))).
Admitted.
Print Nil_neq_Cons.

(*Why axiom*) Lemma Cons_inj :
  forall (A1:Set),
  (forall (a1:A1),
   (forall (a2:A1),
    (forall (l1:(list A1)),
     (forall (l2:(list A1)),
      ((Cons a1 l1) = (Cons a2 l2) -> a1 = a2 /\ l1 = l2))))).
Admitted.
Print Cons_inj.

(*Why axiom*) Lemma in_list_Nil :
  forall (A1:Set), (forall (a:A1), (in_list a (@Nil A1)) = false).
Admitted.
Print in_list_Nil.

(*Why axiom*) Lemma in_list_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (a':A1),
    (forall (l:(list A1)),
     (in_list a (Cons a' l)) = (bool_or (poly_eq a a') (in_list a l))))).
Admitted.
Print in_list_Cons.

(*Why axiom*) Lemma in_list_Append :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)),
     (in_list a (Append l1 l2)) = (bool_or (in_list a l1) (in_list a l2))))).
Admitted.
Print in_list_Append.

(*Why axiom*) Lemma length_nil :
  forall (A1:Set), (length_list (@Nil A1)) = 0.
Admitted.
Print length_nil.

(*Why axiom*) Lemma length_cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l:(list A1)), (length_list (Cons a l)) = (1 + (length_list l)))).
Admitted.
Print length_cons.

(*Why axiom*) Lemma length_pos :
  forall (A1:Set), (forall (l:(list A1)), 0 <= (length_list l)).
Admitted.
Print length_pos.

(*Why axiom*) Lemma head_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (head (Cons a l)) = a)).
Admitted.
Print head_def.

(*Why axiom*) Lemma tail_def :
  forall (A1:Set),
  (forall (a:A1), (forall (l:(list A1)), (tail (Cons a l)) = l)).
Admitted.
Print tail_def.

(*Why axiom*) Lemma Append_nil :
  forall (A1:Set), (forall (l:(list A1)), (Append (@Nil A1) l) = l).
Admitted.
Print Append_nil.

(*Why axiom*) Lemma Append_Cons :
  forall (A1:Set),
  (forall (a:A1),
   (forall (l1:(list A1)),
    (forall (l2:(list A1)), (Append (Cons a l1) l2) = (Cons a (Append l1 l2))))).
Admitted.
Print Append_Cons.

(*Why type*) Definition map: Set -> Set ->Set.
Admitted.

(*Why logic*) Definition upd_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2) -> A1 -> A2 -> (map A1 A2).
Admitted.
Implicit Arguments upd_map.

(*Why logic*) Definition get_map :
  forall (A1:Set), forall (A2:Set), (map A2 A1) -> A2 -> A1.
Admitted.
Implicit Arguments get_map.

(*Why logic*) Definition in_dom_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A1 A2) -> bool.
Admitted.
Implicit Arguments in_dom_map.

(*Why logic*) Definition in_rng_map :
  forall (A1:Set), forall (A2:Set), A1 -> (map A2 A1) -> bool.
Admitted.
Implicit Arguments in_rng_map.

(*Why logic*) Definition empty_map :
  forall (A1:Set), forall (A2:Set), (map A1 A2).
Admitted.
Set Contextual Implicit.
Implicit Arguments empty_map.
Unset Contextual Implicit.

(*Why axiom*) Lemma get_upd_map_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (get_map (upd_map m a b) a) = b))).
Admitted.
Print get_upd_map_same.

(*Why axiom*) Lemma get_upd_map_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (get_map (upd_map m a b) a') = (get_map m a')))))).
Admitted.
Print get_upd_map_diff.

(*Why axiom*) Lemma upd_map_comm :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (forall (b':A2),
       (~(a = a') ->
        (upd_map (upd_map m a b) a' b') = (upd_map (upd_map m a' b') a b))))))).
Admitted.
Print upd_map_comm.

(*Why axiom*) Lemma upd_map_dom_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_dom_map a (upd_map m a b)) = true))).
Admitted.
Print upd_map_dom_same.

(*Why axiom*) Lemma upd_map_dom_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (~(a = a') -> (in_dom_map a' (upd_map m a b)) = (in_dom_map a' m)))))).
Admitted.
Print upd_map_dom_diff.

(*Why axiom*) Lemma upd_map_dom_mon :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (x:A1),
    (forall (x':A1),
     (forall (y:A2),
      ((in_dom_map x m) = true -> (in_dom_map x (upd_map m x' y)) = true))))).
Admitted.
Print upd_map_dom_mon.

(*Why axiom*) Lemma in_dom_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      ((in_dom_map a' (upd_map m a b)) = true <-> a = a' \/
       (in_dom_map a' m) = true))))).
Admitted.
Print in_dom_upd_map.

(*Why axiom*) Lemma in_dom_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (a':A1),
     (forall (b:A2),
      (in_dom_map a' (upd_map m a b)) =
      (bool_or (poly_eq a a') (in_dom_map a' m)))))).
Admitted.
Print in_dom_upd_map_bool.

(*Why axiom*) Lemma upd_map_rng_same :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1), (forall (b:A2), (in_rng_map b (upd_map m a b)) = true))).
Admitted.
Print upd_map_rng_same.

(*Why axiom*) Lemma upd_map_rng_diff :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (~(b = b') -> (in_rng_map b' (upd_map m a b)) = (in_rng_map b' m)))))).
Admitted.
Print upd_map_rng_diff.

(*Why axiom*) Lemma in_rng_upd_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      ((in_rng_map b' (upd_map m a b)) = true <-> b = b' \/
       (in_rng_map b' m) = true))))).
Admitted.
Print in_rng_upd_map.

(*Why axiom*) Lemma in_rng_upd_map_bool :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    (forall (b:A2),
     (forall (b':A2),
      (in_rng_map b' (upd_map m a b)) =
      (bool_or (poly_eq b b') (in_rng_map b' m)))))).
Admitted.
Print in_rng_upd_map_bool.

(*Why axiom*) Lemma in_dom_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (a:A1),
    ((in_dom_map a m) = true -> (in_rng_map (get_map m a) m) = true))).
Admitted.
Print in_dom_in_rng_map.

(*Why axiom*) Lemma inr_rng_in_dom :
  forall (A1:Set), forall (A2:Set),
  (forall (m:(map A1 A2)),
   (forall (b:A2),
    ((in_rng_map b m) = true ->
     (exists a:A1, (in_dom_map a m) = true /\ (get_map m a) = b)))).
Admitted.
Print inr_rng_in_dom.

(*Why axiom*) Lemma empty_in_dom_map :
  forall (A1:Set), forall (A2:Set),
  (forall (a:A1), (in_dom_map a (@empty_map A1 A2)) = false).
Admitted.
Print empty_in_dom_map.

(*Why axiom*) Lemma empty_in_rng_map :
  forall (A1:Set), forall (A2:Set),
  (forall (b:A1), (in_rng_map b (@empty_map A2 A1)) = false).
Admitted.
Print empty_in_rng_map.

(*Why type*) Definition bitstring: Set.
Admitted.

(*Why logic*) Definition length_bitstring : bitstring -> Z.
Admitted.

(*Why axiom*) Lemma triangle_equality :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     (Rle (Rabs (Rminus x z)) (Rplus (Rabs (Rminus x y)) (Rabs (Rminus y z))))))).
Admitted.
Print triangle_equality.

(*Why axiom*) Lemma div_real_simpl : (forall (x:R), (eq (Rdiv x x) (1)%R)).
Admitted.
Print div_real_simpl.

(*Why logic*) Definition real_of_bool : bool -> R.
Admitted.

(*Why axiom*) Lemma real_of_bool_true : (eq (real_of_bool true) (1)%R).
Admitted.
Print real_of_bool_true.

(*Why axiom*) Lemma real_of_bool_false : (eq (real_of_bool false) (0)%R).
Admitted.
Print real_of_bool_false.

(*Why axiom*) Lemma rplus_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle y z) -> (Rle (Rplus x y) (Rplus x z)))))).
Admitted.
Print rplus_le_compat_l.

(*Why axiom*) Lemma rplus_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), ((Rle x y) -> (Rle (Rplus x z) (Rplus y z)))))).
Admitted.
Print rplus_le_compat_r.

(*Why axiom*) Lemma rmult_le_compat_l :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R x) -> ((Rle y z) -> (Rle (Rmult x y) (Rmult x z))))))).
Admitted.
Print rmult_le_compat_l.

(*Why axiom*) Lemma rmult_le_compat_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R),
     ((Rle (0)%R z) -> ((Rle x y) -> (Rle (Rmult x z) (Rmult y z))))))).
Admitted.
Print rmult_le_compat_r.

(*Why axiom*) Lemma rmul_plus_distr_r :
  (forall (x:R),
   (forall (y:R),
    (forall (z:R), (eq (Rmult (Rplus x y) z) (Rplus (Rmult x z) (Rmult y z)))))).
Admitted.
Print rmul_plus_distr_r.

(*Why axiom*) Lemma rdiv_le_compat :
  (forall (x1:R),
   (forall (x2:R),
    (forall (y1:R),
     (forall (y2:R),
      ((Rlt (0)%R y2) ->
       ((Rle y2 y1) -> ((Rle x1 x2) -> (Rle (Rdiv x1 y1) (Rdiv x2 y2))))))))).
Admitted.
Print rdiv_le_compat.

(*Why axiom*) Lemma rdiv_0_le :
  (forall (x:R),
   (forall (y:R),
    ((Rlt (0)%R y) -> ((Rle (0)%R x) -> (Rle (0)%R (Rdiv x y)))))).
Admitted.
Print rdiv_0_le.

(*Why axiom*) Lemma real_of_int_le_compat :
  (forall (x:Z), (forall (y:Z), (x <= y -> (Rle (IZR x) (IZR y))))).
Admitted.
Print real_of_int_le_compat.

(*Why axiom*) Lemma real_of_int_0 : (eq (IZR 0) (0)%R).
Admitted.
Print real_of_int_0.

(*Why axiom*) Lemma real_of_int_1 : (eq (IZR 1) (1)%R).
Admitted.
Print real_of_int_1.

(*Why axiom*) Lemma real_of_int_2 : (eq (IZR 2) (2)%R).
Admitted.
Print real_of_int_2.

(*Why axiom*) Lemma real_of_int_10 : (eq (IZR 0) (000000 / 100000)%R).
Admitted.
Print real_of_int_10.

(*Why axiom*) Lemma real_of_int_11 : (eq (IZR 1) (100000 / 100000)%R).
Admitted.
Print real_of_int_11.

(*Why axiom*) Lemma real_of_int_12 : (eq (IZR 2) (200000 / 100000)%R).
Admitted.
Print real_of_int_12.

(*Why type*) Definition session: Set.
Admitted.

(*Why type*) Definition secret_key: Set.
Admitted.

(*Why type*) Definition public_key: Set.
Admitted.

(*Why type*) Definition message: Set.
Admitted.

(*Why type*) Definition session_string: Set.
Admitted.

(*Why type*) Definition session_key: Set.
Admitted.

(*Why type*) Definition session_id: Set.
Admitted.

(*Why type*) Definition eph_key: Set.
Admitted.

(*Why type*) Definition session_descr: Set.
Admitted.

(*Why logic*) Definition gen_secret_key : Z -> secret_key.
Admitted.

(*Why logic*) Definition gpk : secret_key -> public_key.
Admitted.

(*Why logic*) Definition gen_session_key : Z -> session_key.
Admitted.

(*Why logic*) Definition mk_sid :
  public_key -> public_key -> message -> message -> session_id.
Admitted.

(*Why logic*) Definition fstpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition sndpart : session_id -> public_key.
Admitted.

(*Why logic*) Definition fstmsg : session_id -> message.
Admitted.

(*Why logic*) Definition sndmsg : session_id -> message.
Admitted.

(*Why logic*) Definition isSome_id : (option session_id) -> bool.
Admitted.

(*Why logic*) Definition isSome_string : (option session_string) -> bool.
Admitted.

(*Why logic*) Definition gen_eph_key : Z -> eph_key.
Admitted.

(*Why logic*) Definition inp : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition out_noclash : secret_key -> eph_key -> message.
Admitted.

(*Why logic*) Definition gen_session_string :
  secret_key -> eph_key -> public_key -> message -> session_string.
Admitted.

(*Why logic*) Definition gen_session_string_sid :
  session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> session_string.
Admitted.

(*Why logic*) Definition mk_session_descr :
  public_key -> message -> bool -> bool -> bool -> session_descr.
Admitted.

(*Why logic*) Definition session_part : session_descr -> public_key.
Admitted.

(*Why logic*) Definition session_msg : session_descr -> message.
Admitted.

(*Why logic*) Definition session_eph_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_key_reveal_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition session_test_flag : session_descr -> bool.
Admitted.

(*Why logic*) Definition same_session_string_abs :
  session_id -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition eqS_abs :
  session_string -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> bool.
Admitted.

(*Why logic*) Definition findelse_sid_abs :
  (map session_id session_key) -> session_id -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_g_abs :
  (map session_id session_key) -> session_string
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_id).
Admitted.

(*Why logic*) Definition findelse_h_abs :
  (map session_string session_key) -> session_id
  -> (map public_key secret_key)
  -> (map (prod message public_key) eph_key) -> (option session_string).
Admitted.

(*Why logic*) Definition dummy : secret_key.
Admitted.

(*Why logic*) Definition dummy_session_key : session_key.
Admitted.

(*Why logic*) Definition dummy_session_string : session_string.
Admitted.

(*Why logic*) Definition dummy_session_id : session_id.
Admitted.

(*Why logic*) Definition dummy_part : public_key.
Admitted.

(*Why logic*) Definition dummy_msg : message.
Admitted.

(*Why logic*) Definition dummy_string : session_string.
Admitted.

(*Why logic*) Definition dummy_sid : session_id.
Admitted.

(*Why predicate*) Definition invariant1  (LH1_387:(map session_string session_key)) (LH2_388:(map session_string session_key))
  := (forall (str_390:session_string),
      ((in_dom_map str_390 LH2_388) = true ->
       (in_dom_map str_390 LH1_387) = true /\
       (get_map LH1_387 str_390) = (get_map LH2_388 str_390))).

(*Why predicate*) Definition invariant2  (G2_391:(map session_id session_key)) (LH1_392:(map session_string session_key)) (skey2_393:(map public_key secret_key)) (seed2_394:(map (prod message public_key) eph_key))
  := (forall (str_398:session_string),
      (forall (opsid_397:(option session_id)),
       ((findelse_g_abs G2_391 str_398 skey2_393 seed2_394) = opsid_397 ->
        (~opsid_397 = (@None session_id) ->
         (in_dom_map str_398 LH1_392) = true /\
         (get_map LH1_392 str_398) = (get_map G2_391 (proj opsid_397)))))).

(*Why predicate*) Definition invariant3  (G2_399:(map session_id session_key)) (LH1_400:(map session_string session_key)) (LH2_401:(map session_string session_key)) (skey2_402:(map public_key secret_key)) (seed2_403:(map (prod message public_key) eph_key))
  := (forall (str_405:session_string),
      ((in_dom_map str_405 LH1_400) = true <->
       (in_dom_map str_405 LH2_401) = true \/
       ~(findelse_g_abs G2_399 str_405 skey2_402 seed2_403) =
        (@None session_id))).

(*Why axiom*) Lemma session_string_eq :
  (forall (str1_5:session_string),
   (forall (str2_4:session_string), str1_5 = str2_4 \/ ~str1_5 = str2_4)).
Admitted.
Print session_string_eq.

(*Why axiom*) Lemma isSome_id_def :
  (forall (x_7:(option session_id)),
   ((isSome_id x_7) = true <-> ~x_7 = (@None session_id))).
Admitted.
Print isSome_id_def.

(*Why axiom*) Lemma isSome_none : (isSome_id (@None session_id)) = false.
Admitted.
Print isSome_none.

(*Why axiom*) Lemma isSome_some :
  (forall (x_11:(option session_id)),
   ((isSome_id x_11) = true -> (exists y_10:session_id, x_11 = (Some y_10)))).
Admitted.
Print isSome_some.

(*Why axiom*) Lemma isSome_string_def :
  (forall (x_13:(option session_string)),
   ((isSome_string x_13) = true <-> ~x_13 = (@None session_string))).
Admitted.
Print isSome_string_def.

(*Why axiom*) Lemma isSome_string_some :
  (forall (x_17:(option session_string)),
   ((isSome_string x_17) = true ->
    (exists y_16:session_string, x_17 = (Some y_16)))).
Admitted.
Print isSome_string_some.

(*Why axiom*) Lemma isSome_string_none :
  (isSome_string (@None session_string)) = false.
Admitted.
Print isSome_string_none.

(*Why axiom*) Lemma session_id_proj :
  (forall (s_19:session_id),
   (mk_sid (fstpart s_19) (sndpart s_19) (fstmsg s_19) (sndmsg s_19)) = s_19).
Admitted.
Print session_id_proj.

(*Why axiom*) Lemma session_id_proj_fstpart :
  (forall (A_27:public_key),
   (forall (B_26:public_key),
    (forall (X_25:message),
     (forall (Y_24:message), (fstpart (mk_sid A_27 B_26 X_25 Y_24)) = A_27)))).
Admitted.
Print session_id_proj_fstpart.

(*Why axiom*) Lemma session_id_proj_sndpart :
  (forall (A_35:public_key),
   (forall (B_34:public_key),
    (forall (X_33:message),
     (forall (Y_32:message), (sndpart (mk_sid A_35 B_34 X_33 Y_32)) = B_34)))).
Admitted.
Print session_id_proj_sndpart.

(*Why axiom*) Lemma session_id_proj_fstmsg :
  (forall (A_43:public_key),
   (forall (B_42:public_key),
    (forall (X_41:message),
     (forall (Y_40:message), (fstmsg (mk_sid A_43 B_42 X_41 Y_40)) = X_41)))).
Admitted.
Print session_id_proj_fstmsg.

(*Why axiom*) Lemma session_id_proj_sndmsg :
  (forall (A_51:public_key),
   (forall (B_50:public_key),
    (forall (X_49:message),
     (forall (Y_48:message), (sndmsg (mk_sid A_51 B_50 X_49 Y_48)) = Y_48)))).
Admitted.
Print session_id_proj_sndmsg.

(*Why axiom*) Lemma session_id_eq :
  (forall (s_55:session_id),
   (forall (s'_54:session_id),
    (poly_eq s_55 s'_54) =
    (bool_and
     (bool_and
      (bool_and
       (poly_eq (fstpart s_55) (fstpart s'_54)) (poly_eq
                                                 (sndpart s_55) (sndpart
                                                                 s'_54))) (
      poly_eq (fstmsg s_55) (fstmsg s'_54))) (poly_eq
                                              (sndmsg s_55) (sndmsg s'_54))))).
Admitted.
Print session_id_eq.

(*Why axiom*) Lemma gen_session_string_sid_abs :
  (forall (sid_61:session_id),
   (forall (skey_60:(map public_key secret_key)),
    (forall (seed_59:(map (prod message public_key) eph_key)),
     (gen_session_string_sid sid_61 skey_60 seed_59) =
     (gen_session_string
      (get_map skey_60 (fstpart sid_61)) (get_map
                                          seed_59 (pair
                                                   (fstmsg sid_61) (fstpart
                                                                    sid_61))) (
      sndpart sid_61) (sndmsg sid_61))))).
Admitted.
Print gen_session_string_sid_abs.

(*Why axiom*) Lemma session_descr_proj :
  (forall (s_63:session_descr),
   (mk_session_descr
    (session_part s_63) (session_msg s_63) (session_eph_flag s_63) (session_key_reveal_flag
                                                                    s_63) (
    session_test_flag s_63)) =
   s_63).
Admitted.
Print session_descr_proj.

(*Why axiom*) Lemma session_descr_part :
  (forall (A_73:public_key),
   (forall (X_72:message),
    (forall (ef_71:bool),
     (forall (krf_70:bool),
      (forall (tf_69:bool),
       (session_part (mk_session_descr A_73 X_72 ef_71 krf_70 tf_69)) = A_73))))).
Admitted.
Print session_descr_part.

(*Why axiom*) Lemma session_descr_msg :
  (forall (A_83:public_key),
   (forall (X_82:message),
    (forall (ef_81:bool),
     (forall (krf_80:bool),
      (forall (tf_79:bool),
       (session_msg (mk_session_descr A_83 X_82 ef_81 krf_80 tf_79)) = X_82))))).
Admitted.
Print session_descr_msg.

(*Why axiom*) Lemma session_descr_eph :
  (forall (A_93:public_key),
   (forall (X_92:message),
    (forall (ef_91:bool),
     (forall (krf_90:bool),
      (forall (tf_89:bool),
       (session_eph_flag (mk_session_descr A_93 X_92 ef_91 krf_90 tf_89)) =
       ef_91))))).
Admitted.
Print session_descr_eph.

(*Why axiom*) Lemma session_descr_key_reveal_flag :
  (forall (A_103:public_key),
   (forall (X_102:message),
    (forall (ef_101:bool),
     (forall (krf_100:bool),
      (forall (tf_99:bool),
       (session_key_reveal_flag
        (mk_session_descr A_103 X_102 ef_101 krf_100 tf_99)) =
       krf_100))))).
Admitted.
Print session_descr_key_reveal_flag.

(*Why axiom*) Lemma session_descr_test_flag :
  (forall (A_113:public_key),
   (forall (X_112:message),
    (forall (ef_111:bool),
     (forall (krf_110:bool),
      (forall (tf_109:bool),
       (session_test_flag
        (mk_session_descr A_113 X_112 ef_111 krf_110 tf_109)) =
       tf_109))))).
Admitted.
Print session_descr_test_flag.

(*Why axiom*) Lemma session_descr_eq :
  (forall (s_117:session_descr),
   (forall (s'_116:session_descr),
    (poly_eq s_117 s'_116) =
    (bool_and
     (bool_and
      (bool_and
       (bool_and
        (poly_eq (session_part s_117) (session_part s'_116)) (poly_eq
                                                              (session_msg
                                                               s_117) (
                                                              session_msg
                                                              s'_116))) (
       poly_eq (session_eph_flag s_117) (session_eph_flag s'_116))) (
      poly_eq
      (session_key_reveal_flag s_117) (session_key_reveal_flag s'_116))) (
     poly_eq (session_test_flag s_117) (session_test_flag s'_116))))).
Admitted.
Print session_descr_eq.

(*Why axiom*) Lemma same_string_def :
  (forall (sid_125:session_id),
   (forall (sid'_124:session_id),
    (forall (skey_123:(map public_key secret_key)),
     (forall (seed_122:(map (prod message public_key) eph_key)),
      ((same_session_string_abs sid_125 sid'_124 skey_123 seed_122) = true <->
       (gen_session_string_sid sid_125 skey_123 seed_122) =
       (gen_session_string_sid sid'_124 skey_123 seed_122)))))).
Admitted.
Print same_string_def.

(*Why axiom*) Lemma eqS_def1 :
  (forall (str_133:session_string),
   (forall (sid_132:session_id),
    (forall (skey_131:(map public_key secret_key)),
     (forall (seed_130:(map (prod message public_key) eph_key)),
      ((eqS_abs str_133 sid_132 skey_131 seed_130) = true ->
       (gen_session_string_sid sid_132 skey_131 seed_130) = str_133))))).
Admitted.
Print eqS_def1.

(*Why axiom*) Lemma eqS_def2 :
  (forall (str_141:session_string),
   (forall (sid_140:session_id),
    (forall (skey_139:(map public_key secret_key)),
     (forall (seed_138:(map (prod message public_key) eph_key)),
      ((gen_session_string_sid sid_140 skey_139 seed_138) = str_141 ->
       (eqS_abs str_141 sid_140 skey_139 seed_138) = true))))).
Admitted.
Print eqS_def2.

(*Why axiom*) Lemma findelse_sid_abs_none :
  (forall (m'_151:(map session_id session_key)),
   (forall (s'_150:session_id),
    (forall (skey'_149:(map public_key secret_key)),
     (forall (seed'_148:(map (prod message public_key) eph_key)),
      ((findelse_sid_abs m'_151 s'_150 skey'_149 seed'_148) =
       (@None session_id) <->
       (forall (x_147:session_id),
        ((in_dom_map x_147 m'_151) = true ->
         ~(same_session_string_abs x_147 s'_150 skey'_149 seed'_148) = true))))))).
Admitted.
Print findelse_sid_abs_none.

(*Why axiom*) Lemma findelse_sid_abs_some :
  (forall (m'_161:(map session_id session_key)),
   (forall (s'_160:session_id),
    (forall (skey'_159:(map public_key secret_key)),
     (forall (seed'_158:(map (prod message public_key) eph_key)),
      (forall (opres_157:(option session_id)),
       ((findelse_sid_abs m'_161 s'_160 skey'_159 seed'_158) = opres_157 ->
        (~opres_157 = (@None session_id) ->
         (same_session_string_abs (proj opres_157) s'_160 skey'_159 seed'_158) =
         true /\ (in_dom_map (proj opres_157) m'_161) = true))))))).
Admitted.
Print findelse_sid_abs_some.


(*Why axiom*) Lemma findelse_g_abs_none_2 :
  (forall (m'_171:(map session_id session_key)),
   (forall (str_170:session_string),
    (forall (skey'_169:(map public_key secret_key)),
     (forall (seed'_168:(map (prod message public_key) eph_key)),
      ((findelse_g_abs m'_171 str_170 skey'_169 seed'_168) =
       (@None session_id) <->
       (forall (sid_167:session_id),
        ((in_dom_map sid_167 m'_171) = true ->
         ~(eqS_abs str_170 sid_167 skey'_169 seed'_168) = true))))))).
Admitted.
Print findelse_g_abs_none_2.

(*Why axiom*) Lemma findelse_g_abs_some :
  (forall (m'_181:(map session_id session_key)),
   (forall (str_180:session_string),
    (forall (skey'_179:(map public_key secret_key)),
     (forall (seed'_178:(map (prod message public_key) eph_key)),
      (forall (res_177:(option session_id)),
       ((findelse_g_abs m'_181 str_180 skey'_179 seed'_178) = res_177 <->
        (~res_177 = (@None session_id) ->
         (eqS_abs str_180 (proj res_177) skey'_179 seed'_178) = true /\
         (in_dom_map (proj res_177) m'_181) = true))))))).
Admitted.
Print findelse_g_abs_some.

(*Why axiom*) Lemma findelse_g_update_1 :
  (forall (m_193:(map session_id session_key)),
   (forall (str_192:session_string),
    (forall (skey_191:(map public_key secret_key)),
     (forall (seed_190:(map (prod message public_key) eph_key)),
      (forall (sid_189:session_id),
       (forall (sesskey_188:session_key),
        ((gen_session_string_sid sid_189 skey_191 seed_190) = str_192 ->
         ~(findelse_g_abs
           (upd_map m_193 sid_189 sesskey_188) str_192 skey_191 seed_190) =
          (@None session_id)))))))).
Admitted.
Print findelse_g_update_1.

(*Why axiom*) Lemma findelse_sid_g :
  (forall (m_203:(map session_id session_key)),
   (forall (sid_202:session_id),
    (forall (str_201:session_string),
     (forall (skey_200:(map public_key secret_key)),
      (forall (seed_199:(map (prod message public_key) eph_key)),
       ((gen_session_string_sid sid_202 skey_200 seed_199) = str_201 ->
        (findelse_sid_abs m_203 sid_202 skey_200 seed_199) =
        (findelse_g_abs m_203 str_201 skey_200 seed_199))))))).
Admitted.
Print findelse_sid_g.

(*Why axiom*) Lemma findelse_h_abs_none :
  (forall (m'_213:(map session_string session_key)),
   (forall (sid_212:session_id),
    (forall (skey'_211:(map public_key secret_key)),
     (forall (seed'_210:(map (prod message public_key) eph_key)),
      ((findelse_h_abs m'_213 sid_212 skey'_211 seed'_210) =
       (@None session_string) ->
       (forall (str_209:session_string),
        ((in_dom_map str_209 m'_213) = true ->
         ~(eqS_abs str_209 sid_212 skey'_211 seed'_210) = true))))))).
Admitted.
Print findelse_h_abs_none.

(*Why axiom*) Lemma findelse_h_abs_some :
  (forall (m'_223:(map session_string session_key)),
   (forall (sid_222:session_id),
    (forall (skey'_221:(map public_key secret_key)),
     (forall (seed'_220:(map (prod message public_key) eph_key)),
      (forall (str_219:(option session_string)),
       ((findelse_h_abs m'_223 sid_222 skey'_221 seed'_220) = str_219 ->
        (~str_219 = (@None session_string) ->
         (eqS_abs (proj str_219) sid_222 skey'_221 seed'_220) = true /\
         (in_dom_map (proj str_219) m'_223) = true))))))).
Admitted.
Print findelse_h_abs_some.

(*Why axiom*) Lemma findelse_h_eqS :
  (forall (m_233:(map session_string session_key)),
   (forall (sid_232:session_id),
    (forall (skey_231:(map public_key secret_key)),
     (forall (seed_230:(map (prod message public_key) eph_key)),
      (forall (str_229:(option session_string)),
       ((findelse_h_abs m_233 sid_232 skey_231 seed_230) = str_229 ->
        (~str_229 = (@None session_string) ->
         (gen_session_string_sid sid_232 skey_231 seed_230) = (proj str_229) /\
         (in_dom_map (proj str_229) m_233) = true))))))).
Admitted.
Print findelse_h_eqS.

(* Why obligation from file "easycrypt597430.why", line 640, characters 0-4223: *)
(*Why goal*) Lemma implies_goal54 : 
  (forall (skey_310_1501:(map public_key secret_key)),
   (forall (skey_239_1500:(map public_key secret_key)),
    (forall (seed_312_1499:(map (prod message public_key) eph_key)),
     (forall (seed_241_1498:(map (prod message public_key) eph_key)),
      (forall (s_358_1497:session_id),
       (forall (s_281_1496:session_id),
        (forall (complete_sessions_306_1495:(map (prod public_key message) session_descr)),
         (forall (complete_sessions_235_1494:(map (prod public_key message) session_descr)),
          (forall (LH_311_1493:(map session_string session_key)),
           (forall (LH_240_1492:(map session_string session_key)),
            (forall (G_314_1491:(map session_id session_key)),
             ((invariant1 LH_240_1492 LH_311_1493) ->
              ((invariant2 G_314_1491 LH_240_1492 skey_310_1501 seed_312_1499) ->
               ((invariant3
                 G_314_1491 LH_240_1492 LH_311_1493 skey_310_1501 seed_312_1499) ->
                (skey_239_1500 = skey_310_1501 ->
                 (seed_241_1498 = seed_312_1499 ->
                  (complete_sessions_235_1494 = complete_sessions_306_1495 ->
                   (s_281_1496 = s_358_1497 ->
                    (forall (h_3_753:session_key),
                     let A_359_752 := (fstpart s_358_1497) in
                     let B_360_751 := (sndpart s_358_1497) in
                     let X_361_750 := (fstmsg s_358_1497) in
                     let Y_362_749 := (sndmsg s_358_1497) in
                     ((in_dom_map
                       (pair A_359_752 X_361_750) complete_sessions_306_1495) =
                      true ->
                      let B'_364_748 :=
                        (session_part
                         (get_map
                          complete_sessions_306_1495 (pair
                                                      A_359_752 X_361_750))) in
                      let Y'_365_747 :=
                        (session_msg
                         (get_map
                          complete_sessions_306_1495 (pair
                                                      A_359_752 X_361_750))) in
                      let sidA_378_746 :=
                        (mk_sid A_359_752 B'_364_748 X_361_750 Y'_365_747) in
                      (B_360_751 = B'_364_748 ->
                       (Y_362_749 = Y'_365_747 ->
                        (~(in_dom_map
                           (pair B_360_751 Y_362_749) complete_sessions_306_1495) =
                          true ->
                         (~(session_test_flag
                            (get_map
                             complete_sessions_306_1495 (pair
                                                         A_359_752 X_361_750))) =
                           true ->
                          (~(isSome_id
                             (findelse_sid_abs
                              G_314_1491 sidA_378_746 skey_310_1501 seed_312_1499)) =
                            true ->
                           (~(isSome_string
                              (findelse_h_abs
                               LH_311_1493 sidA_378_746 skey_310_1501 seed_312_1499)) =
                             true ->
                            let A_282_705 := (fstpart s_281_1496) in
                            let B_283_704 := (sndpart s_281_1496) in
                            let X_284_703 := (fstmsg s_281_1496) in
                            let Y_285_702 := (sndmsg s_281_1496) in
                            ((in_dom_map
                              (pair A_282_705 X_284_703) complete_sessions_235_1494) =
                             true ->
                             let B'_287_701 :=
                               (session_part
                                (get_map
                                 complete_sessions_235_1494 (pair
                                                             A_282_705 X_284_703))) in
                             let Y'_288_700 :=
                               (session_msg
                                (get_map
                                 complete_sessions_235_1494 (pair
                                                             A_282_705 X_284_703))) in
                             (B_283_704 = B'_287_701 ->
                              (Y_285_702 = Y'_288_700 ->
                               (~(in_dom_map
                                  (pair B_283_704 Y_285_702) complete_sessions_235_1494) =
                                 true ->
                                (~(session_test_flag
                                   (get_map
                                    complete_sessions_235_1494 (pair
                                                                A_282_705 X_284_703))) =
                                  true ->
                                 let sstr_295_687 :=
                                   (gen_session_string_sid
                                    (mk_sid
                                     A_282_705 B'_287_701 X_284_703 Y'_288_700) skey_239_1500 seed_241_1498) in
                                 (~(in_dom_map sstr_295_687 LH_240_1492) =
                                   true ->
                                  (invariant3
                                   (upd_map G_314_1491 sidA_378_746 h_3_753) (
                                   upd_map LH_240_1492 sstr_295_687 h_3_753) LH_311_1493 skey_310_1501 seed_312_1499))))))))))))))))))))))))))))))))).
Proof.
intros.
unfold invariant3.
intros str.
destruct (session_string_eq str sstr_295_687).
split;intro.
right.
apply findelse_g_update_1.
rewrite H19;unfold sstr_295_687.
replace sidA_378_746 
  with (mk_sid A_282_705 B'_287_701 X_284_703 Y'_288_700).
rewrite H2, H3;reflexivity.
unfold sidA_378_746.
rewrite <- H14, <-H15. 
unfold A_282_705, B_283_704, X_284_703, Y_285_702.
rewrite <- H8, <-H7. 
unfold A_359_752, B_360_751, X_361_750, Y_362_749.
rewrite H5;reflexivity.
rewrite H19.
apply upd_map_dom_same.

split;intro H20.
destruct ((proj1 (in_dom_upd_map _ _ _ _ _ _)) H20).
elim H19; rewrite H21;reflexivity.
destruct ((proj1 (H1 _)) H21);[left | right];auto.
intro H23.
apply H22.
apply (proj2 (findelse_g_abs_none_2  _ _ _ _)).
generalize ((proj1 (findelse_g_abs_none_2 _ _ _ _ )) H23). 
intro H24.
intros.
apply H24.
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ )).
right;auto.

elim H20;intro H21.

generalize ((proj2 (H1 _)) (or_introl _ H21));intro H22. 
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));right;auto.




elim (Some_or_None _ ( findelse_g_abs (upd_map G_314_1491 sidA_378_746 h_3_753) str
          skey_310_1501 seed_312_1499)); intro H22;elim H22;auto.
destruct H22; intros.

destruct ((proj1(findelse_g_abs_some _ _ _ _ _) H23)).
intro H24;symmetry in H24.
apply (None_neq_Some _ _ H24);auto.


destruct ((proj1 (in_dom_upd_map _ _ _ _ _ _  )) H25 ).
rewrite <- H26 in H24.
generalize (eqS_def1 _ _ _ _ H24);intro H27.
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));left.
rewrite <- H27; unfold sstr_295_687.

replace sidA_378_746 
  with (mk_sid A_282_705 B'_287_701 X_284_703 Y'_288_700).
rewrite H2, H3;reflexivity.
unfold sidA_378_746.
rewrite <- H14, <-H15. 
unfold A_282_705, B_283_704, X_284_703, Y_285_702.
rewrite <- H8, <-H7. 
unfold A_359_752, B_360_751, X_361_750, Y_362_749.
rewrite H5;reflexivity.
assert (
findelse_g_abs G_314_1491  str
          skey_310_1501 seed_312_1499 = Some x0).

apply (proj2 (findelse_g_abs_some _ _ _ _ _)).
intros _;split;auto.

assert ( findelse_g_abs G_314_1491 str skey_310_1501 seed_312_1499 <> None).
intro H100.
rewrite H100 in H27.
apply (None_neq_Some _ _ H27).
generalize ((proj2 (H1 _)) (or_intror _ H28));intro H29. 
apply (proj2 (in_dom_upd_map _ _ _ _ _ _ ));right;auto.
Save.
