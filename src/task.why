theory Task
  (*type int
  
  type real
  
  predicate (=) 'a 'a
  
  (* use BuiltIn *) *)
  
  type bool =
    | True
    | False
  
  (* use Bool *)
  
  type func 'a 'b
  
  type pred 'a
  
  function (@!) (func 'a 'b) 'a : 'b
  
  predicate (@?) (pred 'a) 'a
  
  (* use HighOrd *)
  
  type distr 'ta
  
  function mu (distr 'ta) (func 'ta bool) : real
  
  (* use Distr *)
  
  constant Not : func bool bool
  
  axiom Not_spec : forall b:bool. (Not @! b) = True <-> not b = True
  
  constant AND : func bool (func bool bool)
  
  axiom AND_spec :
    forall b:bool, b1:bool.
     ((AND @! b) @! b1) = True <-> b = True /\ b1 = True
  
  constant ANDA : func bool (func bool bool)
  
  axiom ANDA_spec :
    forall b:bool, b1:bool.
     ((ANDA @! b) @! b1) = True <-> b = True && b1 = True
  
  constant OR : func bool (func bool bool)
  
  axiom OR_spec :
    forall b:bool, b1:bool.
     ((OR @! b) @! b1) = True <-> b = True \/ b1 = True
  
  constant OR1 : func bool (func bool bool)
  
  axiom OR_spec1 :
    forall b:bool, b1:bool.
     ((OR1 @! b) @! b1) = True <-> b = True || b1 = True
  
  constant IMP : func bool (func bool bool)
  
  axiom IMP_spec :
    forall b:bool, b1:bool.
     ((IMP @! b) @! b1) = True <-> b = True -> b1 = True
  
  constant IFF : func bool (func bool bool)
  
  axiom IFF_spec :
    forall b:bool, b1:bool.
     ((IFF @! b) @! b1) = True <-> b = True <-> b1 = True
  
  constant EQ : func 'qta (func 'qta bool)
  
  axiom EQ_spec :
    forall x:'qta, x1:'qta.
     (((EQ:func 'qta (func 'qta bool)) @! x) @! x1) = True <-> x = x1
  
  type memory
  
  type name
  
  type module
  
  type var 't
  
  type fun 'ta
  
  type global
  
  function mod_var module name : var 't
  
  function mod_fun module name : fun 'ta
  
  function sub_mod module name : module
  
  function app_mod module module : module
  
  function get_var (var 't) memory : 't
  
  function sem (fun 'ta) memory 'ta : distr memory
  
  function getglob module memory : global
  
  type tuple0 =
    | Tuple0
  
  (* use Tuple01 *)
  
  constant (=_ho) : func 'a (func 'a bool)
  
  axiom infix_eq_ho_spec :
    forall x:'a, x1:'a.
     ((((=_ho):func 'a (func 'a bool)) @! x) @! x1) = True <-> x = x1
  
  constant mu_ho : func (distr 'ta) (func (func 'ta bool) real)
  
  axiom mu_ho_spec :
    forall x:distr 'ta, x1:func 'ta bool.
     (((mu_ho:func (distr 'ta) (func (func 'ta bool) real)) @! x) @! x1) =
      mu x x1
  
  constant zero : int = 0
  
  constant one : int = 1
  
  predicate (<) int int
  
  predicate (>) (x:int) (y:int) = y < x
  
  predicate (<=) (x:int) (y:int) = x < y \/ x = y
  
  function (+) int int : int
  
  function (-) int : int
  
  function (*) int int : int
  
  axiom Assoc : forall x:int, y:int, z:int. ((x + y) + z) = (x + (y + z))
  
  (* clone algebra.Assoc with type t = int, function op = (+),
    prop Assoc1 = Assoc *)
  
  axiom Unit_def_l : forall x:int. (zero + x) = x
  
  axiom Unit_def_r : forall x:int. (x + zero) = x
  
  (* clone algebra.Monoid with type t1 = int, constant unit = zero,
    function op1 = (+), prop Unit_def_r1 = Unit_def_r,
    prop Unit_def_l1 = Unit_def_l, prop Assoc2 = Assoc *)
  
  axiom Inv_def_l : forall x:int. ((- x) + x) = zero
  
  axiom Inv_def_r : forall x:int. (x + (- x)) = zero
  
  (* clone algebra.Group with type t2 = int, function inv = (-),
    constant unit1 = zero, function op2 = (+), prop Inv_def_r1 = Inv_def_r,
    prop Inv_def_l1 = Inv_def_l, prop Unit_def_r2 = Unit_def_r,
    prop Unit_def_l2 = Unit_def_l, prop Assoc3 = Assoc *)
  
  axiom Comm : forall x:int, y:int. (x + y) = (y + x)
  
  (* clone algebra.Comm with type t3 = int, function op3 = (+),
    prop Comm1 = Comm *)
  
  (* meta AC function (+) *)
  
  (* clone algebra.CommutativeGroup with type t4 = int, function inv1 = (-),
    constant unit2 = zero, function op4 = (+), prop Comm2 = Comm,
    prop Inv_def_r2 = Inv_def_r, prop Inv_def_l2 = Inv_def_l,
    prop Unit_def_r3 = Unit_def_r, prop Unit_def_l3 = Unit_def_l,
    prop Assoc4 = Assoc *)
  
  axiom Assoc5 : forall x:int, y:int, z:int. ((x * y) * z) = (x * (y * z))
  
  (* clone algebra.Assoc with type t = int, function op = (*),
    prop Assoc1 = Assoc5 *)
  
  axiom Mul_distr_l :
    forall x:int, y:int, z:int. (x * (y + z)) = ((x * y) + (x * z))
  
  axiom Mul_distr_r :
    forall x:int, y:int, z:int. ((y + z) * x) = ((y * x) + (z * x))
  
  function (-) (x:int) (y:int) : int = x + (- y)
  
  (* clone algebra.Ring with type t5 = int, function (-) = (-),
    function (*) = (*), function (-) = (-), function (+) = (+),
    constant zero1 = zero, prop Mul_distr_r1 = Mul_distr_r,
    prop Mul_distr_l1 = Mul_distr_l, prop Assoc6 = Assoc5, prop Comm3 = Comm,
    prop Inv_def_r3 = Inv_def_r, prop Inv_def_l3 = Inv_def_l,
    prop Unit_def_r4 = Unit_def_r, prop Unit_def_l4 = Unit_def_l,
    prop Assoc7 = Assoc *)
  
  axiom Comm4 : forall x:int, y:int. (x * y) = (y * x)
  
  (* clone algebra.Comm with type t3 = int, function op3 = (*),
    prop Comm1 = Comm4 *)
  
  (* meta AC function (*) *)
  
  (* clone algebra.CommutativeRing with type t6 = int, function (-) = (-),
    function (*) = (*), function (-) = (-), function (+) = (+),
    constant zero2 = zero, prop Comm5 = Comm4,
    prop Mul_distr_r2 = Mul_distr_r, prop Mul_distr_l2 = Mul_distr_l,
    prop Assoc8 = Assoc5, prop Comm6 = Comm, prop Inv_def_r4 = Inv_def_r,
    prop Inv_def_l4 = Inv_def_l, prop Unit_def_r5 = Unit_def_r,
    prop Unit_def_l5 = Unit_def_l, prop Assoc9 = Assoc *)
  
  axiom Unitary : forall x:int. (one * x) = x
  
  axiom NonTrivialRing : not zero = one
  
  (* clone algebra.UnitaryCommutativeRing with type t7 = int,
    constant one1 = one, function (-) = (-), function (*) = (*),
    function (-) = (-), function (+) = (+), constant zero3 = zero,
    prop NonTrivialRing1 = NonTrivialRing, prop Unitary1 = Unitary,
    prop Comm7 = Comm4, prop Mul_distr_r3 = Mul_distr_r,
    prop Mul_distr_l3 = Mul_distr_l, prop Assoc10 = Assoc5,
    prop Comm8 = Comm, prop Inv_def_r5 = Inv_def_r,
    prop Inv_def_l5 = Inv_def_l, prop Unit_def_r6 = Unit_def_r,
    prop Unit_def_l6 = Unit_def_l, prop Assoc11 = Assoc *)
  
  predicate (>=) (x:int) (y:int) = y <= x
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Refl : forall x:int. x <= x
  
  (* clone relations.Reflexive with type t9 = int, predicate rel1 = (<=),
    prop Refl1 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Trans : forall x:int, y:int, z:int. x <= y -> y <= z -> x <= z
  
  (* clone relations.Transitive with type t10 = int, predicate rel2 = (<=),
    prop Trans1 = Trans *)
  
  (* clone relations.PreOrder with type t11 = int, predicate rel3 = (<=),
    prop Trans2 = Trans, prop Refl2 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Antisymm : forall x:int, y:int. x <= y -> y <= x -> x = y
  
  (* clone relations.Antisymmetric with type t12 = int,
    predicate rel4 = (<=), prop Antisymm1 = Antisymm *)
  
  (* clone relations.PartialOrder with type t13 = int, predicate rel5 = (<=),
    prop Antisymm2 = Antisymm, prop Trans3 = Trans, prop Refl3 = Refl *)
  
  (* clone relations.EndoRelation with type t8 = int, predicate rel = (<=),
     *)
  
  axiom Total : forall x:int, y:int. x <= y \/ y <= x
  
  (* clone relations.Total with type t14 = int, predicate rel6 = (<=),
    prop Total1 = Total *)
  
  (* clone relations.TotalOrder with type t15 = int, predicate rel7 = (<=),
    prop Total2 = Total, prop Antisymm3 = Antisymm, prop Trans4 = Trans,
    prop Refl4 = Refl *)
  
  axiom ZeroLessOne : zero <= one
  
  axiom CompatOrderAdd :
    forall x:int, y:int, z:int. x <= y -> (x + z) <= (y + z)
  
  axiom CompatOrderMult :
    forall x:int, y:int, z:int. x <= y -> zero <= z -> (x * z) <= (y * z)
  
  (* clone algebra.OrderedUnitaryCommutativeRing with type t16 = int,
    predicate (>=) = (>=), predicate (<=) = (<=), constant one2 = one,
    function (-) = (-), function (*) = (*), function (-) = (-),
    function (+) = (+), constant zero4 = zero,
    prop CompatOrderMult1 = CompatOrderMult,
    prop CompatOrderAdd1 = CompatOrderAdd, prop ZeroLessOne1 = ZeroLessOne,
    prop Total3 = Total, prop Antisymm4 = Antisymm, prop Trans5 = Trans,
    prop Refl5 = Refl, prop NonTrivialRing2 = NonTrivialRing,
    prop Unitary2 = Unitary, prop Comm9 = Comm4,
    prop Mul_distr_r4 = Mul_distr_r, prop Mul_distr_l4 = Mul_distr_l,
    prop Assoc12 = Assoc5, prop Comm10 = Comm, prop Inv_def_r6 = Inv_def_r,
    prop Inv_def_l6 = Inv_def_l, prop Unit_def_r7 = Unit_def_r,
    prop Unit_def_l7 = Unit_def_l, prop Assoc13 = Assoc *)
  
  (* use int.Int *)
  
  constant (<_ho) : func int (func int bool)
  
  axiom infix_ls_ho_spec :
    forall x:int, x1:int. (((<_ho) @! x) @! x1) = True <-> x < x1
  
  constant (>_ho) : func int (func int bool)
  
  axiom infix_gt_ho_spec :
    forall x:int, x1:int. (((>_ho) @! x) @! x1) = True <-> x > x1
  
  constant (<=_ho) : func int (func int bool)
  
  axiom infix_lseq_ho_spec :
    forall x:int, x1:int. (((<=_ho) @! x) @! x1) = True <-> x <= x1
  
  constant (+_ho) : func int (func int int)
  
  axiom infix_pl_ho_spec :
    forall x:int, x1:int. (((+_ho) @! x) @! x1) = (x + x1)
  
  constant (-_ho) : func int int
  
  axiom prefix_mn_ho_spec : forall x:int. ((-_ho) @! x) = (- x)
  
  constant ( *_ho) : func int (func int int)
  
  axiom infix_as_ho_spec :
    forall x:int, x1:int. ((( *_ho) @! x) @! x1) = (x * x1)
  
  constant (-_ho) : func int (func int int)
  
  axiom infix_mn_ho_spec :
    forall x:int, x1:int. (((-_ho) @! x) @! x1) = (x - x1)
  
  constant (>=_ho) : func int (func int bool)
  
  axiom infix_gteq_ho_spec :
    forall x:int, x1:int. (((>=_ho) @! x) @! x1) = True <-> x >= x1
  
  function abs (x:int) : int = if x >= 0 then x else - x
  
  axiom Abs_le : forall x:int, y:int. abs x <= y <-> (- y) <= x /\ x <= y
  
  axiom Abs_pos : forall x:int. abs x >= 0
  
  (* use int.Abs *)
  
  constant abs_ho : func int int
  
  axiom abs_ho_spec : forall x:int. (abs_ho @! x) = abs x
  
  axiom lstopgt_Int_Triangle_triangle_inequality :
    forall x:int, y:int, z:int. abs (x - y) <= (abs (x - z) + abs (y - z))
  
  function lstopgt_Int_Extrema_min (a:int) (b:int) : int = if a < b then a
    else b
  
  constant lstopgt_Int_Extrema_min_ho : func int (func int int)
  
  axiom lstopgt_Int_Extrema_min_ho_spec :
    forall x:int, x1:int.
     ((lstopgt_Int_Extrema_min_ho @! x) @! x1) = lstopgt_Int_Extrema_min x x1
  
  axiom lstopgt_Int_Extrema_min_is_lb :
    forall a:int, b:int.
     lstopgt_Int_Extrema_min a b <= a /\ lstopgt_Int_Extrema_min a b <= b
  
  axiom lstopgt_Int_Extrema_min_is_glb :
    forall x:int, a:int, b:int.
     x <= a -> x <= b -> x <= lstopgt_Int_Extrema_min a b
  
  axiom lstopgt_Int_Extrema_min_is_extremum :
    forall a:int, b:int.
     lstopgt_Int_Extrema_min a b = a \/ lstopgt_Int_Extrema_min a b = b
  
  function lstopgt_Int_Extrema_max (a:int) (b:int) : int = if a < b then b
    else a
  
  constant lstopgt_Int_Extrema_max_ho : func int (func int int)
  
  axiom lstopgt_Int_Extrema_max_ho_spec :
    forall x:int, x1:int.
     ((lstopgt_Int_Extrema_max_ho @! x) @! x1) = lstopgt_Int_Extrema_max x x1
  
  axiom lstopgt_Int_Extrema_max_is_ub :
    forall a:int, b:int.
     a <= lstopgt_Int_Extrema_max a b /\ b <= lstopgt_Int_Extrema_max a b
  
  axiom lstopgt_Int_Extrema_max_is_lub :
    forall x:int, a:int, b:int.
     a <= x -> b <= x -> lstopgt_Int_Extrema_max a b <= x
  
  axiom lstopgt_Int_Extrema_max_is_extremum :
    forall a:int, b:int.
     lstopgt_Int_Extrema_max a b = a \/ lstopgt_Int_Extrema_max a b = b
  
  function div int int : int
  
  function mod int int : int
  
  axiom Div_mod :
    forall x:int, y:int. not y = 0 -> x = ((y * div x y) + mod x y)
  
  axiom Div_bound :
    forall x:int, y:int. x >= 0 /\ y > 0 -> 0 <= div x y /\ div x y <= x
  
  axiom Mod_bound :
    forall x:int, y:int. not y = 0 -> 0 <= mod x y /\ mod x y < abs y
  
  axiom Mod_1 : forall x:int. mod x 1 = 0
  
  axiom Div_1 : forall x:int. div x 1 = x
  
  axiom Div_inf : forall x:int, y:int. 0 <= x /\ x < y -> div x y = 0
  
  axiom Div_inf_neg :
    forall x:int, y:int. 0 < x /\ x <= y -> div (- x) y = (- 1)
  
  axiom Mod_0 : forall y:int. not y = 0 -> mod 0 y = 0
  
  axiom Div_1_left : forall y:int. y > 1 -> div 1 y = 0
  
  axiom Div_minus1_left : forall y:int. y > 1 -> div (- 1) y = (- 1)
  
  axiom Mod_1_left : forall y:int. y > 1 -> mod 1 y = 1
  
  axiom Mod_minus1_left : forall y:int. y > 1 -> mod (- 1) y = (y - 1)
  
  (* use int.EuclideanDivision *)
  
  constant div_ho : func int (func int int)
  
  axiom div_ho_spec : forall x:int, x1:int. ((div_ho @! x) @! x1) = div x x1
  
  constant mod_ho : func int (func int int)
  
  axiom mod_ho_spec : forall x:int, x1:int. ((mod_ho @! x) @! x1) = mod x x1
  
  (* clone algebra.Assoc with type t = int, function op = (*),
    prop Assoc1 = Assoc14 *)
  
  (* clone algebra.Monoid with type t1 = int, constant unit = one,
    function op1 = (*), prop Unit_def_r1 = Unit_def_r8,
    prop Unit_def_l1 = Unit_def_l8, prop Assoc2 = Assoc14 *)
  
  (* clone algebra.Comm with type t3 = int, function op3 = (*),
    prop Comm1 = Comm11 *)
  
  (* meta AC function (*) *)
  
  (* clone algebra.CommutativeMonoid with type t17 = int,
    constant unit3 = one, function op5 = (*), prop Comm12 = Comm11,
    prop Unit_def_r9 = Unit_def_r8, prop Unit_def_l9 = Unit_def_l8,
    prop Assoc15 = Assoc14 *)
  
  function power int int : int
  
  axiom Power_0 : forall x:int. power x 0 = one
  
  axiom Power_s :
    forall x:int, n:int. n >= 0 -> power x (n + 1) = (x * power x n)
  
  axiom Power_s_alt :
    forall x:int, n:int. n > 0 -> power x n = (x * power x (n - 1))
  
  axiom Power_1 : forall x:int. power x 1 = x
  
  axiom Power_sum :
    forall x:int, n:int, m:int.
     0 <= n -> 0 <= m -> power x (n + m) = (power x n * power x m)
  
  axiom Power_mult :
    forall x:int, n:int, m:int.
     0 <= n -> 0 <= m -> power x (n * m) = power (power x n) m
  
  axiom Power_mult2 :
    forall x:int, y:int, n:int.
     0 <= n -> power (x * y) n = (power x n * power y n)
  
  (* clone int.Exponentiation with type t18 = int, function power1 = power,
    function (*) = (*), constant one3 = one, prop Power_mult21 = Power_mult2,
    prop Power_mult1 = Power_mult, prop Power_sum1 = Power_sum,
    prop Power_11 = Power_1, prop Power_s_alt1 = Power_s_alt,
    prop Power_s1 = Power_s, prop Power_01 = Power_0, prop Comm13 = Comm11,
    prop Unit_def_r10 = Unit_def_r8, prop Unit_def_l10 = Unit_def_l8,
    prop Assoc16 = Assoc14 *)
  
  (* use int.Power *)
  
  constant power_ho : func int (func int int)
  
  axiom power_ho_spec :
    forall x:int, x1:int. ((power_ho @! x) @! x1) = power x x1
  
  axiom lstopgt_Int_Induction_induction :
    forall p:func int bool.
     (p @! 0) = True ->
      (forall j:int. 0 < j -> (p @! (j - 1)) = True -> (p @! j) = True) ->
       (forall i:int. 0 <= i -> (p @! i) = True)
  
  axiom lstopgt_Int_Induction_strongInduction :
    forall p:func int bool.
     (forall j:int.
       0 <= j ->
        (forall k:int. k >= 0 -> k < j -> (p @! k) = True) -> (p @! j) = True) ->
      (forall i:int. 0 <= i -> (p @! i) = True)
  
  axiom lstopgt_Logic_cut_lemma :
    forall a:bool, b:bool. a = True -> (a = True -> b = True) -> b = True
  
  axiom lstopgt_Logic_false_elim : forall c:bool. false -> c = True
  
  axiom lstopgt_Logic_and_elim :
    forall a:bool, b:bool, c:bool.
     a = True /\ b = True -> (a = True -> b = True -> c = True) -> c = True
  
  axiom lstopgt_Logic_and_proj_l :
    forall a:bool, b:bool. a = True /\ b = True -> a = True
  
  axiom lstopgt_Logic_and_proj_r :
    forall a:bool, b:bool. a = True /\ b = True -> b = True
  
  axiom lstopgt_Logic_anda_elim :
    forall a:bool, b:bool, c:bool.
     a = True && b = True -> (a = True -> b = True -> c = True) -> c = True
  
  axiom lstopgt_Logic_or_elim :
    forall a:bool, b:bool, c:bool.
     a = True \/ b = True ->
      (a = True -> c = True) -> (b = True -> c = True) -> c = True
  
  axiom lstopgt_Logic_ora_elim :
    forall a:bool, b:bool, c:bool.
     a = True || b = True ->
      (a = True -> c = True) ->
       (not a = True -> b = True -> c = True) -> c = True
  
  axiom lstopgt_Logic_iff_elim :
    forall a:bool, b:bool, c:bool.
     (a = True <-> b = True) ->
      ((a = True -> b = True) -> (b = True -> a = True) -> c = True) ->
       c = True
  
  axiom lstopgt_Logic_if_elim :
    forall a:bool, bt:bool, bf:bool, c:bool.
     (if a = True then bt else bf) = True ->
      (a = True -> bt = True -> c = True) ->
       (not a = True -> bf = True -> c = True) -> c = True
  
  axiom lstopgt_Logic_true_intro : true
  
  axiom lstopgt_Logic_and_intro :
    forall a:bool, b:bool. a = True -> b = True -> a = True /\ b = True
  
  axiom lstopgt_Logic_anda_intro :
    forall a:bool, b:bool.
     a = True -> (a = True -> b = True) -> a = True && b = True
  
  axiom lstopgt_Logic_or_intro_l :
    forall a:bool, b:bool. a = True -> a = True \/ b = True
  
  axiom lstopgt_Logic_ora_intro_l :
    forall a:bool, b:bool. a = True -> a = True || b = True
  
  axiom lstopgt_Logic_or_intro_r :
    forall a:bool, b:bool. b = True -> a = True \/ b = True
  
  axiom lstopgt_Logic_ora_intro_r :
    forall a:bool, b:bool. (not a = True -> b = True) -> a = True || b = True
  
  axiom lstopgt_Logic_iff_intro :
    forall a:bool, b:bool.
     (a = True -> b = True) ->
      (b = True -> a = True) -> a = True <-> b = True
  
  axiom lstopgt_Logic_if_intro :
    forall a:bool, bt:bool, bf:bool.
     (a = True -> bt = True) ->
      (not a = True -> bf = True) -> (if a = True then bt else bf) = True
  
  axiom lstopgt_Logic_rewrite_l :
    forall x1:'qta, x2:'qta, p:func 'qta bool.
     x1 = x2 -> (p @! x2) = True -> (p @! x1) = True
  
  axiom lstopgt_Logic_rewrite_r :
    forall x1:'qta, x2:'qta, p:func 'qta bool.
     x1 = x2 -> (p @! x1) = True -> (p @! x2) = True
  
  axiom lstopgt_Logic_rewrite_iff_l :
    forall x1:bool, x2:bool, p:func bool bool.
     (x1 = True <-> x2 = True) -> (p @! x2) = True -> (p @! x1) = True
  
  axiom lstopgt_Logic_rewrite_iff_r :
    forall x1:bool, x2:bool, p:func bool bool.
     (x1 = True <-> x2 = True) -> (p @! x1) = True -> (p @! x2) = True
  
  axiom lstopgt_Logic_case_eq_bool :
    forall p:func bool bool, x:bool.
     (x = True -> (p @! True) = True) ->
      (not x = True -> (p @! False) = True) -> (p @! x) = True
  
  axiom lstopgt_Logic_eq_refl : forall x:'qta. x = x
  
  axiom lstopgt_Logic_eqT : forall x:bool. x = True -> x = True
  
  axiom lstopgt_Logic_neqF : forall x:bool. not x = True -> x = False
  
  axiom lstopgt_Logic_eqT_iff : forall x:bool. x = True <-> x = True
  
  axiom lstopgt_Logic_neqF_iff : forall x:bool. x = False <-> not x = True
  
  type tuple2 'a 'a1 =
    | Tuple2 'a 'a1
  
  (* use Tuple21 *)
  
  axiom lstopgt_Logic_eq_tuple2_intro :
    forall x1:'qta1, x2:'qta2, y1:'qta1, y2:'qta2.
     x1 = y1 -> x2 = y2 -> (x1, x2) = (y1, y2)
  
  axiom lstopgt_Logic_eq_tuple2_elim :
    forall x1:'qta1, x2:'qta2, y1:'qta1, y2:'qta2, c:bool.
     (x1, x2) = (y1, y2) -> (x1 = y1 -> x2 = y2 -> c = True) -> c = True
  
  type tuple3 'a 'a1 'a2 =
    | Tuple3 'a 'a1 'a2
  
  (* use Tuple31 *)
  
  axiom lstopgt_Logic_eq_tuple3_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, y1:'qta1, y2:'qta2, y3:'qta3.
     x1 = y1 -> x2 = y2 -> x3 = y3 -> (x1, x2, x3) = (y1, y2, y3)
  
  axiom lstopgt_Logic_eq_tuple3_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, y1:'qta1, y2:'qta2, y3:'qta3, c:
     bool.
     (x1, x2, x3) = (y1, y2, y3) ->
      (x1 = y1 -> x2 = y2 -> x3 = y3 -> c = True) -> c = True
  
  type tuple4 'a 'a1 'a2 'a3 =
    | Tuple4 'a 'a1 'a2 'a3
  
  (* use Tuple41 *)
  
  axiom lstopgt_Logic_eq_tuple4_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, y1:'qta1, y2:'qta2, y3:
     'qta3, y4:'qta4.
     x1 = y1 ->
      x2 = y2 -> x3 = y3 -> x4 = y4 -> (x1, x2, x3, x4) = (y1, y2, y3, y4)
  
  axiom lstopgt_Logic_eq_tuple4_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, y1:'qta1, y2:'qta2, y3:
     'qta3, y4:'qta4, c:bool.
     (x1, x2, x3, x4) = (y1, y2, y3, y4) ->
      (x1 = y1 -> x2 = y2 -> x3 = y3 -> x4 = y4 -> c = True) -> c = True
  
  type tuple5 'a 'a1 'a2 'a3 'a4 =
    | Tuple5 'a 'a1 'a2 'a3 'a4
  
  (* use Tuple51 *)
  
  axiom lstopgt_Logic_eq_tuple5_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, y1:'qta1, y2:
     'qta2, y3:'qta3, y4:'qta4, y5:'qta5.
     x1 = y1 ->
      x2 = y2 ->
       x3 = y3 ->
        x4 = y4 -> x5 = y5 -> (x1, x2, x3, x4, x5) = (y1, y2, y3, y4, y5)
  
  axiom lstopgt_Logic_eq_tuple5_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, y1:'qta1, y2:
     'qta2, y3:'qta3, y4:'qta4, y5:'qta5, c:bool.
     (x1, x2, x3, x4, x5) = (y1, y2, y3, y4, y5) ->
      (x1 = y1 -> x2 = y2 -> x3 = y3 -> x4 = y4 -> x5 = y5 -> c = True) ->
       c = True
  
  type tuple6 'a 'a1 'a2 'a3 'a4 'a5 =
    | Tuple6 'a 'a1 'a2 'a3 'a4 'a5
  
  (* use Tuple61 *)
  
  axiom lstopgt_Logic_eq_tuple6_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, y1:
     'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:'qta6.
     x1 = y1 ->
      x2 = y2 ->
       x3 = y3 ->
        x4 = y4 ->
         x5 = y5 ->
          x6 = y6 -> (x1, x2, x3, x4, x5, x6) = (y1, y2, y3, y4, y5, y6)
  
  axiom lstopgt_Logic_eq_tuple6_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, y1:
     'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:'qta6, c:bool.
     (x1, x2, x3, x4, x5, x6) = (y1, y2, y3, y4, y5, y6) ->
      (x1 = y1 ->
        x2 = y2 -> x3 = y3 -> x4 = y4 -> x5 = y5 -> x6 = y6 -> c = True) ->
       c = True
  
  type tuple7 'a 'a1 'a2 'a3 'a4 'a5 'a6 =
    | Tuple7 'a 'a1 'a2 'a3 'a4 'a5 'a6
  
  (* use Tuple71 *)
  
  axiom lstopgt_Logic_eq_tuple7_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:'qta6, y7:
     'qta7.
     x1 = y1 ->
      x2 = y2 ->
       x3 = y3 ->
        x4 = y4 ->
         x5 = y5 ->
          x6 = y6 ->
           x7 = y7 ->
            (x1, x2, x3, x4, x5, x6, x7) = (y1, y2, y3, y4, y5, y6, y7)
  
  axiom lstopgt_Logic_eq_tuple7_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:'qta6, y7:
     'qta7, c:bool.
     (x1, x2, x3, x4, x5, x6, x7) = (y1, y2, y3, y4, y5, y6, y7) ->
      (x1 = y1 ->
        x2 = y2 ->
         x3 = y3 -> x4 = y4 -> x5 = y5 -> x6 = y6 -> x7 = y7 -> c = True) ->
       c = True
  
  type tuple8 'a 'a1 'a2 'a3 'a4 'a5 'a6
    'a7 =
    | Tuple8 'a 'a1 'a2 'a3 'a4 'a5 'a6 'a7
  
  (* use Tuple81 *)
  
  axiom lstopgt_Logic_eq_tuple8_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, x8:'qta8, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:
     'qta6, y7:'qta7, y8:'qta8.
     x1 = y1 ->
      x2 = y2 ->
       x3 = y3 ->
        x4 = y4 ->
         x5 = y5 ->
          x6 = y6 ->
           x7 = y7 ->
            x8 = y8 ->
             (x1, x2, x3, x4, x5, x6, x7, x8) = (y1, y2, y3, y4, y5, y6, y7,
              y8)
  
  axiom lstopgt_Logic_eq_tuple8_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, x8:'qta8, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:'qta5, y6:
     'qta6, y7:'qta7, y8:'qta8, c:bool.
     (x1, x2, x3, x4, x5, x6, x7, x8) = (y1, y2, y3, y4, y5, y6, y7, y8) ->
      (x1 = y1 ->
        x2 = y2 ->
         x3 = y3 ->
          x4 = y4 -> x5 = y5 -> x6 = y6 -> x7 = y7 -> x8 = y8 -> c = True) ->
       c = True
  
  type tuple9 'a 'a1 'a2 'a3 'a4 'a5 'a6 'a7
    'a8 =
    | Tuple9 'a 'a1 'a2 'a3 'a4 'a5 'a6 'a7 'a8
  
  (* use Tuple91 *)
  
  axiom lstopgt_Logic_eq_tuple9_intro :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, x8:'qta8, x9:'qta9, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:
     'qta5, y6:'qta6, y7:'qta7, y8:'qta8, y9:'qta9.
     x1 = y1 ->
      x2 = y2 ->
       x3 = y3 ->
        x4 = y4 ->
         x5 = y5 ->
          x6 = y6 ->
           x7 = y7 ->
            x8 = y8 ->
             x9 = y9 ->
              (x1, x2, x3, x4, x5, x6, x7, x8, x9) = (y1, y2, y3, y4, y5, y6,
               y7, y8, y9)
  
  axiom lstopgt_Logic_eq_tuple9_elim :
    forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
     'qta7, x8:'qta8, x9:'qta9, y1:'qta1, y2:'qta2, y3:'qta3, y4:'qta4, y5:
     'qta5, y6:'qta6, y7:'qta7, y8:'qta8, y9:'qta9, c:bool.
     (x1, x2, x3, x4, x5, x6, x7, x8, x9) = (y1, y2, y3, y4, y5, y6, y7, y8,
      y9) ->
      (x1 = y1 ->
        x2 = y2 ->
         x3 = y3 ->
          x4 = y4 ->
           x5 = y5 -> x6 = y6 -> x7 = y7 -> x8 = y8 -> x9 = y9 -> c = True) ->
       c = True
  
  axiom lstopgt_Logic_tuple2_ind :
    forall p:func ('qta1, 'qta2) bool, t:('qta1, 'qta2).
     (forall x1:'qta1, x2:'qta2. t = (x1, x2) -> (p @! (x1, x2)) = True) ->
      (p @! t) = True
  
  axiom lstopgt_Logic_tuple3_ind :
    forall p:func ('qta1, 'qta2, 'qta3) bool, t:('qta1, 'qta2, 'qta3).
     (forall x1:'qta1, x2:'qta2, x3:'qta3.
       t = (x1, x2, x3) -> (p @! (x1, x2, x3)) = True) -> (p @! t) = True
  
  axiom lstopgt_Logic_tuple4_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4) bool, t:('qta1, 'qta2, 'qta3,
     'qta4).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4.
       t = (x1, x2, x3, x4) -> (p @! (x1, x2, x3, x4)) = True) ->
      (p @! t) = True
  
  axiom lstopgt_Logic_tuple5_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4, 'qta5) bool, t:('qta1, 'qta2,
     'qta3, 'qta4, 'qta5).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5.
       t = (x1, x2, x3, x4, x5) -> (p @! (x1, x2, x3, x4, x5)) = True) ->
      (p @! t) = True
  
  axiom lstopgt_Logic_tuple6_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6) bool, t:('qta1,
     'qta2, 'qta3, 'qta4, 'qta5, 'qta6).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6.
       t = (x1, x2, x3, x4, x5, x6) -> (p @! (x1, x2, x3, x4, x5, x6)) = True) ->
      (p @! t) = True
  
  axiom lstopgt_Logic_tuple7_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7) bool, t:
     ('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
       'qta7.
       t = (x1, x2, x3, x4, x5, x6, x7) ->
        (p @! (x1, x2, x3, x4, x5, x6, x7)) = True) -> (p @! t) = True
  
  axiom lstopgt_Logic_tuple8_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7, 'qta8)
     bool, t:('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7, 'qta8).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
       'qta7, x8:'qta8.
       t = (x1, x2, x3, x4, x5, x6, x7, x8) ->
        (p @! (x1, x2, x3, x4, x5, x6, x7, x8)) = True) -> (p @! t) = True
  
  axiom lstopgt_Logic_tuple9_ind :
    forall p:func ('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7, 'qta8,
     'qta9) bool, t:('qta1, 'qta2, 'qta3, 'qta4, 'qta5, 'qta6, 'qta7, 'qta8,
     'qta9).
     (forall x1:'qta1, x2:'qta2, x3:'qta3, x4:'qta4, x5:'qta5, x6:'qta6, x7:
       'qta7, x8:'qta8, x9:'qta9.
       t = (x1, x2, x3, x4, x5, x6, x7, x8, x9) ->
        (p @! (x1, x2, x3, x4, x5, x6, x7, x8, x9)) = True) ->
      (p @! t) = True
  
  constant lstopgt_Adv : module
  
  constant lstopgt_Adv_q : name
  
  constant lstopgt_Adv_n : name
  
  constant lstopgt_Adv_g : name
  
  axiom lem :
    forall a:int, b:int, c:int, z:int. ((a + b) - c) = z -> (a + b) = (z + c)
  
  constant z : int
  
  constant etm : memory
  
  axiom h :
    ((get_var (mod_var lstopgt_Adv lstopgt_Adv_n:var int) etm +
       get_var (mod_var lstopgt_Adv lstopgt_Adv_q:var int) etm) -
      get_var (mod_var lstopgt_Adv lstopgt_Adv_g:var int) etm) = z
  
  goal goal1 :
    (get_var (mod_var lstopgt_Adv lstopgt_Adv_n:var int) etm +
      get_var (mod_var lstopgt_Adv lstopgt_Adv_q:var int) etm) =
     (z + get_var (mod_var lstopgt_Adv lstopgt_Adv_g:var int) etm)
end
